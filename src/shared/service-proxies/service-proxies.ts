/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.17.0.0 (NJsonSchema v9.10.42.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>Observable.throw(response_);
        });
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? IsTenantAvailableOutput.fromJS(resultData200) : new IsTenantAvailableOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processRegister(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegisterOutput>><any>Observable.throw(response_);
        });
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterOutput.fromJS(resultData200) : new RegisterOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<RegisterOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendPasswordResetCode(input: SendPasswordResetCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordInput | null | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processResetPassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>Observable.throw(response_);
        });
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ResetPasswordOutput.fromJS(resultData200) : new ResetPasswordOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ResetPasswordOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendEmailActivationLink(input: SendEmailActivationLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    activateEmail(input: ActivateEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processActivateEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    impersonate(input: ImpersonateInput | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processImpersonate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>Observable.throw(response_);
        });
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>Observable.throw(response_);
        });
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonateOutput.fromJS(resultData200) : new ImpersonateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ImpersonateOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    switchToLinkedAccount(input: SwitchToLinkedAccountInput | null | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>Observable.throw(response_);
        });
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchToLinkedAccountOutput.fromJS(resultData200) : new SwitchToLinkedAccountOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @serviceName (optional) 
     * @methodName (optional) 
     * @browserInfo (optional) 
     * @hasException (optional) 
     * @minExecutionDuration (optional) 
     * @maxExecutionDuration (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfAuditLogListDto.fromJS(resultData200) : new PagedResultDtoOfAuditLogListDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @serviceName (optional) 
     * @methodName (optional) 
     * @browserInfo (optional) 
     * @hasException (optional) 
     * @minExecutionDuration (optional) 
     * @maxExecutionDuration (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueDto.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<NameValueDto[]>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @entityTypeFullName (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfEntityChangeListDto.fromJS(resultData200) : new PagedResultDtoOfEntityChangeListDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @userName (optional) 
     * @entityTypeFullName (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileDto>><any>Observable.throw(response_);
        });
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileDto>(<any>null);
    }

    /**
     * @entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | null | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntityPropertyChangeDto.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class AutoCarrierServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCompanyCodeListAsync(): Observable<ListResultDtoOfCompanyCodeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoCarrier/GetCompanyCodeListAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCompanyCodeListAsync(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyCodeListAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCompanyCodeListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfCompanyCodeListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetCompanyCodeListAsync(response: HttpResponseBase): Observable<ListResultDtoOfCompanyCodeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCompanyCodeListDto.fromJS(resultData200) : new ListResultDtoOfCompanyCodeListDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListResultDtoOfCompanyCodeListDto>(<any>null);
    }

    /**
     * @companyCode (optional) 
     * @return Success
     */
    getCarrierRulesByCompanyCodeAsync(companyCode: string | null | undefined): Observable<ListResultDtoOfCarrierRuleDto> {
        let url_ = this.baseUrl + "/api/services/app/AutoCarrier/GetCarrierRulesByCompanyCodeAsync?";
        if (companyCode !== undefined)
            url_ += "companyCode=" + encodeURIComponent("" + companyCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCarrierRulesByCompanyCodeAsync(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCarrierRulesByCompanyCodeAsync(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCarrierRuleDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfCarrierRuleDto>><any>Observable.throw(response_);
        });
    }

    protected processGetCarrierRulesByCompanyCodeAsync(response: HttpResponseBase): Observable<ListResultDtoOfCarrierRuleDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCarrierRuleDto.fromJS(resultData200) : new ListResultDtoOfCarrierRuleDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListResultDtoOfCarrierRuleDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateOrInsertAutoCarrierRule(input: UpdateAutoCarrierRuleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AutoCarrier/UpdateOrInsertAutoCarrierRule";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateOrInsertAutoCarrierRule(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrInsertAutoCarrierRule(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateOrInsertAutoCarrierRule(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    putRuleClone(input: PutRuleCloneInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AutoCarrier/PutRuleClone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processPutRuleClone(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutRuleClone(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processPutRuleClone(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class AutomaticSortingMachineServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    update(input: AutomaticUpdateInput | null | undefined): Observable<AutomaticUpdateOutput> {
        let url_ = this.baseUrl + "/api/services/app/AutomaticSortingMachine/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AutomaticUpdateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<AutomaticUpdateOutput>><any>Observable.throw(response_);
        });
    }

    protected processUpdate(response: HttpResponseBase): Observable<AutomaticUpdateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AutomaticUpdateOutput.fromJS(resultData200) : new AutomaticUpdateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AutomaticUpdateOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    cUpdate(input: AutomaticUpdateInput | null | undefined): Observable<AutomaticUpdateOutput> {
        let url_ = this.baseUrl + "/api/services/app/AutomaticSortingMachine/CUpdate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCUpdate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCUpdate(<any>response_);
                } catch (e) {
                    return <Observable<AutomaticUpdateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<AutomaticUpdateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCUpdate(response: HttpResponseBase): Observable<AutomaticUpdateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AutomaticUpdateOutput.fromJS(resultData200) : new AutomaticUpdateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AutomaticUpdateOutput>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfCacheDto.fromJS(resultData200) : new ListResultDtoOfCacheDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    clearCache(input: EntityDtoOfString | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processClearCache(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserChatFriendsWithSettingsOutput.fromJS(resultData200) : new GetUserChatFriendsWithSettingsOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @tenantId (optional) 
     * @userId (optional) 
     * @minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | null | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>Observable.throw(response_);
        });
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfChatMessageDto.fromJS(resultData200) : new ListResultDtoOfChatMessageDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | null | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>Observable.throw(response_);
        });
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200) : new ListResultDtoOfSubscribableEditionComboboxItemDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    findUsers(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processFindUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>Observable.throw(response_);
        });
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDefaultEditionNameOutput.fromJS(resultData200) : new GetDefaultEditionNameOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @date (optional) 
     * @return Success
     */
    sendAndGetDate(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>Observable.throw(response_);
        });
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DateToStringOutput>(<any>null);
    }

    /**
     * @date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>Observable.throw(response_);
        });
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DateToStringOutput>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>Observable.throw(response_);
        });
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DateToStringOutput.fromJS(resultData200) : new DateToStringOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<DateToStringOutput>(<any>null);
    }

    /**
     * @searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCountries(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>Observable.throw(response_);
        });
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueOfString.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<NameValueOfString[]>(<any>null);
    }

    /**
     * @selectedCountries (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(selectedCountries: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectedCountries);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>Observable.throw(response_);
        });
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(NameValueOfString.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<NameValueOfString[]>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<StringOutput>><any>Observable.throw(response_);
        });
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StringOutput.fromJS(resultData200) : new StringOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<StringOutput>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEditions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfEditionListDto.fromJS(resultData200) : new ListResultDtoOfEditionListDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionEditOutput.fromJS(resultData200) : new GetEditionEditOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetEditionEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateEdition(input: CreateOrUpdateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateOrUpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrUpdateEdition(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteEdition(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @selectedEditionId (optional) 
     * @addAllItem (optional) 
     * @onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | null | undefined, onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SubscribableEditionComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createFriendshipRequest(input: CreateFriendshipRequestInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<FriendDto>><any>Observable.throw(response_);
        });
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FriendDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<FriendDto>><any>Observable.throw(response_);
        });
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FriendDto.fromJS(resultData200) : new FriendDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FriendDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    blockUser(input: BlockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processBlockUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unblockUser(input: UnblockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUnblockUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    acceptFriendshipRequest(input: AcceptFriendshipRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class G2MatrixCommoditiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @requset (optional) 
     * @app_key (optional) 
     * @method (optional) 
     * @sign (optional) 
     * @timestamp (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    createGoods(requset: G2CreateGoodsInput | null | undefined, app_key: string | null | undefined, method: string | null | undefined, sign: string | null | undefined, timestamp: moment.Moment | null | undefined, verify_sign: string | null | undefined): Observable<G2CreateGoodsOutput> {
        let url_ = this.baseUrl + "/api/services/app/G2MatrixCommodities/CreateGoods?";
        if (app_key !== undefined)
            url_ += "app_key=" + encodeURIComponent("" + app_key) + "&"; 
        if (method !== undefined)
            url_ += "method=" + encodeURIComponent("" + method) + "&"; 
        if (sign !== undefined)
            url_ += "sign=" + encodeURIComponent("" + sign) + "&"; 
        if (timestamp !== undefined)
            url_ += "timestamp=" + encodeURIComponent(timestamp ? "" + timestamp.toJSON() : "") + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requset);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateGoods(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateGoods(<any>response_);
                } catch (e) {
                    return <Observable<G2CreateGoodsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<G2CreateGoodsOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreateGoods(response: HttpResponseBase): Observable<G2CreateGoodsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? G2CreateGoodsOutput.fromJS(resultData200) : new G2CreateGoodsOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<G2CreateGoodsOutput>(<any>null);
    }
}

@Injectable()
export class G2MatrixEntryOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @app_key (optional) 
     * @method (optional) 
     * @sign (optional) 
     * @timestamp (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    creatReturnUnloadingInfor(input: G2EntryOrderCreatReturnUnloadingInforInput | null | undefined, app_key: string | null | undefined, method: string | null | undefined, sign: string | null | undefined, timestamp: moment.Moment | null | undefined, verify_sign: string | null | undefined): Observable<G2EntryOrderCreatReturnUnloadingInforOutput> {
        let url_ = this.baseUrl + "/api/services/app/G2MatrixEntryOrder/CreatReturnUnloadingInfor?";
        if (app_key !== undefined)
            url_ += "app_key=" + encodeURIComponent("" + app_key) + "&"; 
        if (method !== undefined)
            url_ += "method=" + encodeURIComponent("" + method) + "&"; 
        if (sign !== undefined)
            url_ += "sign=" + encodeURIComponent("" + sign) + "&"; 
        if (timestamp !== undefined)
            url_ += "timestamp=" + encodeURIComponent(timestamp ? "" + timestamp.toJSON() : "") + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreatReturnUnloadingInfor(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatReturnUnloadingInfor(<any>response_);
                } catch (e) {
                    return <Observable<G2EntryOrderCreatReturnUnloadingInforOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<G2EntryOrderCreatReturnUnloadingInforOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreatReturnUnloadingInfor(response: HttpResponseBase): Observable<G2EntryOrderCreatReturnUnloadingInforOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? G2EntryOrderCreatReturnUnloadingInforOutput.fromJS(resultData200) : new G2EntryOrderCreatReturnUnloadingInforOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<G2EntryOrderCreatReturnUnloadingInforOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @app_key (optional) 
     * @method (optional) 
     * @sign (optional) 
     * @timestamp (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    creatUnloadingInfor(input: G2EntryOrderCreatUnloadingInforInput | null | undefined, app_key: string | null | undefined, method: string | null | undefined, sign: string | null | undefined, timestamp: moment.Moment | null | undefined, verify_sign: string | null | undefined): Observable<G2EntryOrderCreatUnloadingInforOutput> {
        let url_ = this.baseUrl + "/api/services/app/G2MatrixEntryOrder/CreatUnloadingInfor?";
        if (app_key !== undefined)
            url_ += "app_key=" + encodeURIComponent("" + app_key) + "&"; 
        if (method !== undefined)
            url_ += "method=" + encodeURIComponent("" + method) + "&"; 
        if (sign !== undefined)
            url_ += "sign=" + encodeURIComponent("" + sign) + "&"; 
        if (timestamp !== undefined)
            url_ += "timestamp=" + encodeURIComponent(timestamp ? "" + timestamp.toJSON() : "") + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreatUnloadingInfor(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatUnloadingInfor(<any>response_);
                } catch (e) {
                    return <Observable<G2EntryOrderCreatUnloadingInforOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<G2EntryOrderCreatUnloadingInforOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreatUnloadingInfor(response: HttpResponseBase): Observable<G2EntryOrderCreatUnloadingInforOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? G2EntryOrderCreatUnloadingInforOutput.fromJS(resultData200) : new G2EntryOrderCreatUnloadingInforOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<G2EntryOrderCreatUnloadingInforOutput>(<any>null);
    }
}

@Injectable()
export class G2MatrixOutBoundOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @app_key (optional) 
     * @method (optional) 
     * @sign (optional) 
     * @timestamp (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    outBoundInfor(input: G2OutBoundInforInput | null | undefined, app_key: string | null | undefined, method: string | null | undefined, sign: string | null | undefined, timestamp: moment.Moment | null | undefined, verify_sign: string | null | undefined): Observable<G2OutBoundInforOutput> {
        let url_ = this.baseUrl + "/api/services/app/G2MatrixOutBoundOrder/OutBoundInfor?";
        if (app_key !== undefined)
            url_ += "app_key=" + encodeURIComponent("" + app_key) + "&"; 
        if (method !== undefined)
            url_ += "method=" + encodeURIComponent("" + method) + "&"; 
        if (sign !== undefined)
            url_ += "sign=" + encodeURIComponent("" + sign) + "&"; 
        if (timestamp !== undefined)
            url_ += "timestamp=" + encodeURIComponent(timestamp ? "" + timestamp.toJSON() : "") + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processOutBoundInfor(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOutBoundInfor(<any>response_);
                } catch (e) {
                    return <Observable<G2OutBoundInforOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<G2OutBoundInforOutput>><any>Observable.throw(response_);
        });
    }

    protected processOutBoundInfor(response: HttpResponseBase): Observable<G2OutBoundInforOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? G2OutBoundInforOutput.fromJS(resultData200) : new G2OutBoundInforOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<G2OutBoundInforOutput>(<any>null);
    }
}

@Injectable()
export class G2MatrixSaleOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @app_key (optional) 
     * @method (optional) 
     * @sign (optional) 
     * @timestamp (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    syncInsertOrders(input: SaleOrderSyncInsertOrdersInput | null | undefined, app_key: string | null | undefined, method: string | null | undefined, sign: string | null | undefined, timestamp: moment.Moment | null | undefined, verify_sign: string | null | undefined): Observable<SaleOrderSyncInsertOrdersOutput> {
        let url_ = this.baseUrl + "/api/services/app/G2MatrixSaleOrder/SyncInsertOrders?";
        if (app_key !== undefined)
            url_ += "app_key=" + encodeURIComponent("" + app_key) + "&"; 
        if (method !== undefined)
            url_ += "method=" + encodeURIComponent("" + method) + "&"; 
        if (sign !== undefined)
            url_ += "sign=" + encodeURIComponent("" + sign) + "&"; 
        if (timestamp !== undefined)
            url_ += "timestamp=" + encodeURIComponent(timestamp ? "" + timestamp.toJSON() : "") + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSyncInsertOrders(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncInsertOrders(<any>response_);
                } catch (e) {
                    return <Observable<SaleOrderSyncInsertOrdersOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SaleOrderSyncInsertOrdersOutput>><any>Observable.throw(response_);
        });
    }

    protected processSyncInsertOrders(response: HttpResponseBase): Observable<SaleOrderSyncInsertOrdersOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SaleOrderSyncInsertOrdersOutput.fromJS(resultData200) : new SaleOrderSyncInsertOrdersOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SaleOrderSyncInsertOrdersOutput>(<any>null);
    }
}

@Injectable()
export class G2MatrixSupplyDistributeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @app_key (optional) 
     * @method (optional) 
     * @sign (optional) 
     * @timestamp (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    cancelAllOrders(input: G2CancelOrdersInput | null | undefined, app_key: string | null | undefined, method: string | null | undefined, sign: string | null | undefined, timestamp: moment.Moment | null | undefined, verify_sign: string | null | undefined): Observable<SupplyDistributeCancelAllOrdersOutput> {
        let url_ = this.baseUrl + "/api/services/app/G2MatrixSupplyDistribute/CancelAllOrders?";
        if (app_key !== undefined)
            url_ += "app_key=" + encodeURIComponent("" + app_key) + "&"; 
        if (method !== undefined)
            url_ += "method=" + encodeURIComponent("" + method) + "&"; 
        if (sign !== undefined)
            url_ += "sign=" + encodeURIComponent("" + sign) + "&"; 
        if (timestamp !== undefined)
            url_ += "timestamp=" + encodeURIComponent(timestamp ? "" + timestamp.toJSON() : "") + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCancelAllOrders(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelAllOrders(<any>response_);
                } catch (e) {
                    return <Observable<SupplyDistributeCancelAllOrdersOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SupplyDistributeCancelAllOrdersOutput>><any>Observable.throw(response_);
        });
    }

    protected processCancelAllOrders(response: HttpResponseBase): Observable<SupplyDistributeCancelAllOrdersOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SupplyDistributeCancelAllOrdersOutput.fromJS(resultData200) : new SupplyDistributeCancelAllOrdersOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SupplyDistributeCancelAllOrdersOutput>(<any>null);
    }
}

@Injectable()
export class HangfireSampleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    test(input: HangfireSampleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HangfireSample/Test";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processTest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processTest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @incomeStatisticsDateInterval (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: IncomeStatisticsDateInterval | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval !== undefined)
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetDashboardStatisticsData(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatisticsData(<any>response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>Observable.throw(e);
                }
            } else
                return <Observable<HostDashboardData>><any>Observable.throw(response_);
        });
    }

    protected processGetDashboardStatisticsData(response: HttpResponseBase): Observable<HostDashboardData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostDashboardData.fromJS(resultData200) : new HostDashboardData();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HostDashboardData>(<any>null);
    }

    /**
     * @incomeStatisticsDateInterval (optional) 
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: IncomeStatisticsDateInterval2 | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval !== undefined)
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetIncomeStatisticsDataOutput.fromJS(resultData200) : new GetIncomeStatisticsDataOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @startDate (optional) 
     * @endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetEditionTenantStatisticsOutput.fromJS(resultData200) : new GetEditionTenantStatisticsOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HostSettingsEditDto.fromJS(resultData200) : new HostSettingsEditDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HostSettingsEditDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateAllSettings(input: HostSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setup(input: InstallDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSetup(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AppSettingsJsonDto.fromJS(resultData200) : new AppSettingsJsonDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>Observable.throw(response_);
        });
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CheckDatabaseOutput.fromJS(resultData200) : new CheckDatabaseOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | null | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<InvoiceDto>><any>Observable.throw(response_);
        });
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InvoiceDto.fromJS(resultData200) : new InvoiceDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<InvoiceDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createInvoice(input: CreateInvoiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetLanguages(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguagesOutput.fromJS(resultData200) : new GetLanguagesOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetLanguagesOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLanguageForEditOutput.fromJS(resultData200) : new GetLanguageForEditOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateLanguage(input: CreateOrUpdateLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setDefaultLanguage(input: SetDefaultLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @sorting (optional) 
     * @baseLanguageName (optional) 
     * @targetValueFilter (optional) 
     * @filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLanguageTextListDto.fromJS(resultData200) : new PagedResultDtoOfLanguageTextListDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateLanguageText(input: UpdateLanguageTextInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class Lk02OutboundOrderReportDatasServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @warehouseCode (optional) 
     * @companyCode (optional) 
     * @code (optional) 
     * @leadingSts (optional) 
     * @trailingSts (optional) 
     * @shipmentType (optional) 
     * @shipToCity (optional) 
     * @shipToState (optional) 
     * @processType (optional) 
     * @created (optional) 
     * @actualShipDateTime (optional) 
     * @carrierCode (optional) 
     * @endDateTime (optional) 
     * @startWithinLimitedHoursIsNotProduced (optional) 
     * @endWithinLimitedHoursIsNotProduced (optional) 
     * @return Success
     */
    getOrders(warehouseCode: string | null | undefined, companyCode: string | null | undefined, code: string | null | undefined, leadingSts: number | null | undefined, trailingSts: number | null | undefined, shipmentType: string | null | undefined, shipToCity: string | null | undefined, shipToState: string | null | undefined, processType: string | null | undefined, created: moment.Moment | null | undefined, actualShipDateTime: moment.Moment | null | undefined, carrierCode: string | null | undefined, endDateTime: moment.Moment | null | undefined, startWithinLimitedHoursIsNotProduced: number | null | undefined, endWithinLimitedHoursIsNotProduced: number | null | undefined): Observable<Lk02OutboundOrderReportDatasGetOrdersOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Lk02OutboundOrderReportDatas/GetOrders?";
        if (warehouseCode !== undefined)
            url_ += "WarehouseCode=" + encodeURIComponent("" + warehouseCode) + "&"; 
        if (companyCode !== undefined)
            url_ += "CompanyCode=" + encodeURIComponent("" + companyCode) + "&"; 
        if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&"; 
        if (leadingSts !== undefined)
            url_ += "LeadingSts=" + encodeURIComponent("" + leadingSts) + "&"; 
        if (trailingSts !== undefined)
            url_ += "TrailingSts=" + encodeURIComponent("" + trailingSts) + "&"; 
        if (shipmentType !== undefined)
            url_ += "ShipmentType=" + encodeURIComponent("" + shipmentType) + "&"; 
        if (shipToCity !== undefined)
            url_ += "ShipToCity=" + encodeURIComponent("" + shipToCity) + "&"; 
        if (shipToState !== undefined)
            url_ += "ShipToState=" + encodeURIComponent("" + shipToState) + "&"; 
        if (processType !== undefined)
            url_ += "ProcessType=" + encodeURIComponent("" + processType) + "&"; 
        if (created !== undefined)
            url_ += "Created=" + encodeURIComponent(created ? "" + created.toJSON() : "") + "&"; 
        if (actualShipDateTime !== undefined)
            url_ += "ActualShipDateTime=" + encodeURIComponent(actualShipDateTime ? "" + actualShipDateTime.toJSON() : "") + "&"; 
        if (carrierCode !== undefined)
            url_ += "CarrierCode=" + encodeURIComponent("" + carrierCode) + "&"; 
        if (endDateTime !== undefined)
            url_ += "EndDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toJSON() : "") + "&"; 
        if (startWithinLimitedHoursIsNotProduced !== undefined)
            url_ += "StartWithinLimitedHoursIsNotProduced=" + encodeURIComponent("" + startWithinLimitedHoursIsNotProduced) + "&"; 
        if (endWithinLimitedHoursIsNotProduced !== undefined)
            url_ += "EndWithinLimitedHoursIsNotProduced=" + encodeURIComponent("" + endWithinLimitedHoursIsNotProduced) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetOrders(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrders(<any>response_);
                } catch (e) {
                    return <Observable<Lk02OutboundOrderReportDatasGetOrdersOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Lk02OutboundOrderReportDatasGetOrdersOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetOrders(response: HttpResponseBase): Observable<Lk02OutboundOrderReportDatasGetOrdersOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Lk02OutboundOrderReportDatasGetOrdersOutput.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Lk02OutboundOrderReportDatasGetOrdersOutput[]>(<any>null);
    }

    /**
     * @return Success
     */
    getOwnerCodes(): Observable<Lk02OutboundOrderReportDatasGetOwnerCodesOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Lk02OutboundOrderReportDatas/GetOwnerCodes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetOwnerCodes(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnerCodes(<any>response_);
                } catch (e) {
                    return <Observable<Lk02OutboundOrderReportDatasGetOwnerCodesOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Lk02OutboundOrderReportDatasGetOwnerCodesOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetOwnerCodes(response: HttpResponseBase): Observable<Lk02OutboundOrderReportDatasGetOwnerCodesOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Lk02OutboundOrderReportDatasGetOwnerCodesOutput.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Lk02OutboundOrderReportDatasGetOwnerCodesOutput[]>(<any>null);
    }

    /**
     * @warehouseCode (optional) 
     * @return Success
     */
    getOwnerCodesByWarehouseCode(warehouseCode: string | null | undefined): Observable<Lk02OutboundOrderReportDatasGetOwnerCodesOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Lk02OutboundOrderReportDatas/GetOwnerCodesByWarehouseCode?";
        if (warehouseCode !== undefined)
            url_ += "warehouseCode=" + encodeURIComponent("" + warehouseCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetOwnerCodesByWarehouseCode(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnerCodesByWarehouseCode(<any>response_);
                } catch (e) {
                    return <Observable<Lk02OutboundOrderReportDatasGetOwnerCodesOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<Lk02OutboundOrderReportDatasGetOwnerCodesOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetOwnerCodesByWarehouseCode(response: HttpResponseBase): Observable<Lk02OutboundOrderReportDatasGetOwnerCodesOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(Lk02OutboundOrderReportDatasGetOwnerCodesOutput.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<Lk02OutboundOrderReportDatasGetOwnerCodesOutput[]>(<any>null);
    }

    /**
     * @orderCreatedTime (optional) 
     * @return Success
     */
    getEachStatusOrderAmount(orderCreatedTime: moment.Moment | null | undefined, warehouseCode: string): Observable<GetEachStatusOrderAmountOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Lk02OutboundOrderReportDatas/GetEachStatusOrderAmount?";
        if (orderCreatedTime !== undefined)
            url_ += "OrderCreatedTime=" + encodeURIComponent(orderCreatedTime ? "" + orderCreatedTime.toJSON() : "") + "&"; 
        if (warehouseCode === undefined || warehouseCode === null)
            throw new Error("The parameter 'warehouseCode' must be defined and cannot be null.");
        else
            url_ += "WarehouseCode=" + encodeURIComponent("" + warehouseCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEachStatusOrderAmount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEachStatusOrderAmount(<any>response_);
                } catch (e) {
                    return <Observable<GetEachStatusOrderAmountOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetEachStatusOrderAmountOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetEachStatusOrderAmount(response: HttpResponseBase): Observable<GetEachStatusOrderAmountOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetEachStatusOrderAmountOutput.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetEachStatusOrderAmountOutput[]>(<any>null);
    }

    /**
     * @orderCreatedTime (optional) 
     * @return Success
     */
    getEachProvinceOrderAmount(orderCreatedTime: moment.Moment | null | undefined, warehouseCode: string): Observable<GetEachProvinceOrderAmountOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Lk02OutboundOrderReportDatas/GetEachProvinceOrderAmount?";
        if (orderCreatedTime !== undefined)
            url_ += "OrderCreatedTime=" + encodeURIComponent(orderCreatedTime ? "" + orderCreatedTime.toJSON() : "") + "&"; 
        if (warehouseCode === undefined || warehouseCode === null)
            throw new Error("The parameter 'warehouseCode' must be defined and cannot be null.");
        else
            url_ += "WarehouseCode=" + encodeURIComponent("" + warehouseCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEachProvinceOrderAmount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEachProvinceOrderAmount(<any>response_);
                } catch (e) {
                    return <Observable<GetEachProvinceOrderAmountOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetEachProvinceOrderAmountOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetEachProvinceOrderAmount(response: HttpResponseBase): Observable<GetEachProvinceOrderAmountOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetEachProvinceOrderAmountOutput.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetEachProvinceOrderAmountOutput[]>(<any>null);
    }

    /**
     * @orderCreatedTime (optional) 
     * @return Success
     */
    getEachCarrierOrderAmount(orderCreatedTime: moment.Moment | null | undefined, warehouseCode: string): Observable<GetEachCarrierOrderAmountOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Lk02OutboundOrderReportDatas/GetEachCarrierOrderAmount?";
        if (orderCreatedTime !== undefined)
            url_ += "OrderCreatedTime=" + encodeURIComponent(orderCreatedTime ? "" + orderCreatedTime.toJSON() : "") + "&"; 
        if (warehouseCode === undefined || warehouseCode === null)
            throw new Error("The parameter 'warehouseCode' must be defined and cannot be null.");
        else
            url_ += "WarehouseCode=" + encodeURIComponent("" + warehouseCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEachCarrierOrderAmount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEachCarrierOrderAmount(<any>response_);
                } catch (e) {
                    return <Observable<GetEachCarrierOrderAmountOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetEachCarrierOrderAmountOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetEachCarrierOrderAmount(response: HttpResponseBase): Observable<GetEachCarrierOrderAmountOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetEachCarrierOrderAmountOutput.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetEachCarrierOrderAmountOutput[]>(<any>null);
    }

    /**
     * @orderCreatedTime (optional) 
     * @orderEndCreatedTime (optional) 
     * @warehouseCode (optional) 
     * @return Success
     */
    getEachCarrierAssignStatusOrderAmount(orderCreatedTime: moment.Moment | null | undefined, orderEndCreatedTime: moment.Moment | null | undefined, warehouseCode: string | null | undefined, statusArray: number[]): Observable<GetEachCarrierAssignStatusOrderAmountOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Lk02OutboundOrderReportDatas/GetEachCarrierAssignStatusOrderAmount?";
        if (orderCreatedTime !== undefined)
            url_ += "OrderCreatedTime=" + encodeURIComponent(orderCreatedTime ? "" + orderCreatedTime.toJSON() : "") + "&"; 
        if (orderEndCreatedTime !== undefined)
            url_ += "OrderEndCreatedTime=" + encodeURIComponent(orderEndCreatedTime ? "" + orderEndCreatedTime.toJSON() : "") + "&"; 
        if (warehouseCode !== undefined)
            url_ += "WarehouseCode=" + encodeURIComponent("" + warehouseCode) + "&"; 
        if (statusArray === undefined || statusArray === null)
            throw new Error("The parameter 'statusArray' must be defined and cannot be null.");
        else
            statusArray && statusArray.forEach(item => { url_ += "StatusArray=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEachCarrierAssignStatusOrderAmount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEachCarrierAssignStatusOrderAmount(<any>response_);
                } catch (e) {
                    return <Observable<GetEachCarrierAssignStatusOrderAmountOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetEachCarrierAssignStatusOrderAmountOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetEachCarrierAssignStatusOrderAmount(response: HttpResponseBase): Observable<GetEachCarrierAssignStatusOrderAmountOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetEachCarrierAssignStatusOrderAmountOutput.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetEachCarrierAssignStatusOrderAmountOutput[]>(<any>null);
    }

    /**
     * @orderCreatedTime (optional) 
     * @return Success
     */
    getEachOwnerAndStatusOrderAmount(orderCreatedTime: moment.Moment | null | undefined, warehouseCode: string): Observable<GetEachOwnerAndStatusOrderAmountOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Lk02OutboundOrderReportDatas/GetEachOwnerAndStatusOrderAmount?";
        if (orderCreatedTime !== undefined)
            url_ += "OrderCreatedTime=" + encodeURIComponent(orderCreatedTime ? "" + orderCreatedTime.toJSON() : "") + "&"; 
        if (warehouseCode === undefined || warehouseCode === null)
            throw new Error("The parameter 'warehouseCode' must be defined and cannot be null.");
        else
            url_ += "WarehouseCode=" + encodeURIComponent("" + warehouseCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEachOwnerAndStatusOrderAmount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEachOwnerAndStatusOrderAmount(<any>response_);
                } catch (e) {
                    return <Observable<GetEachOwnerAndStatusOrderAmountOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetEachOwnerAndStatusOrderAmountOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetEachOwnerAndStatusOrderAmount(response: HttpResponseBase): Observable<GetEachOwnerAndStatusOrderAmountOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetEachOwnerAndStatusOrderAmountOutput.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetEachOwnerAndStatusOrderAmountOutput[]>(<any>null);
    }

    /**
     * @orderCreatedTime (optional) 
     * @orderEndCreatedTime (optional) 
     * @return Success
     */
    getAssignOwnerAndStatusOrderAmount(ownerCode: string, orderCreatedTime: moment.Moment | null | undefined, orderEndCreatedTime: moment.Moment | null | undefined, statusArray: number[]): Observable<GetEachOwnerAndStatusOrderAmountOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Lk02OutboundOrderReportDatas/GetAssignOwnerAndStatusOrderAmount?";
        if (ownerCode === undefined || ownerCode === null)
            throw new Error("The parameter 'ownerCode' must be defined and cannot be null.");
        else
            url_ += "OwnerCode=" + encodeURIComponent("" + ownerCode) + "&"; 
        if (orderCreatedTime !== undefined)
            url_ += "OrderCreatedTime=" + encodeURIComponent(orderCreatedTime ? "" + orderCreatedTime.toJSON() : "") + "&"; 
        if (orderEndCreatedTime !== undefined)
            url_ += "OrderEndCreatedTime=" + encodeURIComponent(orderEndCreatedTime ? "" + orderEndCreatedTime.toJSON() : "") + "&"; 
        if (statusArray === undefined || statusArray === null)
            throw new Error("The parameter 'statusArray' must be defined and cannot be null.");
        else
            statusArray && statusArray.forEach(item => { url_ += "StatusArray=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAssignOwnerAndStatusOrderAmount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssignOwnerAndStatusOrderAmount(<any>response_);
                } catch (e) {
                    return <Observable<GetEachOwnerAndStatusOrderAmountOutput[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetEachOwnerAndStatusOrderAmountOutput[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAssignOwnerAndStatusOrderAmount(response: HttpResponseBase): Observable<GetEachOwnerAndStatusOrderAmountOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(GetEachOwnerAndStatusOrderAmountOutput.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetEachOwnerAndStatusOrderAmountOutput[]>(<any>null);
    }

    /**
     * @queryStartTime (optional) 
     * @queryEndTime (optional) 
     * @isActive (optional) 
     * @return Success
     */
    getPackageAmount(queryStartTime: moment.Moment | null | undefined, queryEndTime: moment.Moment | null | undefined, warehouseCode: string, isActive: boolean | null | undefined): Observable<GetPackageAmountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Lk02OutboundOrderReportDatas/GetPackageAmount?";
        if (queryStartTime !== undefined)
            url_ += "QueryStartTime=" + encodeURIComponent(queryStartTime ? "" + queryStartTime.toJSON() : "") + "&"; 
        if (queryEndTime !== undefined)
            url_ += "QueryEndTime=" + encodeURIComponent(queryEndTime ? "" + queryEndTime.toJSON() : "") + "&"; 
        if (warehouseCode === undefined || warehouseCode === null)
            throw new Error("The parameter 'warehouseCode' must be defined and cannot be null.");
        else
            url_ += "WarehouseCode=" + encodeURIComponent("" + warehouseCode) + "&"; 
        if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetPackageAmount(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackageAmount(<any>response_);
                } catch (e) {
                    return <Observable<GetPackageAmountOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetPackageAmountOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetPackageAmount(response: HttpResponseBase): Observable<GetPackageAmountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPackageAmountOutput.fromJS(resultData200) : new GetPackageAmountOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetPackageAmountOutput>(<any>null);
    }

    /**
     * @queryStartTime (optional) 
     * @minTotalWeight (optional) 
     * @maxTotalWeight (optional) 
     * @return Success
     */
    getOrderAmountByWeight(queryStartTime: moment.Moment | null | undefined, warehouseCode: string, minTotalWeight: number | null | undefined, maxTotalWeight: number | null | undefined): Observable<GetOrderAmountByWeightOutput> {
        let url_ = this.baseUrl + "/api/services/app/Lk02OutboundOrderReportDatas/GetOrderAmountByWeight?";
        if (queryStartTime !== undefined)
            url_ += "QueryStartTime=" + encodeURIComponent(queryStartTime ? "" + queryStartTime.toJSON() : "") + "&"; 
        if (warehouseCode === undefined || warehouseCode === null)
            throw new Error("The parameter 'warehouseCode' must be defined and cannot be null.");
        else
            url_ += "WarehouseCode=" + encodeURIComponent("" + warehouseCode) + "&"; 
        if (minTotalWeight !== undefined)
            url_ += "MinTotalWeight=" + encodeURIComponent("" + minTotalWeight) + "&"; 
        if (maxTotalWeight !== undefined)
            url_ += "MaxTotalWeight=" + encodeURIComponent("" + maxTotalWeight) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetOrderAmountByWeight(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderAmountByWeight(<any>response_);
                } catch (e) {
                    return <Observable<GetOrderAmountByWeightOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetOrderAmountByWeightOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetOrderAmountByWeight(response: HttpResponseBase): Observable<GetOrderAmountByWeightOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetOrderAmountByWeightOutput.fromJS(resultData200) : new GetOrderAmountByWeightOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetOrderAmountByWeightOutput>(<any>null);
    }

    /**
     * @queryStartTime (optional) 
     * @queryEndTime (optional) 
     * @return Success
     */
    getOrderAmountByCreateTime(queryStartTime: moment.Moment | null | undefined, queryEndTime: moment.Moment | null | undefined, warehouseCode: string): Observable<GetOrderAmountByCreateTimeOutput> {
        let url_ = this.baseUrl + "/api/services/app/Lk02OutboundOrderReportDatas/GetOrderAmountByCreateTime?";
        if (queryStartTime !== undefined)
            url_ += "QueryStartTime=" + encodeURIComponent(queryStartTime ? "" + queryStartTime.toJSON() : "") + "&"; 
        if (queryEndTime !== undefined)
            url_ += "QueryEndTime=" + encodeURIComponent(queryEndTime ? "" + queryEndTime.toJSON() : "") + "&"; 
        if (warehouseCode === undefined || warehouseCode === null)
            throw new Error("The parameter 'warehouseCode' must be defined and cannot be null.");
        else
            url_ += "WarehouseCode=" + encodeURIComponent("" + warehouseCode) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetOrderAmountByCreateTime(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrderAmountByCreateTime(<any>response_);
                } catch (e) {
                    return <Observable<GetOrderAmountByCreateTimeOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetOrderAmountByCreateTimeOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetOrderAmountByCreateTime(response: HttpResponseBase): Observable<GetOrderAmountByCreateTimeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetOrderAmountByCreateTimeOutput.fromJS(resultData200) : new GetOrderAmountByCreateTimeOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetOrderAmountByCreateTimeOutput>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @state (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: State | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationsOutput.fromJS(resultData200) : new GetNotificationsOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    setNotificationAsRead(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetNotificationSettingsOutput.fromJS(resultData200) : new GetNotificationSettingsOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateNotificationSettings(input: UpdateNotificationSettingsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>Observable.throw(response_);
        });
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfOrganizationUnitDto.fromJS(resultData200) : new ListResultDtoOfOrganizationUnitDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200) : new PagedResultDtoOfOrganizationUnitUserListDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrganizationUnit(input: CreateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationUnitDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateOrganizationUnit(input: UpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>Observable.throw(response_);
        });
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationUnitDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    moveOrganizationUnit(input: MoveOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>Observable.throw(response_);
        });
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationUnitDto.fromJS(resultData200) : new OrganizationUnitDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationUnitDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @userId (optional) 
     * @organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(input: UsersToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    findUsers(input: FindOrganizationUnitUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processFindUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>Observable.throw(response_);
        });
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfNameValueDto.fromJS(resultData200) : new PagedResultDtoOfNameValueDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class OwnerGroupMembersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @ownerCodeFilter (optional) 
     * @ownerNameFilter (optional) 
     * @ownerGroupGroupNameFilter (optional) 
     * @sorting (optional) 
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, ownerCodeFilter: string | null | undefined, ownerNameFilter: string | null | undefined, ownerGroupGroupNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetOwnerGroupMemberForView> {
        let url_ = this.baseUrl + "/api/services/app/OwnerGroupMembers/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (ownerCodeFilter !== undefined)
            url_ += "OwnerCodeFilter=" + encodeURIComponent("" + ownerCodeFilter) + "&"; 
        if (ownerNameFilter !== undefined)
            url_ += "OwnerNameFilter=" + encodeURIComponent("" + ownerNameFilter) + "&"; 
        if (ownerGroupGroupNameFilter !== undefined)
            url_ += "OwnerGroupGroupNameFilter=" + encodeURIComponent("" + ownerGroupGroupNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetOwnerGroupMemberForView>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetOwnerGroupMemberForView>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetOwnerGroupMemberForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetOwnerGroupMemberForView.fromJS(resultData200) : new PagedResultDtoOfGetOwnerGroupMemberForView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfGetOwnerGroupMemberForView>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getOwnerGroupMemberForEdit(id: number | null | undefined): Observable<GetOwnerGroupMemberForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/OwnerGroupMembers/GetOwnerGroupMemberForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetOwnerGroupMemberForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnerGroupMemberForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetOwnerGroupMemberForEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetOwnerGroupMemberForEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetOwnerGroupMemberForEdit(response: HttpResponseBase): Observable<GetOwnerGroupMemberForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetOwnerGroupMemberForEditOutput.fromJS(resultData200) : new GetOwnerGroupMemberForEditOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetOwnerGroupMemberForEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditOwnerGroupMemberDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OwnerGroupMembers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OwnerGroupMembers/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @filter (optional) 
     * @sorting (optional) 
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    getAllOwnerGroupForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfOwnerGroupLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/OwnerGroupMembers/GetAllOwnerGroupForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllOwnerGroupForLookupTable(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOwnerGroupForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOwnerGroupLookupTableDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfOwnerGroupLookupTableDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAllOwnerGroupForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfOwnerGroupLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfOwnerGroupLookupTableDto.fromJS(resultData200) : new PagedResultDtoOfOwnerGroupLookupTableDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfOwnerGroupLookupTableDto>(<any>null);
    }
}

@Injectable()
export class OwnerGroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @groupCodeFilter (optional) 
     * @groupNameFilter (optional) 
     * @sorting (optional) 
     * @skipCount (optional) 
     * @maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, groupCodeFilter: string | null | undefined, groupNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetOwnerGroupForView> {
        let url_ = this.baseUrl + "/api/services/app/OwnerGroups/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (groupCodeFilter !== undefined)
            url_ += "GroupCodeFilter=" + encodeURIComponent("" + groupCodeFilter) + "&"; 
        if (groupNameFilter !== undefined)
            url_ += "GroupNameFilter=" + encodeURIComponent("" + groupNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetOwnerGroupForView>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetOwnerGroupForView>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetOwnerGroupForView> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfGetOwnerGroupForView.fromJS(resultData200) : new PagedResultDtoOfGetOwnerGroupForView();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfGetOwnerGroupForView>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getOwnerGroupForEdit(id: number | null | undefined): Observable<GetOwnerGroupForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/OwnerGroups/GetOwnerGroupForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetOwnerGroupForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOwnerGroupForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetOwnerGroupForEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetOwnerGroupForEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetOwnerGroupForEdit(response: HttpResponseBase): Observable<GetOwnerGroupForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetOwnerGroupForEditOutput.fromJS(resultData200) : new GetOwnerGroupForEditOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetOwnerGroupForEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditOwnerGroupDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OwnerGroups/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OwnerGroups/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDelete(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>Observable.throw(response_);
        });
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PaymentInfoDto.fromJS(resultData200) : new PaymentInfoDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PaymentInfoDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createPayment(input: CreatePaymentDto | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreatePayment(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    executePayment(input: ExecutePaymentDto | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExecutePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processExecutePayment(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecutePayment(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processExecutePayment(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200) : new PagedResultDtoOfSubscriptionPaymentListDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200) : new ListResultDtoOfFlatPermissionWithLevelDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>Observable.throw(response_);
        });
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CurrentUserProfileEditDto.fromJS(resultData200) : new CurrentUserProfileEditDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>Observable.throw(response_);
        });
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200) : new UpdateGoogleAuthenticatorKeyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @return Success
     */
    sendVerificationSms(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    verifySmsCode(input: VerifySmsCodeInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateCurrentUserProfile(input: CurrentUserProfileEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processChangePassword(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateProfilePicture(input: UpdateProfilePictureInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetPasswordComplexitySettingOutput.fromJS(resultData200) : new GetPasswordComplexitySettingOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @profilePictureId (optional) 
     * @userId (optional) 
     * @tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | null | undefined, userId: number | null | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetProfilePictureOutput.fromJS(resultData200) : new GetProfilePictureOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @permission (optional) 
     * @return Success
     */
    getRoles(permission: string | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetRoles(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfRoleListDto.fromJS(resultData200) : new ListResultDtoOfRoleListDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRoleForEditOutput.fromJS(resultData200) : new GetRoleForEditOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateRole(input: CreateOrUpdateRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteRole(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteRole(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetCurrentLoginInformationsOutput.fromJS(resultData200) : new GetCurrentLoginInformationsOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>Observable.throw(response_);
        });
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UpdateUserSignInTokenOutput.fromJS(resultData200) : new UpdateUserSignInTokenOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @upgradeEditionId (optional) 
     * @return Success
     */
    upgradeTenantToEquivalentEdition(upgradeEditionId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/UpgradeTenantToEquivalentEdition?";
        if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUpgradeTenantToEquivalentEdition(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeTenantToEquivalentEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpgradeTenantToEquivalentEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @subscriptionEndDateStart (optional) 
     * @subscriptionEndDateEnd (optional) 
     * @creationDateStart (optional) 
     * @creationDateEnd (optional) 
     * @editionId (optional) 
     * @editionIdSpecified (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: moment.Moment | null | undefined, subscriptionEndDateEnd: moment.Moment | null | undefined, creationDateStart: moment.Moment | null | undefined, creationDateEnd: moment.Moment | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&"; 
        if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&"; 
        if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetTenants(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfTenantListDto.fromJS(resultData200) : new PagedResultDtoOfTenantListDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createTenant(input: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateTenant(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | null | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantEditDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantEditDto.fromJS(resultData200) : new TenantEditDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TenantEditDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateTenant(input: TenantEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteTenant(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | null | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetTenantFeaturesEditOutput.fromJS(resultData200) : new GetTenantFeaturesEditOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateTenantFeatures(input: UpdateTenantFeaturesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unlockTenantAdmin(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetMemberActivityOutput.fromJS(resultData200) : new GetMemberActivityOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @salesSummaryDatePeriod (optional) 
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod | null | undefined): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod !== undefined)
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetDashboardDataOutput.fromJS(resultData200) : new GetDashboardDataOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @salesSummaryDatePeriod (optional) 
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod2 | null | undefined): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod !== undefined)
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetSalesSummaryOutput.fromJS(resultData200) : new GetSalesSummaryOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    getRegionalStats(input: any | null | undefined): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetRegionalStatsOutput.fromJS(resultData200) : new GetRegionalStatsOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    getGeneralStats(input: any | null | undefined): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetGeneralStatsOutput.fromJS(resultData200) : new GetGeneralStatsOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetGeneralStatsOutput>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    registerTenant(input: RegisterTenantInput | null | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>Observable.throw(response_);
        });
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? RegisterTenantOutput.fromJS(resultData200) : new RegisterTenantOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionsSelectOutput.fromJS(resultData200) : new EditionsSelectOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EditionsSelectOutput>(<any>null);
    }

    /**
     * @editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | null | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetEdition(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>Observable.throw(response_);
        });
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EditionSelectDto.fromJS(resultData200) : new EditionSelectDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>Observable.throw(response_);
        });
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TenantSettingsEditDto.fromJS(resultData200) : new TenantSettingsEditDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateAllSettings(input: TenantSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processClearLogo(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @defaultTimezoneScope (optional) 
     * @return Success
     */
    getTimezones(defaultTimezoneScope: DefaultTimezoneScope | null | undefined): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope !== undefined)
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetTimezones(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>Observable.throw(response_);
        });
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfNameValueDto.fromJS(resultData200) : new ListResultDtoOfNameValueDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>Observable.throw(response_);
        });
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ComboboxItemDto.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>Observable.throw(response_);
        });
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? AuthenticateResultModel.fromJS(resultData200) : new AuthenticateResultModel();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<AuthenticateResultModel>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(model: SendTwoFactorAuthCodeModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>Observable.throw(response_);
        });
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ImpersonatedAuthenticateResultModel.fromJS(resultData200) : new ImpersonatedAuthenticateResultModel();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>Observable.throw(response_);
        });
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SwitchedAccountAuthenticateResultModel.fromJS(resultData200) : new SwitchedAccountAuthenticateResultModel();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>Observable.throw(response_);
        });
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>Observable.throw(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>Observable.throw(response_);
        });
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ExternalAuthenticateResultModel.fromJS(resultData200) : new ExternalAuthenticateResultModel();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @message (optional) 
     * @severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processTestNotification(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<UiCustomizationSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<UiCustomizationSettingsEditDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<UiCustomizationSettingsEditDto>><any>Observable.throw(response_);
        });
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<UiCustomizationSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UiCustomizationSettingsEditDto.fromJS(resultData200) : new UiCustomizationSettingsEditDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UiCustomizationSettingsEditDto>(<any>null);
    }

    /**
     * @settings (optional) 
     * @return Success
     */
    updateUiManagementSettings(settings: UiCustomizationSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @settings (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(settings: UiCustomizationSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @filter (optional) 
     * @permission (optional) 
     * @role (optional) 
     * @sorting (optional) 
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | null | undefined, permission: string | null | undefined, role: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permission !== undefined)
            url_ += "Permission=" + encodeURIComponent("" + permission) + "&"; 
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>Observable.throw(response_);
        });
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfUserListDto.fromJS(resultData200) : new PagedResultDtoOfUserListDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @return Success
     */
    getUsersToExcel(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileDto>><any>Observable.throw(response_);
        });
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileDto>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserForEditOutput.fromJS(resultData200) : new GetUserForEditOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetUserForEditOutput>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | null | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetUserPermissionsForEditOutput.fromJS(resultData200) : new GetUserPermissionsForEditOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    updateUserPermissions(input: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).flatMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    createOrUpdateUser(input: CreateOrUpdateUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @id (optional) 
     * @return Success
     */
    deleteUser(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("delete", url_, options_).flatMap((response_ : any) => {
            return this.processDeleteUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unlockUser(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUnlockUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    linkToUser(input: LinkToUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processLinkToUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }

    /**
     * @maxResultCount (optional) 
     * @skipCount (optional) 
     * @sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>Observable.throw(response_);
        });
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResultDtoOfLinkedUserDto.fromJS(resultData200) : new PagedResultDtoOfLinkedUserDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>Observable.throw(response_);
        });
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfLinkedUserDto.fromJS(resultData200) : new ListResultDtoOfLinkedUserDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @input (optional) 
     * @return Success
     */
    unlinkUser(input: UnlinkUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>Observable.throw(e);
                }
            } else
                return <Observable<void>><any>Observable.throw(response_);
        });
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return Observable.of<void>(<any>null);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>Observable.throw(response_);
        });
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200) : new ListResultDtoOfUserLoginAttemptDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>Observable.throw(response_);
        });
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? GetLatestWebLogsOutput.fromJS(resultData200) : new GetLatestWebLogsOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>Observable.throw(e);
                }
            } else
                return <Observable<FileDto>><any>Observable.throw(response_);
        });
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FileDto.fromJS(resultData200) : new FileDto();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FileDto>(<any>null);
    }
}

@Injectable()
export class WmsConsignOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: ConsignOrderNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<ConsignOrderNotifyOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsConsignOrder/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<ConsignOrderNotifyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ConsignOrderNotifyOutput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<ConsignOrderNotifyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ConsignOrderNotifyOutput.fromJS(resultData200) : new ConsignOrderNotifyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ConsignOrderNotifyOutput>(<any>null);
    }
}

@Injectable()
export class WmsCs01CnDeliveryorderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    create(input: CnWmsDeliveryorderCreateInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsDeliveryorderCreateOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsCs01CnDeliveryorder/Create?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsDeliveryorderCreateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsDeliveryorderCreateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CnWmsDeliveryorderCreateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsDeliveryorderCreateOutput.fromJS(resultData200) : new CnWmsDeliveryorderCreateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsDeliveryorderCreateOutput>(<any>null);
    }
}

@Injectable()
export class WmsCs01CnEntryorderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    create(input: CnWmsEntryorderCreateInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsEntryorderCreateOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsCs01CnEntryorder/Create?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsEntryorderCreateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsEntryorderCreateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CnWmsEntryorderCreateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsEntryorderCreateOutput.fromJS(resultData200) : new CnWmsEntryorderCreateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsEntryorderCreateOutput>(<any>null);
    }
}

@Injectable()
export class WmsCs01CnInventoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    query(input: CnWmsInventoryQueryInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsInventoryQueryOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsCs01CnInventory/Query?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processQuery(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuery(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsInventoryQueryOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsInventoryQueryOutput>><any>Observable.throw(response_);
        });
    }

    protected processQuery(response: HttpResponseBase): Observable<CnWmsInventoryQueryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsInventoryQueryOutput.fromJS(resultData200) : new CnWmsInventoryQueryOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsInventoryQueryOutput>(<any>null);
    }
}

@Injectable()
export class WmsCs01CnOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    cancel(input: CnWmsOrderCancelInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsOrderCancelOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsCs01CnOrder/Cancel?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCancel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsOrderCancelOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsOrderCancelOutput>><any>Observable.throw(response_);
        });
    }

    protected processCancel(response: HttpResponseBase): Observable<CnWmsOrderCancelOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsOrderCancelOutput.fromJS(resultData200) : new CnWmsOrderCancelOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsOrderCancelOutput>(<any>null);
    }
}

@Injectable()
export class WmsCs01CnReturnorderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    create(input: CnWmsReturnorderCreateInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsReturnorderCreateOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsCs01CnReturnorder/Create?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsReturnorderCreateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsReturnorderCreateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CnWmsReturnorderCreateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsReturnorderCreateOutput.fromJS(resultData200) : new CnWmsReturnorderCreateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsReturnorderCreateOutput>(<any>null);
    }
}

@Injectable()
export class WmsCs01CnSingleitemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    synchronize(input: CnWmsSingleitemSynchronizeInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsSingleitemSynchronizeOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsCs01CnSingleitem/Synchronize?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSynchronize(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSynchronize(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsSingleitemSynchronizeOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsSingleitemSynchronizeOutput>><any>Observable.throw(response_);
        });
    }

    protected processSynchronize(response: HttpResponseBase): Observable<CnWmsSingleitemSynchronizeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsSingleitemSynchronizeOutput.fromJS(resultData200) : new CnWmsSingleitemSynchronizeOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsSingleitemSynchronizeOutput>(<any>null);
    }
}

@Injectable()
export class WmsCs01CnStockoutServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    create(input: CnWmsStockoutCreateInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsStockoutCreateOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsCs01CnStockout/Create?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsStockoutCreateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsStockoutCreateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CnWmsStockoutCreateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsStockoutCreateOutput.fromJS(resultData200) : new CnWmsStockoutCreateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsStockoutCreateOutput>(<any>null);
    }
}

@Injectable()
export class WmsInventoryQuantityServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    query(input: InventoryQuantityQueryInput | null | undefined): Observable<InventoryQuantityQueryOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsInventoryQuantity/Query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processQuery(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuery(<any>response_);
                } catch (e) {
                    return <Observable<InventoryQuantityQueryOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<InventoryQuantityQueryOutput>><any>Observable.throw(response_);
        });
    }

    protected processQuery(response: HttpResponseBase): Observable<InventoryQuantityQueryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? InventoryQuantityQueryOutput.fromJS(resultData200) : new InventoryQuantityQueryOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<InventoryQuantityQueryOutput>(<any>null);
    }
}

@Injectable()
export class WmsItemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @return Success
     */
    query(input: GetItemsInput | null | undefined): Observable<ItemQueryOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsItem/Query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processQuery(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuery(<any>response_);
                } catch (e) {
                    return <Observable<ItemQueryOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ItemQueryOutput>><any>Observable.throw(response_);
        });
    }

    protected processQuery(response: HttpResponseBase): Observable<ItemQueryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ItemQueryOutput.fromJS(resultData200) : new ItemQueryOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ItemQueryOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk01CnDeliveryorderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    create(input: CnWmsDeliveryorderCreateInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsDeliveryorderCreateOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk01CnDeliveryorder/Create?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsDeliveryorderCreateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsDeliveryorderCreateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CnWmsDeliveryorderCreateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsDeliveryorderCreateOutput.fromJS(resultData200) : new CnWmsDeliveryorderCreateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsDeliveryorderCreateOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk01CnEntryorderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    create(input: CnWmsEntryorderCreateInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsEntryorderCreateOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk01CnEntryorder/Create?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsEntryorderCreateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsEntryorderCreateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CnWmsEntryorderCreateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsEntryorderCreateOutput.fromJS(resultData200) : new CnWmsEntryorderCreateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsEntryorderCreateOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk01CnInventoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    query(input: CnWmsInventoryQueryInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsInventoryQueryOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk01CnInventory/Query?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processQuery(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuery(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsInventoryQueryOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsInventoryQueryOutput>><any>Observable.throw(response_);
        });
    }

    protected processQuery(response: HttpResponseBase): Observable<CnWmsInventoryQueryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsInventoryQueryOutput.fromJS(resultData200) : new CnWmsInventoryQueryOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsInventoryQueryOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk01CnOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    cancel(input: CnWmsOrderCancelInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsOrderCancelOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk01CnOrder/Cancel?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCancel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsOrderCancelOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsOrderCancelOutput>><any>Observable.throw(response_);
        });
    }

    protected processCancel(response: HttpResponseBase): Observable<CnWmsOrderCancelOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsOrderCancelOutput.fromJS(resultData200) : new CnWmsOrderCancelOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsOrderCancelOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk01CnReturnorderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    create(input: CnWmsReturnorderCreateInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsReturnorderCreateOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk01CnReturnorder/Create?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsReturnorderCreateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsReturnorderCreateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CnWmsReturnorderCreateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsReturnorderCreateOutput.fromJS(resultData200) : new CnWmsReturnorderCreateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsReturnorderCreateOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk01CnSingleitemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    synchronize(input: CnWmsSingleitemSynchronizeInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsSingleitemSynchronizeOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk01CnSingleitem/Synchronize?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSynchronize(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSynchronize(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsSingleitemSynchronizeOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsSingleitemSynchronizeOutput>><any>Observable.throw(response_);
        });
    }

    protected processSynchronize(response: HttpResponseBase): Observable<CnWmsSingleitemSynchronizeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsSingleitemSynchronizeOutput.fromJS(resultData200) : new CnWmsSingleitemSynchronizeOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsSingleitemSynchronizeOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk01CnStockoutServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    create(input: CnWmsStockoutCreateInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsStockoutCreateOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk01CnStockout/Create?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsStockoutCreateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsStockoutCreateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CnWmsStockoutCreateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsStockoutCreateOutput.fromJS(resultData200) : new CnWmsStockoutCreateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsStockoutCreateOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk01ConsignOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: ConsignOrderNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<ConsignOrderNotifyOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk01ConsignOrder/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<ConsignOrderNotifyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ConsignOrderNotifyOutput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<ConsignOrderNotifyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ConsignOrderNotifyOutput.fromJS(resultData200) : new ConsignOrderNotifyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ConsignOrderNotifyOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk01OrderCancelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: OrderCancelNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<OrderCancelNotifyOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk01OrderCancel/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<OrderCancelNotifyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrderCancelNotifyOutput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<OrderCancelNotifyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrderCancelNotifyOutput.fromJS(resultData200) : new OrderCancelNotifyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrderCancelNotifyOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk01SkuInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: SkuInfoNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<SkuInfoNotifyOuput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk01SkuInfo/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<SkuInfoNotifyOuput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SkuInfoNotifyOuput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<SkuInfoNotifyOuput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkuInfoNotifyOuput.fromJS(resultData200) : new SkuInfoNotifyOuput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SkuInfoNotifyOuput>(<any>null);
    }
}

@Injectable()
export class WmsLk01StockInOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: StockInOrderNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<StockInOrderNotifyOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk01StockInOrder/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<StockInOrderNotifyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<StockInOrderNotifyOutput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<StockInOrderNotifyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StockInOrderNotifyOutput.fromJS(resultData200) : new StockInOrderNotifyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<StockInOrderNotifyOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk01StockOutOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: StockOutOrderNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<StockOutOrderNotifyOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk01StockOutOrder/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<StockOutOrderNotifyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<StockOutOrderNotifyOutput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<StockOutOrderNotifyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StockOutOrderNotifyOutput.fromJS(resultData200) : new StockOutOrderNotifyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<StockOutOrderNotifyOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk02CnDeliveryorderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    create(input: CnWmsDeliveryorderCreateInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsDeliveryorderCreateOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk02CnDeliveryorder/Create?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsDeliveryorderCreateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsDeliveryorderCreateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CnWmsDeliveryorderCreateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsDeliveryorderCreateOutput.fromJS(resultData200) : new CnWmsDeliveryorderCreateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsDeliveryorderCreateOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk02CnEntryorderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    create(input: CnWmsEntryorderCreateInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsEntryorderCreateOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk02CnEntryorder/Create?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsEntryorderCreateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsEntryorderCreateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CnWmsEntryorderCreateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsEntryorderCreateOutput.fromJS(resultData200) : new CnWmsEntryorderCreateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsEntryorderCreateOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk02CnInventoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    query(input: CnWmsInventoryQueryInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsInventoryQueryOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk02CnInventory/Query?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processQuery(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuery(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsInventoryQueryOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsInventoryQueryOutput>><any>Observable.throw(response_);
        });
    }

    protected processQuery(response: HttpResponseBase): Observable<CnWmsInventoryQueryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsInventoryQueryOutput.fromJS(resultData200) : new CnWmsInventoryQueryOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsInventoryQueryOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk02CnOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    cancel(input: CnWmsOrderCancelInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsOrderCancelOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk02CnOrder/Cancel?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCancel(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancel(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsOrderCancelOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsOrderCancelOutput>><any>Observable.throw(response_);
        });
    }

    protected processCancel(response: HttpResponseBase): Observable<CnWmsOrderCancelOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsOrderCancelOutput.fromJS(resultData200) : new CnWmsOrderCancelOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsOrderCancelOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk02CnReturnorderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    create(input: CnWmsReturnorderCreateInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsReturnorderCreateOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk02CnReturnorder/Create?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsReturnorderCreateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsReturnorderCreateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CnWmsReturnorderCreateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsReturnorderCreateOutput.fromJS(resultData200) : new CnWmsReturnorderCreateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsReturnorderCreateOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk02CnSingleitemServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    synchronize(input: CnWmsSingleitemSynchronizeInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsSingleitemSynchronizeOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk02CnSingleitem/Synchronize?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processSynchronize(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSynchronize(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsSingleitemSynchronizeOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsSingleitemSynchronizeOutput>><any>Observable.throw(response_);
        });
    }

    protected processSynchronize(response: HttpResponseBase): Observable<CnWmsSingleitemSynchronizeOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsSingleitemSynchronizeOutput.fromJS(resultData200) : new CnWmsSingleitemSynchronizeOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsSingleitemSynchronizeOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk02CnStockoutServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    create(input: CnWmsStockoutCreateInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<CnWmsStockoutCreateOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk02CnStockout/Create?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processCreate(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<CnWmsStockoutCreateOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<CnWmsStockoutCreateOutput>><any>Observable.throw(response_);
        });
    }

    protected processCreate(response: HttpResponseBase): Observable<CnWmsStockoutCreateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CnWmsStockoutCreateOutput.fromJS(resultData200) : new CnWmsStockoutCreateOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CnWmsStockoutCreateOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk02ConsignOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: ConsignOrderNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<ConsignOrderNotifyOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk02ConsignOrder/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<ConsignOrderNotifyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<ConsignOrderNotifyOutput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<ConsignOrderNotifyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ConsignOrderNotifyOutput.fromJS(resultData200) : new ConsignOrderNotifyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ConsignOrderNotifyOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk02OrderCancelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: OrderCancelNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<OrderCancelNotifyOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk02OrderCancel/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<OrderCancelNotifyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrderCancelNotifyOutput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<OrderCancelNotifyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrderCancelNotifyOutput.fromJS(resultData200) : new OrderCancelNotifyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrderCancelNotifyOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk02SkuInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: SkuInfoNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<SkuInfoNotifyOuput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk02SkuInfo/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<SkuInfoNotifyOuput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SkuInfoNotifyOuput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<SkuInfoNotifyOuput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkuInfoNotifyOuput.fromJS(resultData200) : new SkuInfoNotifyOuput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SkuInfoNotifyOuput>(<any>null);
    }
}

@Injectable()
export class WmsLk02StockInOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: StockInOrderNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<StockInOrderNotifyOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk02StockInOrder/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<StockInOrderNotifyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<StockInOrderNotifyOutput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<StockInOrderNotifyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StockInOrderNotifyOutput.fromJS(resultData200) : new StockInOrderNotifyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<StockInOrderNotifyOutput>(<any>null);
    }
}

@Injectable()
export class WmsLk02StockOutOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: StockOutOrderNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<StockOutOrderNotifyOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsLk02StockOutOrder/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<StockOutOrderNotifyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<StockOutOrderNotifyOutput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<StockOutOrderNotifyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StockOutOrderNotifyOutput.fromJS(resultData200) : new StockOutOrderNotifyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<StockOutOrderNotifyOutput>(<any>null);
    }
}

@Injectable()
export class WmsOrderCancelServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: OrderCancelNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<OrderCancelNotifyOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsOrderCancel/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<OrderCancelNotifyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrderCancelNotifyOutput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<OrderCancelNotifyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrderCancelNotifyOutput.fromJS(resultData200) : new OrderCancelNotifyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrderCancelNotifyOutput>(<any>null);
    }
}

@Injectable()
export class WmsSkuInfoServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: SkuInfoNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<SkuInfoNotifyOuput> {
        let url_ = this.baseUrl + "/api/services/app/WmsSkuInfo/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<SkuInfoNotifyOuput>><any>Observable.throw(e);
                }
            } else
                return <Observable<SkuInfoNotifyOuput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<SkuInfoNotifyOuput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? SkuInfoNotifyOuput.fromJS(resultData200) : new SkuInfoNotifyOuput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<SkuInfoNotifyOuput>(<any>null);
    }
}

@Injectable()
export class WmsStockInOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: StockInOrderNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<StockInOrderNotifyOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsStockInOrder/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<StockInOrderNotifyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<StockInOrderNotifyOutput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<StockInOrderNotifyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StockInOrderNotifyOutput.fromJS(resultData200) : new StockInOrderNotifyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<StockInOrderNotifyOutput>(<any>null);
    }
}

@Injectable()
export class WmsStockOutOrderServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @input (optional) 
     * @data_digest (optional) 
     * @msg_type (optional) 
     * @partner_code (optional) 
     * @from_code (optional) 
     * @verify_sign (optional) 
     * @return Success
     */
    notify(input: StockOutOrderNotifyInput | null | undefined, data_digest: string | null | undefined, msg_type: string | null | undefined, partner_code: string | null | undefined, from_code: string | null | undefined, verify_sign: string | null | undefined): Observable<StockOutOrderNotifyOutput> {
        let url_ = this.baseUrl + "/api/services/app/WmsStockOutOrder/Notify?";
        if (data_digest !== undefined)
            url_ += "data_digest=" + encodeURIComponent("" + data_digest) + "&"; 
        if (msg_type !== undefined)
            url_ += "msg_type=" + encodeURIComponent("" + msg_type) + "&"; 
        if (partner_code !== undefined)
            url_ += "partner_code=" + encodeURIComponent("" + partner_code) + "&"; 
        if (from_code !== undefined)
            url_ += "from_code=" + encodeURIComponent("" + from_code) + "&"; 
        if (verify_sign !== undefined)
            url_ += "verify_sign=" + encodeURIComponent("" + verify_sign) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).flatMap((response_ : any) => {
            return this.processNotify(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNotify(<any>response_);
                } catch (e) {
                    return <Observable<StockOutOrderNotifyOutput>><any>Observable.throw(e);
                }
            } else
                return <Observable<StockOutOrderNotifyOutput>><any>Observable.throw(response_);
        });
    }

    protected processNotify(response: HttpResponseBase): Observable<StockOutOrderNotifyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? StockOutOrderNotifyOutput.fromJS(resultData200) : new StockOutOrderNotifyOutput();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<StockOutOrderNotifyOutput>(<any>null);
    }
}

@Injectable()
export class XWmsrReportServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @company (optional) 
     * @leadingSts (optional) 
     * @trailingSts (optional) 
     * @shipmentType (optional) 
     * @shipToState (optional) 
     * @actualShipDateTime (optional) 
     * @carrier (optional) 
     * @userDef8 (optional) 
     * @processType (optional) 
     * @shipmentCategory6 (optional) 
     * @createDateTime (optional) 
     * @endDateTime (optional) 
     * @createUser (optional) 
     * @startWithinLimitedHoursIsNotProduced (optional) 
     * @endWithinLimitedHoursIsNotProduced (optional) 
     * @return Success
     */
    getDeliveryOrders(company: string | null | undefined, leadingSts: number | null | undefined, trailingSts: number | null | undefined, shipmentType: string | null | undefined, shipToState: string | null | undefined, actualShipDateTime: moment.Moment | null | undefined, carrier: string | null | undefined, userDef8: string | null | undefined, processType: string | null | undefined, shipmentCategory6: string | null | undefined, createDateTime: moment.Moment | null | undefined, endDateTime: moment.Moment | null | undefined, createUser: string | null | undefined, startWithinLimitedHoursIsNotProduced: number | null | undefined, endWithinLimitedHoursIsNotProduced: number | null | undefined): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/XWmsrReport/GetDeliveryOrders?";
        if (company !== undefined)
            url_ += "Company=" + encodeURIComponent("" + company) + "&"; 
        if (leadingSts !== undefined)
            url_ += "LeadingSts=" + encodeURIComponent("" + leadingSts) + "&"; 
        if (trailingSts !== undefined)
            url_ += "TrailingSts=" + encodeURIComponent("" + trailingSts) + "&"; 
        if (shipmentType !== undefined)
            url_ += "ShipmentType=" + encodeURIComponent("" + shipmentType) + "&"; 
        if (shipToState !== undefined)
            url_ += "ShipToState=" + encodeURIComponent("" + shipToState) + "&"; 
        if (actualShipDateTime !== undefined)
            url_ += "ActualShipDateTime=" + encodeURIComponent(actualShipDateTime ? "" + actualShipDateTime.toJSON() : "") + "&"; 
        if (carrier !== undefined)
            url_ += "Carrier=" + encodeURIComponent("" + carrier) + "&"; 
        if (userDef8 !== undefined)
            url_ += "UserDef8=" + encodeURIComponent("" + userDef8) + "&"; 
        if (processType !== undefined)
            url_ += "ProcessType=" + encodeURIComponent("" + processType) + "&"; 
        if (shipmentCategory6 !== undefined)
            url_ += "ShipmentCategory6=" + encodeURIComponent("" + shipmentCategory6) + "&"; 
        if (createDateTime !== undefined)
            url_ += "CreateDateTime=" + encodeURIComponent(createDateTime ? "" + createDateTime.toJSON() : "") + "&"; 
        if (endDateTime !== undefined)
            url_ += "EndDateTime=" + encodeURIComponent(endDateTime ? "" + endDateTime.toJSON() : "") + "&"; 
        if (createUser !== undefined)
            url_ += "CreateUser=" + encodeURIComponent("" + createUser) + "&"; 
        if (startWithinLimitedHoursIsNotProduced !== undefined)
            url_ += "StartWithinLimitedHoursIsNotProduced=" + encodeURIComponent("" + startWithinLimitedHoursIsNotProduced) + "&"; 
        if (endWithinLimitedHoursIsNotProduced !== undefined)
            url_ += "EndWithinLimitedHoursIsNotProduced=" + encodeURIComponent("" + endWithinLimitedHoursIsNotProduced) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).flatMap((response_ : any) => {
            return this.processGetDeliveryOrders(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDeliveryOrders(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<string[]>><any>Observable.throw(response_);
        });
    }

    protected processGetDeliveryOrders(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(item);
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<string[]>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: IsTenantAvailableOutputState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId: number | undefined;
    resetCode: string;
    password: string;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }
}

export interface IResetPasswordInput {
    userId: number | undefined;
    resetCode: string;
    password: string;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        return data; 
    }
}

export interface IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;
}

export class FileDto implements IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string;
    fileToken: string;
}

export class NameValueDto implements INameValueDto {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeListDtoChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            this.changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeListDtoChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class ListResultDtoOfCompanyCodeListDto implements IListResultDtoOfCompanyCodeListDto {
    items: CompanyCodeListDto[] | undefined;

    constructor(data?: IListResultDtoOfCompanyCodeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CompanyCodeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCompanyCodeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCompanyCodeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCompanyCodeListDto {
    items: CompanyCodeListDto[] | undefined;
}

export class CompanyCodeListDto implements ICompanyCodeListDto {
    code: string;
    warehouseCode: string;
    name: string | undefined;

    constructor(data?: ICompanyCodeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.warehouseCode = data["warehouseCode"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CompanyCodeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyCodeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["warehouseCode"] = this.warehouseCode;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICompanyCodeListDto {
    code: string;
    warehouseCode: string;
    name: string | undefined;
}

export class ListResultDtoOfCarrierRuleDto implements IListResultDtoOfCarrierRuleDto {
    items: CarrierRuleDto[] | undefined;

    constructor(data?: IListResultDtoOfCarrierRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CarrierRuleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCarrierRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCarrierRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCarrierRuleDto {
    items: CarrierRuleDto[] | undefined;
}

export class CarrierRuleDto implements ICarrierRuleDto {
    companyCode: string | undefined;
    province: string | undefined;
    carrierCode: string | undefined;
    isPriority: boolean | undefined;
    weightRules: CarrierWeightRuleDto[] | undefined;
    id: number | undefined;

    constructor(data?: ICarrierRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.companyCode = data["companyCode"];
            this.province = data["province"];
            this.carrierCode = data["carrierCode"];
            this.isPriority = data["isPriority"];
            if (data["weightRules"] && data["weightRules"].constructor === Array) {
                this.weightRules = [];
                for (let item of data["weightRules"])
                    this.weightRules.push(CarrierWeightRuleDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CarrierRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarrierRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyCode"] = this.companyCode;
        data["province"] = this.province;
        data["carrierCode"] = this.carrierCode;
        data["isPriority"] = this.isPriority;
        if (this.weightRules && this.weightRules.constructor === Array) {
            data["weightRules"] = [];
            for (let item of this.weightRules)
                data["weightRules"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface ICarrierRuleDto {
    companyCode: string | undefined;
    province: string | undefined;
    carrierCode: string | undefined;
    isPriority: boolean | undefined;
    weightRules: CarrierWeightRuleDto[] | undefined;
    id: number | undefined;
}

export class CarrierWeightRuleDto implements ICarrierWeightRuleDto {
    autoCarrierRuleId: number | undefined;
    minWeight: number | undefined;
    maxWeight: number | undefined;
    carrierCode: string | undefined;
    id: number | undefined;

    constructor(data?: ICarrierWeightRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.autoCarrierRuleId = data["autoCarrierRuleId"];
            this.minWeight = data["minWeight"];
            this.maxWeight = data["maxWeight"];
            this.carrierCode = data["carrierCode"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CarrierWeightRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CarrierWeightRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoCarrierRuleId"] = this.autoCarrierRuleId;
        data["minWeight"] = this.minWeight;
        data["maxWeight"] = this.maxWeight;
        data["carrierCode"] = this.carrierCode;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICarrierWeightRuleDto {
    autoCarrierRuleId: number | undefined;
    minWeight: number | undefined;
    maxWeight: number | undefined;
    carrierCode: string | undefined;
    id: number | undefined;
}

export class UpdateAutoCarrierRuleInput implements IUpdateAutoCarrierRuleInput {
    id: number | undefined;
    companyCode: string;
    province: string;
    carrierCode: string | undefined;
    isPriority: boolean | undefined;
    weightRules: UpdateAutoCarrierWeightRuleInput[] | undefined;

    constructor(data?: IUpdateAutoCarrierRuleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.companyCode = data["companyCode"];
            this.province = data["province"];
            this.carrierCode = data["carrierCode"];
            this.isPriority = data["isPriority"];
            if (data["weightRules"] && data["weightRules"].constructor === Array) {
                this.weightRules = [];
                for (let item of data["weightRules"])
                    this.weightRules.push(UpdateAutoCarrierWeightRuleInput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateAutoCarrierRuleInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAutoCarrierRuleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["companyCode"] = this.companyCode;
        data["province"] = this.province;
        data["carrierCode"] = this.carrierCode;
        data["isPriority"] = this.isPriority;
        if (this.weightRules && this.weightRules.constructor === Array) {
            data["weightRules"] = [];
            for (let item of this.weightRules)
                data["weightRules"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateAutoCarrierRuleInput {
    id: number | undefined;
    companyCode: string;
    province: string;
    carrierCode: string | undefined;
    isPriority: boolean | undefined;
    weightRules: UpdateAutoCarrierWeightRuleInput[] | undefined;
}

export class UpdateAutoCarrierWeightRuleInput implements IUpdateAutoCarrierWeightRuleInput {
    autoCarrierRuleId: number | undefined;
    minWeight: number | undefined;
    maxWeight: number | undefined;
    carrierCode: string;

    constructor(data?: IUpdateAutoCarrierWeightRuleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.autoCarrierRuleId = data["autoCarrierRuleId"];
            this.minWeight = data["minWeight"];
            this.maxWeight = data["maxWeight"];
            this.carrierCode = data["carrierCode"];
        }
    }

    static fromJS(data: any): UpdateAutoCarrierWeightRuleInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateAutoCarrierWeightRuleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["autoCarrierRuleId"] = this.autoCarrierRuleId;
        data["minWeight"] = this.minWeight;
        data["maxWeight"] = this.maxWeight;
        data["carrierCode"] = this.carrierCode;
        return data; 
    }
}

export interface IUpdateAutoCarrierWeightRuleInput {
    autoCarrierRuleId: number | undefined;
    minWeight: number | undefined;
    maxWeight: number | undefined;
    carrierCode: string;
}

export class PutRuleCloneInput implements IPutRuleCloneInput {
    sourceCode: string;
    destinationCode: string;

    constructor(data?: IPutRuleCloneInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceCode = data["sourceCode"];
            this.destinationCode = data["destinationCode"];
        }
    }

    static fromJS(data: any): PutRuleCloneInput {
        data = typeof data === 'object' ? data : {};
        let result = new PutRuleCloneInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceCode"] = this.sourceCode;
        data["destinationCode"] = this.destinationCode;
        return data; 
    }
}

export interface IPutRuleCloneInput {
    sourceCode: string;
    destinationCode: string;
}

export class AutomaticUpdateInput implements IAutomaticUpdateInput {
    waybillCode: string;
    totalWeight: number | undefined;

    constructor(data?: IAutomaticUpdateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.waybillCode = data["waybillCode"];
            this.totalWeight = data["totalWeight"];
        }
    }

    static fromJS(data: any): AutomaticUpdateInput {
        data = typeof data === 'object' ? data : {};
        let result = new AutomaticUpdateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["waybillCode"] = this.waybillCode;
        data["totalWeight"] = this.totalWeight;
        return data; 
    }
}

export interface IAutomaticUpdateInput {
    waybillCode: string;
    totalWeight: number | undefined;
}

export class AutomaticUpdateOutput implements IAutomaticUpdateOutput {
    processType: string | undefined;
    carrierCode: string | undefined;

    constructor(data?: IAutomaticUpdateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.processType = data["processType"];
            this.carrierCode = data["carrierCode"];
        }
    }

    static fromJS(data: any): AutomaticUpdateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AutomaticUpdateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["processType"] = this.processType;
        data["carrierCode"] = this.carrierCode;
        return data; 
    }
}

export interface IAutomaticUpdateOutput {
    processType: string | undefined;
    carrierCode: string | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class CacheDto implements ICacheDto {
    name: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment | undefined;
    friends: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (data["friends"] && data["friends"].constructor === Array) {
                this.friends = [];
                for (let item of data["friends"])
                    this.friends.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (this.friends && this.friends.constructor === Array) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment | undefined;
    friends: FriendDto[] | undefined;
}

export class FriendDto implements IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendDtoState | undefined;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }
}

export interface IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendDtoState | undefined;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ChatMessageDto implements IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatMessageDtoSide | undefined;
    readState: ChatMessageDtoReadState | undefined;
    receiverReadState: ChatMessageDtoReceiverReadState | undefined;
    message: string | undefined;
    creationTime: moment.Moment | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatMessageDtoSide | undefined;
    readState: ChatMessageDtoReadState | undefined;
    receiverReadState: ChatMessageDtoReceiverReadState | undefined;
    message: string | undefined;
    creationTime: moment.Moment | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class IValueValidator implements IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class CreateOrUpdateEditionDto implements ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];

    constructor(data?: ICreateOrUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateOrUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class G2CreateGoodsInput implements IG2CreateGoodsInput {
    type: number | undefined;
    items: CreateGoodsItem[] | undefined;

    constructor(data?: IG2CreateGoodsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CreateGoodsItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): G2CreateGoodsInput {
        data = typeof data === 'object' ? data : {};
        let result = new G2CreateGoodsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IG2CreateGoodsInput {
    type: number | undefined;
    items: CreateGoodsItem[] | undefined;
}

export class CreateGoodsItem implements ICreateGoodsItem {
    itemCode: string;
    itemCodeWms: string;
    itemName: string;
    ownerCode: string;
    warehouseCode: string;
    barcode: string;
    itemType: string;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    safetyStock: number | undefined;
    skuProperty: string | undefined;
    color: string | undefined;
    size: string | undefined;
    length: number | undefined;
    height: number | undefined;
    width: number | undefined;
    netWeight: number | undefined;
    grossWeight: number | undefined;
    volume: number | undefined;
    pcs: string | undefined;
    pcr: string | undefined;
    stockUnit: string | undefined;
    remark: string | undefined;
    pricingCategory: string | undefined;
    purchasePrice: number | undefined;
    costPrice: number | undefined;
    tagPrice: number | undefined;
    retailPrice: number | undefined;
    packCode: string | undefined;
    seasonCode: string | undefined;
    seasonName: string | undefined;
    approvalNumber: string | undefined;
    brandCode: string | undefined;
    brandName: string | undefined;
    title: string | undefined;
    packageMaterial: string | undefined;
    originAddress: string | undefined;
    shortName: string | undefined;
    categoryId: string | undefined;
    categoryName: string | undefined;
    isSku: string | undefined;
    isHazardous: string | undefined;
    isShelfLifeMgmt: string | undefined;
    productDate: moment.Moment | undefined;
    expireDate: moment.Moment | undefined;
    shelfLife: number | undefined;
    rejectLifecycle: number | undefined;
    lockupLifecycle: number | undefined;
    adventLifecycle: number | undefined;
    actionType: string;
    batchRemark: string | undefined;
    batchCode: string | undefined;
    isFragile: string | undefined;
    isValid: string | undefined;
    picUrl: string | undefined;
    englishName: string | undefined;
    string1: string | undefined;
    string2: string | undefined;
    string3: string | undefined;
    string4: string | undefined;
    updatetimeERP: moment.Moment | undefined;
    createTimeERP: moment.Moment | undefined;

    constructor(data?: ICreateGoodsItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemCode = data["itemCode"];
            this.itemCodeWms = data["itemCodeWms"];
            this.itemName = data["itemName"];
            this.ownerCode = data["ownerCode"];
            this.warehouseCode = data["warehouseCode"];
            this.barcode = data["barcode"];
            this.itemType = data["itemType"];
            this.supplierCode = data["supplierCode"];
            this.supplierName = data["supplierName"];
            this.safetyStock = data["safetyStock"];
            this.skuProperty = data["skuProperty"];
            this.color = data["color"];
            this.size = data["size"];
            this.length = data["length"];
            this.height = data["height"];
            this.width = data["width"];
            this.netWeight = data["netWeight"];
            this.grossWeight = data["grossWeight"];
            this.volume = data["volume"];
            this.pcs = data["pcs"];
            this.pcr = data["pcr"];
            this.stockUnit = data["stockUnit"];
            this.remark = data["remark"];
            this.pricingCategory = data["pricingCategory"];
            this.purchasePrice = data["purchasePrice"];
            this.costPrice = data["costPrice"];
            this.tagPrice = data["tagPrice"];
            this.retailPrice = data["retailPrice"];
            this.packCode = data["packCode"];
            this.seasonCode = data["seasonCode"];
            this.seasonName = data["seasonName"];
            this.approvalNumber = data["approvalNumber"];
            this.brandCode = data["brandCode"];
            this.brandName = data["brandName"];
            this.title = data["title"];
            this.packageMaterial = data["packageMaterial"];
            this.originAddress = data["originAddress"];
            this.shortName = data["shortName"];
            this.categoryId = data["categoryId"];
            this.categoryName = data["categoryName"];
            this.isSku = data["isSku"];
            this.isHazardous = data["isHazardous"];
            this.isShelfLifeMgmt = data["isShelfLifeMgmt"];
            this.productDate = data["productDate"] ? moment(data["productDate"].toString()) : <any>undefined;
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.shelfLife = data["shelfLife"];
            this.rejectLifecycle = data["rejectLifecycle"];
            this.lockupLifecycle = data["lockupLifecycle"];
            this.adventLifecycle = data["adventLifecycle"];
            this.actionType = data["actionType"];
            this.batchRemark = data["batchRemark"];
            this.batchCode = data["batchCode"];
            this.isFragile = data["isFragile"];
            this.isValid = data["isValid"];
            this.picUrl = data["picUrl"];
            this.englishName = data["englishName"];
            this.string1 = data["string1"];
            this.string2 = data["string2"];
            this.string3 = data["string3"];
            this.string4 = data["string4"];
            this.updatetimeERP = data["updatetimeERP"] ? moment(data["updatetimeERP"].toString()) : <any>undefined;
            this.createTimeERP = data["createTimeERP"] ? moment(data["createTimeERP"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateGoodsItem {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGoodsItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemCode"] = this.itemCode;
        data["itemCodeWms"] = this.itemCodeWms;
        data["itemName"] = this.itemName;
        data["ownerCode"] = this.ownerCode;
        data["warehouseCode"] = this.warehouseCode;
        data["barcode"] = this.barcode;
        data["itemType"] = this.itemType;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["safetyStock"] = this.safetyStock;
        data["skuProperty"] = this.skuProperty;
        data["color"] = this.color;
        data["size"] = this.size;
        data["length"] = this.length;
        data["height"] = this.height;
        data["width"] = this.width;
        data["netWeight"] = this.netWeight;
        data["grossWeight"] = this.grossWeight;
        data["volume"] = this.volume;
        data["pcs"] = this.pcs;
        data["pcr"] = this.pcr;
        data["stockUnit"] = this.stockUnit;
        data["remark"] = this.remark;
        data["pricingCategory"] = this.pricingCategory;
        data["purchasePrice"] = this.purchasePrice;
        data["costPrice"] = this.costPrice;
        data["tagPrice"] = this.tagPrice;
        data["retailPrice"] = this.retailPrice;
        data["packCode"] = this.packCode;
        data["seasonCode"] = this.seasonCode;
        data["seasonName"] = this.seasonName;
        data["approvalNumber"] = this.approvalNumber;
        data["brandCode"] = this.brandCode;
        data["brandName"] = this.brandName;
        data["title"] = this.title;
        data["packageMaterial"] = this.packageMaterial;
        data["originAddress"] = this.originAddress;
        data["shortName"] = this.shortName;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["isSku"] = this.isSku;
        data["isHazardous"] = this.isHazardous;
        data["isShelfLifeMgmt"] = this.isShelfLifeMgmt;
        data["productDate"] = this.productDate ? this.productDate.toISOString() : <any>undefined;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["shelfLife"] = this.shelfLife;
        data["rejectLifecycle"] = this.rejectLifecycle;
        data["lockupLifecycle"] = this.lockupLifecycle;
        data["adventLifecycle"] = this.adventLifecycle;
        data["actionType"] = this.actionType;
        data["batchRemark"] = this.batchRemark;
        data["batchCode"] = this.batchCode;
        data["isFragile"] = this.isFragile;
        data["isValid"] = this.isValid;
        data["picUrl"] = this.picUrl;
        data["englishName"] = this.englishName;
        data["string1"] = this.string1;
        data["string2"] = this.string2;
        data["string3"] = this.string3;
        data["string4"] = this.string4;
        data["updatetimeERP"] = this.updatetimeERP ? this.updatetimeERP.toISOString() : <any>undefined;
        data["createTimeERP"] = this.createTimeERP ? this.createTimeERP.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ICreateGoodsItem {
    itemCode: string;
    itemCodeWms: string;
    itemName: string;
    ownerCode: string;
    warehouseCode: string;
    barcode: string;
    itemType: string;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    safetyStock: number | undefined;
    skuProperty: string | undefined;
    color: string | undefined;
    size: string | undefined;
    length: number | undefined;
    height: number | undefined;
    width: number | undefined;
    netWeight: number | undefined;
    grossWeight: number | undefined;
    volume: number | undefined;
    pcs: string | undefined;
    pcr: string | undefined;
    stockUnit: string | undefined;
    remark: string | undefined;
    pricingCategory: string | undefined;
    purchasePrice: number | undefined;
    costPrice: number | undefined;
    tagPrice: number | undefined;
    retailPrice: number | undefined;
    packCode: string | undefined;
    seasonCode: string | undefined;
    seasonName: string | undefined;
    approvalNumber: string | undefined;
    brandCode: string | undefined;
    brandName: string | undefined;
    title: string | undefined;
    packageMaterial: string | undefined;
    originAddress: string | undefined;
    shortName: string | undefined;
    categoryId: string | undefined;
    categoryName: string | undefined;
    isSku: string | undefined;
    isHazardous: string | undefined;
    isShelfLifeMgmt: string | undefined;
    productDate: moment.Moment | undefined;
    expireDate: moment.Moment | undefined;
    shelfLife: number | undefined;
    rejectLifecycle: number | undefined;
    lockupLifecycle: number | undefined;
    adventLifecycle: number | undefined;
    actionType: string;
    batchRemark: string | undefined;
    batchCode: string | undefined;
    isFragile: string | undefined;
    isValid: string | undefined;
    picUrl: string | undefined;
    englishName: string | undefined;
    string1: string | undefined;
    string2: string | undefined;
    string3: string | undefined;
    string4: string | undefined;
    updatetimeERP: moment.Moment | undefined;
    createTimeERP: moment.Moment | undefined;
}

export class G2CreateGoodsOutput implements IG2CreateGoodsOutput {
    data: CreateGoodsData | undefined;
    code: number | undefined;
    message: string | undefined;

    constructor(data?: IG2CreateGoodsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? CreateGoodsData.fromJS(data["data"]) : <any>undefined;
            this.code = data["code"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): G2CreateGoodsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new G2CreateGoodsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }
}

export interface IG2CreateGoodsOutput {
    data: CreateGoodsData | undefined;
    code: number | undefined;
    message: string | undefined;
}

export class CreateGoodsData implements ICreateGoodsData {
    total: number | undefined;
    fail: DataFail[] | undefined;
    success: DataSuccess[] | undefined;

    constructor(data?: ICreateGoodsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"];
            if (data["fail"] && data["fail"].constructor === Array) {
                this.fail = [];
                for (let item of data["fail"])
                    this.fail.push(DataFail.fromJS(item));
            }
            if (data["success"] && data["success"].constructor === Array) {
                this.success = [];
                for (let item of data["success"])
                    this.success.push(DataSuccess.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateGoodsData {
        data = typeof data === 'object' ? data : {};
        let result = new CreateGoodsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (this.fail && this.fail.constructor === Array) {
            data["fail"] = [];
            for (let item of this.fail)
                data["fail"].push(item.toJSON());
        }
        if (this.success && this.success.constructor === Array) {
            data["success"] = [];
            for (let item of this.success)
                data["success"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateGoodsData {
    total: number | undefined;
    fail: DataFail[] | undefined;
    success: DataSuccess[] | undefined;
}

export class DataFail implements IDataFail {
    itemCode: string | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: IDataFail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemCode = data["itemCode"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): DataFail {
        data = typeof data === 'object' ? data : {};
        let result = new DataFail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemCode"] = this.itemCode;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface IDataFail {
    itemCode: string | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class DataSuccess implements IDataSuccess {
    itemCode: string | undefined;

    constructor(data?: IDataSuccess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemCode = data["itemCode"];
        }
    }

    static fromJS(data: any): DataSuccess {
        data = typeof data === 'object' ? data : {};
        let result = new DataSuccess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemCode"] = this.itemCode;
        return data; 
    }
}

export interface IDataSuccess {
    itemCode: string | undefined;
}

export class G2EntryOrderCreatReturnUnloadingInforInput implements IG2EntryOrderCreatReturnUnloadingInforInput {
    wareHouseCode: string;
    ownerCode: string;
    entryOrderCode: string;
    projectCode: string | undefined;
    orderCodeWMS: string;
    saleOrderCodeOwner: string | undefined;
    saleOrderCodeWMS: string | undefined;
    orderType: string;
    expectStartTime: moment.Moment;
    expectEndTime: moment.Moment;
    supplierName: string | undefined;
    supplierCode: string | undefined;
    arrivalMode: string | undefined;
    areaCode: string | undefined;
    logisticsName: string | undefined;
    logisticsCode: string | undefined;
    expressCode: string | undefined;
    totalOrderLines: number | undefined;
    createTimeERP: moment.Moment | undefined;
    updateTimeERP: moment.Moment | undefined;
    operatorName: string | undefined;
    operatorCode: string | undefined;
    operateTime: moment.Moment | undefined;
    returnReason: string | undefined;
    remark: string | undefined;
    senderInfos: EntryOrderCreatReturnUnloadingInforInputSenderInfo[] | undefined;
    orderLines: EntryOrderCreatReturnUnloadingInforInputOrderLine[];

    constructor(data?: IG2EntryOrderCreatReturnUnloadingInforInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.orderLines = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.wareHouseCode = data["wareHouseCode"];
            this.ownerCode = data["ownerCode"];
            this.entryOrderCode = data["entryOrderCode"];
            this.projectCode = data["projectCode"];
            this.orderCodeWMS = data["orderCodeWMS"];
            this.saleOrderCodeOwner = data["saleOrderCodeOwner"];
            this.saleOrderCodeWMS = data["saleOrderCodeWMS"];
            this.orderType = data["orderType"];
            this.expectStartTime = data["expectStartTime"] ? moment(data["expectStartTime"].toString()) : <any>undefined;
            this.expectEndTime = data["expectEndTime"] ? moment(data["expectEndTime"].toString()) : <any>undefined;
            this.supplierName = data["supplierName"];
            this.supplierCode = data["supplierCode"];
            this.arrivalMode = data["arrivalMode"];
            this.areaCode = data["areaCode"];
            this.logisticsName = data["logisticsName"];
            this.logisticsCode = data["logisticsCode"];
            this.expressCode = data["expressCode"];
            this.totalOrderLines = data["totalOrderLines"];
            this.createTimeERP = data["createTimeERP"] ? moment(data["createTimeERP"].toString()) : <any>undefined;
            this.updateTimeERP = data["updateTimeERP"] ? moment(data["updateTimeERP"].toString()) : <any>undefined;
            this.operatorName = data["operatorName"];
            this.operatorCode = data["operatorCode"];
            this.operateTime = data["operateTime"] ? moment(data["operateTime"].toString()) : <any>undefined;
            this.returnReason = data["returnReason"];
            this.remark = data["remark"];
            if (data["senderInfos"] && data["senderInfos"].constructor === Array) {
                this.senderInfos = [];
                for (let item of data["senderInfos"])
                    this.senderInfos.push(EntryOrderCreatReturnUnloadingInforInputSenderInfo.fromJS(item));
            }
            if (data["orderLines"] && data["orderLines"].constructor === Array) {
                this.orderLines = [];
                for (let item of data["orderLines"])
                    this.orderLines.push(EntryOrderCreatReturnUnloadingInforInputOrderLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): G2EntryOrderCreatReturnUnloadingInforInput {
        data = typeof data === 'object' ? data : {};
        let result = new G2EntryOrderCreatReturnUnloadingInforInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["wareHouseCode"] = this.wareHouseCode;
        data["ownerCode"] = this.ownerCode;
        data["entryOrderCode"] = this.entryOrderCode;
        data["projectCode"] = this.projectCode;
        data["orderCodeWMS"] = this.orderCodeWMS;
        data["saleOrderCodeOwner"] = this.saleOrderCodeOwner;
        data["saleOrderCodeWMS"] = this.saleOrderCodeWMS;
        data["orderType"] = this.orderType;
        data["expectStartTime"] = this.expectStartTime ? this.expectStartTime.toISOString() : <any>undefined;
        data["expectEndTime"] = this.expectEndTime ? this.expectEndTime.toISOString() : <any>undefined;
        data["supplierName"] = this.supplierName;
        data["supplierCode"] = this.supplierCode;
        data["arrivalMode"] = this.arrivalMode;
        data["areaCode"] = this.areaCode;
        data["logisticsName"] = this.logisticsName;
        data["logisticsCode"] = this.logisticsCode;
        data["expressCode"] = this.expressCode;
        data["totalOrderLines"] = this.totalOrderLines;
        data["createTimeERP"] = this.createTimeERP ? this.createTimeERP.toISOString() : <any>undefined;
        data["updateTimeERP"] = this.updateTimeERP ? this.updateTimeERP.toISOString() : <any>undefined;
        data["operatorName"] = this.operatorName;
        data["operatorCode"] = this.operatorCode;
        data["operateTime"] = this.operateTime ? this.operateTime.toISOString() : <any>undefined;
        data["returnReason"] = this.returnReason;
        data["remark"] = this.remark;
        if (this.senderInfos && this.senderInfos.constructor === Array) {
            data["senderInfos"] = [];
            for (let item of this.senderInfos)
                data["senderInfos"].push(item.toJSON());
        }
        if (this.orderLines && this.orderLines.constructor === Array) {
            data["orderLines"] = [];
            for (let item of this.orderLines)
                data["orderLines"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IG2EntryOrderCreatReturnUnloadingInforInput {
    wareHouseCode: string;
    ownerCode: string;
    entryOrderCode: string;
    projectCode: string | undefined;
    orderCodeWMS: string;
    saleOrderCodeOwner: string | undefined;
    saleOrderCodeWMS: string | undefined;
    orderType: string;
    expectStartTime: moment.Moment;
    expectEndTime: moment.Moment;
    supplierName: string | undefined;
    supplierCode: string | undefined;
    arrivalMode: string | undefined;
    areaCode: string | undefined;
    logisticsName: string | undefined;
    logisticsCode: string | undefined;
    expressCode: string | undefined;
    totalOrderLines: number | undefined;
    createTimeERP: moment.Moment | undefined;
    updateTimeERP: moment.Moment | undefined;
    operatorName: string | undefined;
    operatorCode: string | undefined;
    operateTime: moment.Moment | undefined;
    returnReason: string | undefined;
    remark: string | undefined;
    senderInfos: EntryOrderCreatReturnUnloadingInforInputSenderInfo[] | undefined;
    orderLines: EntryOrderCreatReturnUnloadingInforInputOrderLine[];
}

export class EntryOrderCreatReturnUnloadingInforInputSenderInfo implements IEntryOrderCreatReturnUnloadingInforInputSenderInfo {
    senderCompany: string | undefined;
    senderName: string | undefined;
    senderZipcode: string | undefined;
    senderTel: string | undefined;
    senderMobile: string | undefined;
    senderEmail: string | undefined;
    senderCountrycode: string | undefined;
    senderProvince: string | undefined;
    senderCity: string | undefined;
    senderArea: string | undefined;
    senderTown: string | undefined;
    senderDetailAddress: string | undefined;

    constructor(data?: IEntryOrderCreatReturnUnloadingInforInputSenderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.senderCompany = data["senderCompany"];
            this.senderName = data["senderName"];
            this.senderZipcode = data["senderZipcode"];
            this.senderTel = data["senderTel"];
            this.senderMobile = data["senderMobile"];
            this.senderEmail = data["senderEmail"];
            this.senderCountrycode = data["senderCountrycode"];
            this.senderProvince = data["senderProvince"];
            this.senderCity = data["senderCity"];
            this.senderArea = data["senderArea"];
            this.senderTown = data["senderTown"];
            this.senderDetailAddress = data["senderDetailAddress"];
        }
    }

    static fromJS(data: any): EntryOrderCreatReturnUnloadingInforInputSenderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EntryOrderCreatReturnUnloadingInforInputSenderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderCompany"] = this.senderCompany;
        data["senderName"] = this.senderName;
        data["senderZipcode"] = this.senderZipcode;
        data["senderTel"] = this.senderTel;
        data["senderMobile"] = this.senderMobile;
        data["senderEmail"] = this.senderEmail;
        data["senderCountrycode"] = this.senderCountrycode;
        data["senderProvince"] = this.senderProvince;
        data["senderCity"] = this.senderCity;
        data["senderArea"] = this.senderArea;
        data["senderTown"] = this.senderTown;
        data["senderDetailAddress"] = this.senderDetailAddress;
        return data; 
    }
}

export interface IEntryOrderCreatReturnUnloadingInforInputSenderInfo {
    senderCompany: string | undefined;
    senderName: string | undefined;
    senderZipcode: string | undefined;
    senderTel: string | undefined;
    senderMobile: string | undefined;
    senderEmail: string | undefined;
    senderCountrycode: string | undefined;
    senderProvince: string | undefined;
    senderCity: string | undefined;
    senderArea: string | undefined;
    senderTown: string | undefined;
    senderDetailAddress: string | undefined;
}

export class EntryOrderCreatReturnUnloadingInforInputOrderLine implements IEntryOrderCreatReturnUnloadingInforInputOrderLine {
    orderLineNo: string;
    returnOrderLineNo: string;
    itemCode: string;
    itemName: string;
    pcs: string | undefined;
    isGift: string | undefined;
    skuProperty: string | undefined;
    planQty: number | undefined;
    stockUnit: string | undefined;
    purchasePrice: number | undefined;
    priceCount: number | undefined;
    retailPrice: number | undefined;
    productDate: moment.Moment | undefined;
    expireDate: moment.Moment | undefined;
    produceCode: string | undefined;
    batchCode: string | undefined;
    string1: string | undefined;
    string2: string | undefined;
    string3: string | undefined;
    string4: string | undefined;
    string5: string | undefined;

    constructor(data?: IEntryOrderCreatReturnUnloadingInforInputOrderLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderLineNo = data["orderLineNo"];
            this.returnOrderLineNo = data["returnOrderLineNo"];
            this.itemCode = data["itemCode"];
            this.itemName = data["itemName"];
            this.pcs = data["pcs"];
            this.isGift = data["isGift"];
            this.skuProperty = data["skuProperty"];
            this.planQty = data["planQty"];
            this.stockUnit = data["stockUnit"];
            this.purchasePrice = data["purchasePrice"];
            this.priceCount = data["priceCount"];
            this.retailPrice = data["retailPrice"];
            this.productDate = data["productDate"] ? moment(data["productDate"].toString()) : <any>undefined;
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.produceCode = data["produceCode"];
            this.batchCode = data["batchCode"];
            this.string1 = data["string1"];
            this.string2 = data["string2"];
            this.string3 = data["string3"];
            this.string4 = data["string4"];
            this.string5 = data["string5"];
        }
    }

    static fromJS(data: any): EntryOrderCreatReturnUnloadingInforInputOrderLine {
        data = typeof data === 'object' ? data : {};
        let result = new EntryOrderCreatReturnUnloadingInforInputOrderLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderLineNo"] = this.orderLineNo;
        data["returnOrderLineNo"] = this.returnOrderLineNo;
        data["itemCode"] = this.itemCode;
        data["itemName"] = this.itemName;
        data["pcs"] = this.pcs;
        data["isGift"] = this.isGift;
        data["skuProperty"] = this.skuProperty;
        data["planQty"] = this.planQty;
        data["stockUnit"] = this.stockUnit;
        data["purchasePrice"] = this.purchasePrice;
        data["priceCount"] = this.priceCount;
        data["retailPrice"] = this.retailPrice;
        data["productDate"] = this.productDate ? this.productDate.toISOString() : <any>undefined;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["produceCode"] = this.produceCode;
        data["batchCode"] = this.batchCode;
        data["string1"] = this.string1;
        data["string2"] = this.string2;
        data["string3"] = this.string3;
        data["string4"] = this.string4;
        data["string5"] = this.string5;
        return data; 
    }
}

export interface IEntryOrderCreatReturnUnloadingInforInputOrderLine {
    orderLineNo: string;
    returnOrderLineNo: string;
    itemCode: string;
    itemName: string;
    pcs: string | undefined;
    isGift: string | undefined;
    skuProperty: string | undefined;
    planQty: number | undefined;
    stockUnit: string | undefined;
    purchasePrice: number | undefined;
    priceCount: number | undefined;
    retailPrice: number | undefined;
    productDate: moment.Moment | undefined;
    expireDate: moment.Moment | undefined;
    produceCode: string | undefined;
    batchCode: string | undefined;
    string1: string | undefined;
    string2: string | undefined;
    string3: string | undefined;
    string4: string | undefined;
    string5: string | undefined;
}

export class G2EntryOrderCreatReturnUnloadingInforOutput implements IG2EntryOrderCreatReturnUnloadingInforOutput {
    code: number | undefined;
    message: string | undefined;

    constructor(data?: IG2EntryOrderCreatReturnUnloadingInforOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): G2EntryOrderCreatReturnUnloadingInforOutput {
        data = typeof data === 'object' ? data : {};
        let result = new G2EntryOrderCreatReturnUnloadingInforOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }
}

export interface IG2EntryOrderCreatReturnUnloadingInforOutput {
    code: number | undefined;
    message: string | undefined;
}

export class G2EntryOrderCreatUnloadingInforInput implements IG2EntryOrderCreatUnloadingInforInput {
    warehouseCode: string;
    ownerCode: string;
    entryOrderCode: string;
    orderCodeWMS: string | undefined;
    projectCode: string | undefined;
    ownerOrderCode: string | undefined;
    orderType: string;
    expectStartTime: moment.Moment;
    expectEndTime: moment.Moment;
    supplierName: string | undefined;
    supplierCode: string | undefined;
    arrivalMode: string | undefined;
    areaCode: string | undefined;
    logisticsName: string | undefined;
    logisticsCode: string | undefined;
    expressCode: string | undefined;
    totalOrderLines: number | undefined;
    createTimeERP: moment.Moment | undefined;
    updateTimeERP: moment.Moment | undefined;
    operatorName: string | undefined;
    operatorCode: string | undefined;
    operateTime: moment.Moment | undefined;
    remark: string | undefined;
    senderInfos: EntryOrderCreatUnloadingInforInputSenderInfo[] | undefined;
    getInfoS: GetInfo[] | undefined;
    orderLines: OrderLine[];

    constructor(data?: IG2EntryOrderCreatUnloadingInforInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.orderLines = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.warehouseCode = data["warehouseCode"];
            this.ownerCode = data["ownerCode"];
            this.entryOrderCode = data["entryOrderCode"];
            this.orderCodeWMS = data["orderCodeWMS"];
            this.projectCode = data["projectCode"];
            this.ownerOrderCode = data["ownerOrderCode"];
            this.orderType = data["orderType"];
            this.expectStartTime = data["expectStartTime"] ? moment(data["expectStartTime"].toString()) : <any>undefined;
            this.expectEndTime = data["expectEndTime"] ? moment(data["expectEndTime"].toString()) : <any>undefined;
            this.supplierName = data["supplierName"];
            this.supplierCode = data["supplierCode"];
            this.arrivalMode = data["arrivalMode"];
            this.areaCode = data["areaCode"];
            this.logisticsName = data["logisticsName"];
            this.logisticsCode = data["logisticsCode"];
            this.expressCode = data["expressCode"];
            this.totalOrderLines = data["totalOrderLines"];
            this.createTimeERP = data["createTimeERP"] ? moment(data["createTimeERP"].toString()) : <any>undefined;
            this.updateTimeERP = data["updateTimeERP"] ? moment(data["updateTimeERP"].toString()) : <any>undefined;
            this.operatorName = data["operatorName"];
            this.operatorCode = data["operatorCode"];
            this.operateTime = data["operateTime"] ? moment(data["operateTime"].toString()) : <any>undefined;
            this.remark = data["remark"];
            if (data["senderInfos"] && data["senderInfos"].constructor === Array) {
                this.senderInfos = [];
                for (let item of data["senderInfos"])
                    this.senderInfos.push(EntryOrderCreatUnloadingInforInputSenderInfo.fromJS(item));
            }
            if (data["getInfoS"] && data["getInfoS"].constructor === Array) {
                this.getInfoS = [];
                for (let item of data["getInfoS"])
                    this.getInfoS.push(GetInfo.fromJS(item));
            }
            if (data["orderLines"] && data["orderLines"].constructor === Array) {
                this.orderLines = [];
                for (let item of data["orderLines"])
                    this.orderLines.push(OrderLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): G2EntryOrderCreatUnloadingInforInput {
        data = typeof data === 'object' ? data : {};
        let result = new G2EntryOrderCreatUnloadingInforInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warehouseCode"] = this.warehouseCode;
        data["ownerCode"] = this.ownerCode;
        data["entryOrderCode"] = this.entryOrderCode;
        data["orderCodeWMS"] = this.orderCodeWMS;
        data["projectCode"] = this.projectCode;
        data["ownerOrderCode"] = this.ownerOrderCode;
        data["orderType"] = this.orderType;
        data["expectStartTime"] = this.expectStartTime ? this.expectStartTime.toISOString() : <any>undefined;
        data["expectEndTime"] = this.expectEndTime ? this.expectEndTime.toISOString() : <any>undefined;
        data["supplierName"] = this.supplierName;
        data["supplierCode"] = this.supplierCode;
        data["arrivalMode"] = this.arrivalMode;
        data["areaCode"] = this.areaCode;
        data["logisticsName"] = this.logisticsName;
        data["logisticsCode"] = this.logisticsCode;
        data["expressCode"] = this.expressCode;
        data["totalOrderLines"] = this.totalOrderLines;
        data["createTimeERP"] = this.createTimeERP ? this.createTimeERP.toISOString() : <any>undefined;
        data["updateTimeERP"] = this.updateTimeERP ? this.updateTimeERP.toISOString() : <any>undefined;
        data["operatorName"] = this.operatorName;
        data["operatorCode"] = this.operatorCode;
        data["operateTime"] = this.operateTime ? this.operateTime.toISOString() : <any>undefined;
        data["remark"] = this.remark;
        if (this.senderInfos && this.senderInfos.constructor === Array) {
            data["senderInfos"] = [];
            for (let item of this.senderInfos)
                data["senderInfos"].push(item.toJSON());
        }
        if (this.getInfoS && this.getInfoS.constructor === Array) {
            data["getInfoS"] = [];
            for (let item of this.getInfoS)
                data["getInfoS"].push(item.toJSON());
        }
        if (this.orderLines && this.orderLines.constructor === Array) {
            data["orderLines"] = [];
            for (let item of this.orderLines)
                data["orderLines"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IG2EntryOrderCreatUnloadingInforInput {
    warehouseCode: string;
    ownerCode: string;
    entryOrderCode: string;
    orderCodeWMS: string | undefined;
    projectCode: string | undefined;
    ownerOrderCode: string | undefined;
    orderType: string;
    expectStartTime: moment.Moment;
    expectEndTime: moment.Moment;
    supplierName: string | undefined;
    supplierCode: string | undefined;
    arrivalMode: string | undefined;
    areaCode: string | undefined;
    logisticsName: string | undefined;
    logisticsCode: string | undefined;
    expressCode: string | undefined;
    totalOrderLines: number | undefined;
    createTimeERP: moment.Moment | undefined;
    updateTimeERP: moment.Moment | undefined;
    operatorName: string | undefined;
    operatorCode: string | undefined;
    operateTime: moment.Moment | undefined;
    remark: string | undefined;
    senderInfos: EntryOrderCreatUnloadingInforInputSenderInfo[] | undefined;
    getInfoS: GetInfo[] | undefined;
    orderLines: OrderLine[];
}

export class EntryOrderCreatUnloadingInforInputSenderInfo implements IEntryOrderCreatUnloadingInforInputSenderInfo {
    senderCompany: string | undefined;
    senderName: string | undefined;
    senderZipcode: string | undefined;
    senderTel: string | undefined;
    senderMobile: string | undefined;
    senderEmail: string | undefined;
    senderCountrycode: string | undefined;
    senderProvince: string | undefined;
    senderCity: string | undefined;
    senderArea: string | undefined;
    senderTown: string | undefined;
    senderDetailAddress: string | undefined;

    constructor(data?: IEntryOrderCreatUnloadingInforInputSenderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.senderCompany = data["senderCompany"];
            this.senderName = data["senderName"];
            this.senderZipcode = data["senderZipcode"];
            this.senderTel = data["senderTel"];
            this.senderMobile = data["senderMobile"];
            this.senderEmail = data["senderEmail"];
            this.senderCountrycode = data["senderCountrycode"];
            this.senderProvince = data["senderProvince"];
            this.senderCity = data["senderCity"];
            this.senderArea = data["senderArea"];
            this.senderTown = data["senderTown"];
            this.senderDetailAddress = data["senderDetailAddress"];
        }
    }

    static fromJS(data: any): EntryOrderCreatUnloadingInforInputSenderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new EntryOrderCreatUnloadingInforInputSenderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderCompany"] = this.senderCompany;
        data["senderName"] = this.senderName;
        data["senderZipcode"] = this.senderZipcode;
        data["senderTel"] = this.senderTel;
        data["senderMobile"] = this.senderMobile;
        data["senderEmail"] = this.senderEmail;
        data["senderCountrycode"] = this.senderCountrycode;
        data["senderProvince"] = this.senderProvince;
        data["senderCity"] = this.senderCity;
        data["senderArea"] = this.senderArea;
        data["senderTown"] = this.senderTown;
        data["senderDetailAddress"] = this.senderDetailAddress;
        return data; 
    }
}

export interface IEntryOrderCreatUnloadingInforInputSenderInfo {
    senderCompany: string | undefined;
    senderName: string | undefined;
    senderZipcode: string | undefined;
    senderTel: string | undefined;
    senderMobile: string | undefined;
    senderEmail: string | undefined;
    senderCountrycode: string | undefined;
    senderProvince: string | undefined;
    senderCity: string | undefined;
    senderArea: string | undefined;
    senderTown: string | undefined;
    senderDetailAddress: string | undefined;
}

export class GetInfo implements IGetInfo {
    getCompany: string | undefined;
    getName: string | undefined;
    getZipcode: string | undefined;
    getTel: string | undefined;
    getMobile: string | undefined;
    getEmail: string | undefined;
    getCountrycode: string | undefined;
    getProvince: string | undefined;
    getCity: string | undefined;
    getArea: string | undefined;
    getTown: string | undefined;
    getDetailAddress: string | undefined;

    constructor(data?: IGetInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.getCompany = data["getCompany"];
            this.getName = data["getName"];
            this.getZipcode = data["getZipcode"];
            this.getTel = data["getTel"];
            this.getMobile = data["getMobile"];
            this.getEmail = data["getEmail"];
            this.getCountrycode = data["getCountrycode"];
            this.getProvince = data["getProvince"];
            this.getCity = data["getCity"];
            this.getArea = data["getArea"];
            this.getTown = data["getTown"];
            this.getDetailAddress = data["getDetailAddress"];
        }
    }

    static fromJS(data: any): GetInfo {
        data = typeof data === 'object' ? data : {};
        let result = new GetInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["getCompany"] = this.getCompany;
        data["getName"] = this.getName;
        data["getZipcode"] = this.getZipcode;
        data["getTel"] = this.getTel;
        data["getMobile"] = this.getMobile;
        data["getEmail"] = this.getEmail;
        data["getCountrycode"] = this.getCountrycode;
        data["getProvince"] = this.getProvince;
        data["getCity"] = this.getCity;
        data["getArea"] = this.getArea;
        data["getTown"] = this.getTown;
        data["getDetailAddress"] = this.getDetailAddress;
        return data; 
    }
}

export interface IGetInfo {
    getCompany: string | undefined;
    getName: string | undefined;
    getZipcode: string | undefined;
    getTel: string | undefined;
    getMobile: string | undefined;
    getEmail: string | undefined;
    getCountrycode: string | undefined;
    getProvince: string | undefined;
    getCity: string | undefined;
    getArea: string | undefined;
    getTown: string | undefined;
    getDetailAddress: string | undefined;
}

export class OrderLine implements IOrderLine {
    orderLineNo: string;
    itemCode: string;
    itemId: string | undefined;
    inventoryType: string | undefined;
    itemName: string;
    pcs: string | undefined;
    isGift: string | undefined;
    skuProperty: string | undefined;
    planQty: number | undefined;
    stockUnit: string | undefined;
    purchasePrice: number | undefined;
    priceCount: number | undefined;
    retailPrice: number | undefined;
    productDate: moment.Moment | undefined;
    expireDate: moment.Moment | undefined;
    produceCode: string | undefined;
    batchCode: string | undefined;
    string1: string | undefined;
    string2: string | undefined;
    string3: string | undefined;
    string4: string | undefined;
    string5: string | undefined;

    constructor(data?: IOrderLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderLineNo = data["orderLineNo"];
            this.itemCode = data["itemCode"];
            this.itemId = data["itemId"];
            this.inventoryType = data["inventoryType"];
            this.itemName = data["itemName"];
            this.pcs = data["pcs"];
            this.isGift = data["isGift"];
            this.skuProperty = data["skuProperty"];
            this.planQty = data["planQty"];
            this.stockUnit = data["stockUnit"];
            this.purchasePrice = data["purchasePrice"];
            this.priceCount = data["priceCount"];
            this.retailPrice = data["retailPrice"];
            this.productDate = data["productDate"] ? moment(data["productDate"].toString()) : <any>undefined;
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.produceCode = data["produceCode"];
            this.batchCode = data["batchCode"];
            this.string1 = data["string1"];
            this.string2 = data["string2"];
            this.string3 = data["string3"];
            this.string4 = data["string4"];
            this.string5 = data["string5"];
        }
    }

    static fromJS(data: any): OrderLine {
        data = typeof data === 'object' ? data : {};
        let result = new OrderLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderLineNo"] = this.orderLineNo;
        data["itemCode"] = this.itemCode;
        data["itemId"] = this.itemId;
        data["inventoryType"] = this.inventoryType;
        data["itemName"] = this.itemName;
        data["pcs"] = this.pcs;
        data["isGift"] = this.isGift;
        data["skuProperty"] = this.skuProperty;
        data["planQty"] = this.planQty;
        data["stockUnit"] = this.stockUnit;
        data["purchasePrice"] = this.purchasePrice;
        data["priceCount"] = this.priceCount;
        data["retailPrice"] = this.retailPrice;
        data["productDate"] = this.productDate ? this.productDate.toISOString() : <any>undefined;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["produceCode"] = this.produceCode;
        data["batchCode"] = this.batchCode;
        data["string1"] = this.string1;
        data["string2"] = this.string2;
        data["string3"] = this.string3;
        data["string4"] = this.string4;
        data["string5"] = this.string5;
        return data; 
    }
}

export interface IOrderLine {
    orderLineNo: string;
    itemCode: string;
    itemId: string | undefined;
    inventoryType: string | undefined;
    itemName: string;
    pcs: string | undefined;
    isGift: string | undefined;
    skuProperty: string | undefined;
    planQty: number | undefined;
    stockUnit: string | undefined;
    purchasePrice: number | undefined;
    priceCount: number | undefined;
    retailPrice: number | undefined;
    productDate: moment.Moment | undefined;
    expireDate: moment.Moment | undefined;
    produceCode: string | undefined;
    batchCode: string | undefined;
    string1: string | undefined;
    string2: string | undefined;
    string3: string | undefined;
    string4: string | undefined;
    string5: string | undefined;
}

export class G2EntryOrderCreatUnloadingInforOutput implements IG2EntryOrderCreatUnloadingInforOutput {
    code: number | undefined;
    message: string | undefined;

    constructor(data?: IG2EntryOrderCreatUnloadingInforOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): G2EntryOrderCreatUnloadingInforOutput {
        data = typeof data === 'object' ? data : {};
        let result = new G2EntryOrderCreatUnloadingInforOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }
}

export interface IG2EntryOrderCreatUnloadingInforOutput {
    code: number | undefined;
    message: string | undefined;
}

export class G2OutBoundInforInput implements IG2OutBoundInforInput {
    deliveryOrderCode: string;
    orderType: string;
    warehouseCode: string;
    ownerCode: string;
    createTime: moment.Moment | undefined;
    scheduleDate: moment.Moment | undefined;
    logisticsCode: string | undefined;
    logisticsName: string | undefined;
    transportMode: string | undefined;
    remark: string | undefined;
    sendInfo: G2OutBoundInforInputSendInfo | undefined;
    getInfo: G2OutBoundInforInputGetInfo | undefined;
    pickInfo: G2OutBoundInforInputPickInfo | undefined;
    orderLines: G2OutBoundInforInputOrderLines[] | undefined;

    constructor(data?: IG2OutBoundInforInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deliveryOrderCode = data["deliveryOrderCode"];
            this.orderType = data["orderType"];
            this.warehouseCode = data["warehouseCode"];
            this.ownerCode = data["ownerCode"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.scheduleDate = data["scheduleDate"] ? moment(data["scheduleDate"].toString()) : <any>undefined;
            this.logisticsCode = data["logisticsCode"];
            this.logisticsName = data["logisticsName"];
            this.transportMode = data["transportMode"];
            this.remark = data["remark"];
            this.sendInfo = data["sendInfo"] ? G2OutBoundInforInputSendInfo.fromJS(data["sendInfo"]) : <any>undefined;
            this.getInfo = data["getInfo"] ? G2OutBoundInforInputGetInfo.fromJS(data["getInfo"]) : <any>undefined;
            this.pickInfo = data["pickInfo"] ? G2OutBoundInforInputPickInfo.fromJS(data["pickInfo"]) : <any>undefined;
            if (data["orderLines"] && data["orderLines"].constructor === Array) {
                this.orderLines = [];
                for (let item of data["orderLines"])
                    this.orderLines.push(G2OutBoundInforInputOrderLines.fromJS(item));
            }
        }
    }

    static fromJS(data: any): G2OutBoundInforInput {
        data = typeof data === 'object' ? data : {};
        let result = new G2OutBoundInforInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryOrderCode"] = this.deliveryOrderCode;
        data["orderType"] = this.orderType;
        data["warehouseCode"] = this.warehouseCode;
        data["ownerCode"] = this.ownerCode;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["scheduleDate"] = this.scheduleDate ? this.scheduleDate.toISOString() : <any>undefined;
        data["logisticsCode"] = this.logisticsCode;
        data["logisticsName"] = this.logisticsName;
        data["transportMode"] = this.transportMode;
        data["remark"] = this.remark;
        data["sendInfo"] = this.sendInfo ? this.sendInfo.toJSON() : <any>undefined;
        data["getInfo"] = this.getInfo ? this.getInfo.toJSON() : <any>undefined;
        data["pickInfo"] = this.pickInfo ? this.pickInfo.toJSON() : <any>undefined;
        if (this.orderLines && this.orderLines.constructor === Array) {
            data["orderLines"] = [];
            for (let item of this.orderLines)
                data["orderLines"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IG2OutBoundInforInput {
    deliveryOrderCode: string;
    orderType: string;
    warehouseCode: string;
    ownerCode: string;
    createTime: moment.Moment | undefined;
    scheduleDate: moment.Moment | undefined;
    logisticsCode: string | undefined;
    logisticsName: string | undefined;
    transportMode: string | undefined;
    remark: string | undefined;
    sendInfo: G2OutBoundInforInputSendInfo | undefined;
    getInfo: G2OutBoundInforInputGetInfo | undefined;
    pickInfo: G2OutBoundInforInputPickInfo | undefined;
    orderLines: G2OutBoundInforInputOrderLines[] | undefined;
}

export class G2OutBoundInforInputSendInfo implements IG2OutBoundInforInputSendInfo {
    senderCompany: string | undefined;
    senderName: string | undefined;
    senderZipcode: string | undefined;
    senderTel: string | undefined;
    senderMobile: string | undefined;
    senderEmail: string | undefined;
    senderCountrycode: string | undefined;
    senderProvince: string | undefined;
    senderCity: string | undefined;
    senderArea: string | undefined;
    senderTown: string | undefined;
    senderDetailddress: string | undefined;
    senderId: string | undefined;

    constructor(data?: IG2OutBoundInforInputSendInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.senderCompany = data["senderCompany"];
            this.senderName = data["senderName"];
            this.senderZipcode = data["senderZipcode"];
            this.senderTel = data["senderTel"];
            this.senderMobile = data["senderMobile"];
            this.senderEmail = data["senderEmail"];
            this.senderCountrycode = data["senderCountrycode"];
            this.senderProvince = data["senderProvince"];
            this.senderCity = data["senderCity"];
            this.senderArea = data["senderArea"];
            this.senderTown = data["senderTown"];
            this.senderDetailddress = data["senderDetailddress"];
            this.senderId = data["senderId"];
        }
    }

    static fromJS(data: any): G2OutBoundInforInputSendInfo {
        data = typeof data === 'object' ? data : {};
        let result = new G2OutBoundInforInputSendInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderCompany"] = this.senderCompany;
        data["senderName"] = this.senderName;
        data["senderZipcode"] = this.senderZipcode;
        data["senderTel"] = this.senderTel;
        data["senderMobile"] = this.senderMobile;
        data["senderEmail"] = this.senderEmail;
        data["senderCountrycode"] = this.senderCountrycode;
        data["senderProvince"] = this.senderProvince;
        data["senderCity"] = this.senderCity;
        data["senderArea"] = this.senderArea;
        data["senderTown"] = this.senderTown;
        data["senderDetailddress"] = this.senderDetailddress;
        data["senderId"] = this.senderId;
        return data; 
    }
}

export interface IG2OutBoundInforInputSendInfo {
    senderCompany: string | undefined;
    senderName: string | undefined;
    senderZipcode: string | undefined;
    senderTel: string | undefined;
    senderMobile: string | undefined;
    senderEmail: string | undefined;
    senderCountrycode: string | undefined;
    senderProvince: string | undefined;
    senderCity: string | undefined;
    senderArea: string | undefined;
    senderTown: string | undefined;
    senderDetailddress: string | undefined;
    senderId: string | undefined;
}

export class G2OutBoundInforInputGetInfo implements IG2OutBoundInforInputGetInfo {
    getCompany: string | undefined;
    getName: string | undefined;
    getZipcode: string | undefined;
    getTel: string | undefined;
    getMobile: string | undefined;
    getEmail: string | undefined;
    getCountrycode: string | undefined;
    getProvince: string;
    getCity: string;
    getArea: string | undefined;
    getTown: string | undefined;
    getDetailAddress: string;
    getId: string | undefined;

    constructor(data?: IG2OutBoundInforInputGetInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.getCompany = data["getCompany"];
            this.getName = data["getName"];
            this.getZipcode = data["getZipcode"];
            this.getTel = data["getTel"];
            this.getMobile = data["getMobile"];
            this.getEmail = data["getEmail"];
            this.getCountrycode = data["getCountrycode"];
            this.getProvince = data["getProvince"];
            this.getCity = data["getCity"];
            this.getArea = data["getArea"];
            this.getTown = data["getTown"];
            this.getDetailAddress = data["getDetailAddress"];
            this.getId = data["getId"];
        }
    }

    static fromJS(data: any): G2OutBoundInforInputGetInfo {
        data = typeof data === 'object' ? data : {};
        let result = new G2OutBoundInforInputGetInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["getCompany"] = this.getCompany;
        data["getName"] = this.getName;
        data["getZipcode"] = this.getZipcode;
        data["getTel"] = this.getTel;
        data["getMobile"] = this.getMobile;
        data["getEmail"] = this.getEmail;
        data["getCountrycode"] = this.getCountrycode;
        data["getProvince"] = this.getProvince;
        data["getCity"] = this.getCity;
        data["getArea"] = this.getArea;
        data["getTown"] = this.getTown;
        data["getDetailAddress"] = this.getDetailAddress;
        data["getId"] = this.getId;
        return data; 
    }
}

export interface IG2OutBoundInforInputGetInfo {
    getCompany: string | undefined;
    getName: string | undefined;
    getZipcode: string | undefined;
    getTel: string | undefined;
    getMobile: string | undefined;
    getEmail: string | undefined;
    getCountrycode: string | undefined;
    getProvince: string;
    getCity: string;
    getArea: string | undefined;
    getTown: string | undefined;
    getDetailAddress: string;
    getId: string | undefined;
}

export class G2OutBoundInforInputPickInfo implements IG2OutBoundInforInputPickInfo {
    pickerInfoCompany: string | undefined;
    pickerInfoName: string | undefined;
    pickerInfoTel: string | undefined;
    pickerInfoMobile: string | undefined;
    pickerInfoId: string | undefined;
    pickerInfoCarno: string | undefined;

    constructor(data?: IG2OutBoundInforInputPickInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pickerInfoCompany = data["pickerInfoCompany"];
            this.pickerInfoName = data["pickerInfoName"];
            this.pickerInfoTel = data["pickerInfoTel"];
            this.pickerInfoMobile = data["pickerInfoMobile"];
            this.pickerInfoId = data["pickerInfoId"];
            this.pickerInfoCarno = data["pickerInfoCarno"];
        }
    }

    static fromJS(data: any): G2OutBoundInforInputPickInfo {
        data = typeof data === 'object' ? data : {};
        let result = new G2OutBoundInforInputPickInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pickerInfoCompany"] = this.pickerInfoCompany;
        data["pickerInfoName"] = this.pickerInfoName;
        data["pickerInfoTel"] = this.pickerInfoTel;
        data["pickerInfoMobile"] = this.pickerInfoMobile;
        data["pickerInfoId"] = this.pickerInfoId;
        data["pickerInfoCarno"] = this.pickerInfoCarno;
        return data; 
    }
}

export interface IG2OutBoundInforInputPickInfo {
    pickerInfoCompany: string | undefined;
    pickerInfoName: string | undefined;
    pickerInfoTel: string | undefined;
    pickerInfoMobile: string | undefined;
    pickerInfoId: string | undefined;
    pickerInfoCarno: string | undefined;
}

export class G2OutBoundInforInputOrderLines implements IG2OutBoundInforInputOrderLines {
    orderLineNo: string;
    ownerCode: string | undefined;
    itemCode: string;
    itemId: string | undefined;
    itemName: string | undefined;
    inventoryType: string | undefined;
    unit: string;
    planQty: string;
    batchCode: string | undefined;
    productDate: string | undefined;
    expireDate: string | undefined;
    produceCode: string | undefined;

    constructor(data?: IG2OutBoundInforInputOrderLines) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderLineNo = data["orderLineNo"];
            this.ownerCode = data["ownerCode"];
            this.itemCode = data["itemCode"];
            this.itemId = data["itemId"];
            this.itemName = data["itemName"];
            this.inventoryType = data["inventoryType"];
            this.unit = data["unit"];
            this.planQty = data["planQty"];
            this.batchCode = data["batchCode"];
            this.productDate = data["productDate"];
            this.expireDate = data["expireDate"];
            this.produceCode = data["produceCode"];
        }
    }

    static fromJS(data: any): G2OutBoundInforInputOrderLines {
        data = typeof data === 'object' ? data : {};
        let result = new G2OutBoundInforInputOrderLines();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderLineNo"] = this.orderLineNo;
        data["ownerCode"] = this.ownerCode;
        data["itemCode"] = this.itemCode;
        data["itemId"] = this.itemId;
        data["itemName"] = this.itemName;
        data["inventoryType"] = this.inventoryType;
        data["unit"] = this.unit;
        data["planQty"] = this.planQty;
        data["batchCode"] = this.batchCode;
        data["productDate"] = this.productDate;
        data["expireDate"] = this.expireDate;
        data["produceCode"] = this.produceCode;
        return data; 
    }
}

export interface IG2OutBoundInforInputOrderLines {
    orderLineNo: string;
    ownerCode: string | undefined;
    itemCode: string;
    itemId: string | undefined;
    itemName: string | undefined;
    inventoryType: string | undefined;
    unit: string;
    planQty: string;
    batchCode: string | undefined;
    productDate: string | undefined;
    expireDate: string | undefined;
    produceCode: string | undefined;
}

export class G2OutBoundInforOutput implements IG2OutBoundInforOutput {
    code: number | undefined;
    message: string | undefined;

    constructor(data?: IG2OutBoundInforOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): G2OutBoundInforOutput {
        data = typeof data === 'object' ? data : {};
        let result = new G2OutBoundInforOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }
}

export interface IG2OutBoundInforOutput {
    code: number | undefined;
    message: string | undefined;
}

export class SaleOrderSyncInsertOrdersInput implements ISaleOrderSyncInsertOrdersInput {
    deliverOrderType: string;
    orderCode: string;
    orderCodeWms: string;
    orderCode2: string | undefined;
    preDeliveryOrderCode: string;
    preDeliveryOrderCodeWms: string;
    projectCode: string;
    warehouseCode: string;
    ownerCode: string;
    orderTime: moment.Moment | undefined;
    operTimeERP: moment.Moment | undefined;
    payTime: moment.Moment | undefined;
    deliveryTime: moment.Moment | undefined;
    earliestDeliveryTime: moment.Moment | undefined;
    latestDeliveryTime: moment.Moment | undefined;
    consigneeCode: string | undefined;
    shippingMethod: string | undefined;
    logisticsCode: string;
    logisticsName: string;
    expressCode: string | undefined;
    pickingAddress: string | undefined;
    earliestPickingTime: moment.Moment | undefined;
    latestPickingTime: moment.Moment | undefined;
    sales: string | undefined;
    saleTel: string | undefined;
    callCenterTel: string | undefined;
    paymentMethod: string | undefined;
    payStatus: string | undefined;
    totalAmount: string | undefined;
    amount: string | undefined;
    gotAmount: string | undefined;
    itemAmount: string | undefined;
    discountAmount: string | undefined;
    freight: string | undefined;
    serviceFee: string | undefined;
    isUrgency: string | undefined;
    isInvoiceFlag: string | undefined;
    remark: string | undefined;
    shopName: string | undefined;
    remark1: string | undefined;
    remark2: string | undefined;
    remark3: string | undefined;
    remark4: string | undefined;
    remark5: string | undefined;
    remark6: string | undefined;
    remark7: string | undefined;
    salePlate: string | undefined;
    getInfo: SaleOrderSyncInsertOrdersInputGetInfo;
    sendInfo: SaleOrderSyncInsertOrdersInputSendInfo | undefined;
    invoices: SaleOrderSyncInsertOrdersInputInvoices[] | undefined;
    cargo: SaleOrderSyncInsertOrdersInputCargo[] | undefined;

    constructor(data?: ISaleOrderSyncInsertOrdersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.getInfo = new SaleOrderSyncInsertOrdersInputGetInfo();
        }
    }

    init(data?: any) {
        if (data) {
            this.deliverOrderType = data["deliverOrderType"];
            this.orderCode = data["orderCode"];
            this.orderCodeWms = data["orderCodeWms"];
            this.orderCode2 = data["orderCode2"];
            this.preDeliveryOrderCode = data["preDeliveryOrderCode"];
            this.preDeliveryOrderCodeWms = data["preDeliveryOrderCodeWms"];
            this.projectCode = data["projectCode"];
            this.warehouseCode = data["warehouseCode"];
            this.ownerCode = data["ownerCode"];
            this.orderTime = data["orderTime"] ? moment(data["orderTime"].toString()) : <any>undefined;
            this.operTimeERP = data["operTimeERP"] ? moment(data["operTimeERP"].toString()) : <any>undefined;
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.deliveryTime = data["deliveryTime"] ? moment(data["deliveryTime"].toString()) : <any>undefined;
            this.earliestDeliveryTime = data["earliestDeliveryTime"] ? moment(data["earliestDeliveryTime"].toString()) : <any>undefined;
            this.latestDeliveryTime = data["latestDeliveryTime"] ? moment(data["latestDeliveryTime"].toString()) : <any>undefined;
            this.consigneeCode = data["consigneeCode"];
            this.shippingMethod = data["shippingMethod"];
            this.logisticsCode = data["logisticsCode"];
            this.logisticsName = data["logisticsName"];
            this.expressCode = data["expressCode"];
            this.pickingAddress = data["pickingAddress"];
            this.earliestPickingTime = data["earliestPickingTime"] ? moment(data["earliestPickingTime"].toString()) : <any>undefined;
            this.latestPickingTime = data["latestPickingTime"] ? moment(data["latestPickingTime"].toString()) : <any>undefined;
            this.sales = data["sales"];
            this.saleTel = data["saleTel"];
            this.callCenterTel = data["callCenterTel"];
            this.paymentMethod = data["paymentMethod"];
            this.payStatus = data["payStatus"];
            this.totalAmount = data["totalAmount"];
            this.amount = data["amount"];
            this.gotAmount = data["gotAmount"];
            this.itemAmount = data["itemAmount"];
            this.discountAmount = data["discountAmount"];
            this.freight = data["freight"];
            this.serviceFee = data["serviceFee"];
            this.isUrgency = data["isUrgency"];
            this.isInvoiceFlag = data["isInvoiceFlag"];
            this.remark = data["remark"];
            this.shopName = data["shopName"];
            this.remark1 = data["remark1"];
            this.remark2 = data["remark2"];
            this.remark3 = data["remark3"];
            this.remark4 = data["remark4"];
            this.remark5 = data["remark5"];
            this.remark6 = data["remark6"];
            this.remark7 = data["remark7"];
            this.salePlate = data["salePlate"];
            this.getInfo = data["getInfo"] ? SaleOrderSyncInsertOrdersInputGetInfo.fromJS(data["getInfo"]) : new SaleOrderSyncInsertOrdersInputGetInfo();
            this.sendInfo = data["sendInfo"] ? SaleOrderSyncInsertOrdersInputSendInfo.fromJS(data["sendInfo"]) : <any>undefined;
            if (data["invoices"] && data["invoices"].constructor === Array) {
                this.invoices = [];
                for (let item of data["invoices"])
                    this.invoices.push(SaleOrderSyncInsertOrdersInputInvoices.fromJS(item));
            }
            if (data["cargo"] && data["cargo"].constructor === Array) {
                this.cargo = [];
                for (let item of data["cargo"])
                    this.cargo.push(SaleOrderSyncInsertOrdersInputCargo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SaleOrderSyncInsertOrdersInput {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOrderSyncInsertOrdersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliverOrderType"] = this.deliverOrderType;
        data["orderCode"] = this.orderCode;
        data["orderCodeWms"] = this.orderCodeWms;
        data["orderCode2"] = this.orderCode2;
        data["preDeliveryOrderCode"] = this.preDeliveryOrderCode;
        data["preDeliveryOrderCodeWms"] = this.preDeliveryOrderCodeWms;
        data["projectCode"] = this.projectCode;
        data["warehouseCode"] = this.warehouseCode;
        data["ownerCode"] = this.ownerCode;
        data["orderTime"] = this.orderTime ? this.orderTime.toISOString() : <any>undefined;
        data["operTimeERP"] = this.operTimeERP ? this.operTimeERP.toISOString() : <any>undefined;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["deliveryTime"] = this.deliveryTime ? this.deliveryTime.toISOString() : <any>undefined;
        data["earliestDeliveryTime"] = this.earliestDeliveryTime ? this.earliestDeliveryTime.toISOString() : <any>undefined;
        data["latestDeliveryTime"] = this.latestDeliveryTime ? this.latestDeliveryTime.toISOString() : <any>undefined;
        data["consigneeCode"] = this.consigneeCode;
        data["shippingMethod"] = this.shippingMethod;
        data["logisticsCode"] = this.logisticsCode;
        data["logisticsName"] = this.logisticsName;
        data["expressCode"] = this.expressCode;
        data["pickingAddress"] = this.pickingAddress;
        data["earliestPickingTime"] = this.earliestPickingTime ? this.earliestPickingTime.toISOString() : <any>undefined;
        data["latestPickingTime"] = this.latestPickingTime ? this.latestPickingTime.toISOString() : <any>undefined;
        data["sales"] = this.sales;
        data["saleTel"] = this.saleTel;
        data["callCenterTel"] = this.callCenterTel;
        data["paymentMethod"] = this.paymentMethod;
        data["payStatus"] = this.payStatus;
        data["totalAmount"] = this.totalAmount;
        data["amount"] = this.amount;
        data["gotAmount"] = this.gotAmount;
        data["itemAmount"] = this.itemAmount;
        data["discountAmount"] = this.discountAmount;
        data["freight"] = this.freight;
        data["serviceFee"] = this.serviceFee;
        data["isUrgency"] = this.isUrgency;
        data["isInvoiceFlag"] = this.isInvoiceFlag;
        data["remark"] = this.remark;
        data["shopName"] = this.shopName;
        data["remark1"] = this.remark1;
        data["remark2"] = this.remark2;
        data["remark3"] = this.remark3;
        data["remark4"] = this.remark4;
        data["remark5"] = this.remark5;
        data["remark6"] = this.remark6;
        data["remark7"] = this.remark7;
        data["salePlate"] = this.salePlate;
        data["getInfo"] = this.getInfo ? this.getInfo.toJSON() : <any>undefined;
        data["sendInfo"] = this.sendInfo ? this.sendInfo.toJSON() : <any>undefined;
        if (this.invoices && this.invoices.constructor === Array) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        if (this.cargo && this.cargo.constructor === Array) {
            data["cargo"] = [];
            for (let item of this.cargo)
                data["cargo"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISaleOrderSyncInsertOrdersInput {
    deliverOrderType: string;
    orderCode: string;
    orderCodeWms: string;
    orderCode2: string | undefined;
    preDeliveryOrderCode: string;
    preDeliveryOrderCodeWms: string;
    projectCode: string;
    warehouseCode: string;
    ownerCode: string;
    orderTime: moment.Moment | undefined;
    operTimeERP: moment.Moment | undefined;
    payTime: moment.Moment | undefined;
    deliveryTime: moment.Moment | undefined;
    earliestDeliveryTime: moment.Moment | undefined;
    latestDeliveryTime: moment.Moment | undefined;
    consigneeCode: string | undefined;
    shippingMethod: string | undefined;
    logisticsCode: string;
    logisticsName: string;
    expressCode: string | undefined;
    pickingAddress: string | undefined;
    earliestPickingTime: moment.Moment | undefined;
    latestPickingTime: moment.Moment | undefined;
    sales: string | undefined;
    saleTel: string | undefined;
    callCenterTel: string | undefined;
    paymentMethod: string | undefined;
    payStatus: string | undefined;
    totalAmount: string | undefined;
    amount: string | undefined;
    gotAmount: string | undefined;
    itemAmount: string | undefined;
    discountAmount: string | undefined;
    freight: string | undefined;
    serviceFee: string | undefined;
    isUrgency: string | undefined;
    isInvoiceFlag: string | undefined;
    remark: string | undefined;
    shopName: string | undefined;
    remark1: string | undefined;
    remark2: string | undefined;
    remark3: string | undefined;
    remark4: string | undefined;
    remark5: string | undefined;
    remark6: string | undefined;
    remark7: string | undefined;
    salePlate: string | undefined;
    getInfo: SaleOrderSyncInsertOrdersInputGetInfo;
    sendInfo: SaleOrderSyncInsertOrdersInputSendInfo | undefined;
    invoices: SaleOrderSyncInsertOrdersInputInvoices[] | undefined;
    cargo: SaleOrderSyncInsertOrdersInputCargo[] | undefined;
}

export class SaleOrderSyncInsertOrdersInputGetInfo implements ISaleOrderSyncInsertOrdersInputGetInfo {
    consignee: string | undefined;
    custmoerCode: string | undefined;
    consigneeOrg: string | undefined;
    consigneePhone: string | undefined;
    deliveryProvince: string | undefined;
    deliveryCity: string | undefined;
    deliveryDistrict: string | undefined;
    deliveryVillage: string | undefined;
    deliveryAddress: string | undefined;

    constructor(data?: ISaleOrderSyncInsertOrdersInputGetInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.consignee = data["consignee"];
            this.custmoerCode = data["custmoerCode"];
            this.consigneeOrg = data["consigneeOrg"];
            this.consigneePhone = data["consigneePhone"];
            this.deliveryProvince = data["deliveryProvince"];
            this.deliveryCity = data["deliveryCity"];
            this.deliveryDistrict = data["deliveryDistrict"];
            this.deliveryVillage = data["deliveryVillage"];
            this.deliveryAddress = data["deliveryAddress"];
        }
    }

    static fromJS(data: any): SaleOrderSyncInsertOrdersInputGetInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOrderSyncInsertOrdersInputGetInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consignee"] = this.consignee;
        data["custmoerCode"] = this.custmoerCode;
        data["consigneeOrg"] = this.consigneeOrg;
        data["consigneePhone"] = this.consigneePhone;
        data["deliveryProvince"] = this.deliveryProvince;
        data["deliveryCity"] = this.deliveryCity;
        data["deliveryDistrict"] = this.deliveryDistrict;
        data["deliveryVillage"] = this.deliveryVillage;
        data["deliveryAddress"] = this.deliveryAddress;
        return data; 
    }
}

export interface ISaleOrderSyncInsertOrdersInputGetInfo {
    consignee: string | undefined;
    custmoerCode: string | undefined;
    consigneeOrg: string | undefined;
    consigneePhone: string | undefined;
    deliveryProvince: string | undefined;
    deliveryCity: string | undefined;
    deliveryDistrict: string | undefined;
    deliveryVillage: string | undefined;
    deliveryAddress: string | undefined;
}

export class SaleOrderSyncInsertOrdersInputSendInfo implements ISaleOrderSyncInsertOrdersInputSendInfo {
    shipper: string | undefined;
    forwardingOrg: string | undefined;
    sPhone: string | undefined;

    constructor(data?: ISaleOrderSyncInsertOrdersInputSendInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.shipper = data["shipper"];
            this.forwardingOrg = data["forwardingOrg"];
            this.sPhone = data["sPhone"];
        }
    }

    static fromJS(data: any): SaleOrderSyncInsertOrdersInputSendInfo {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOrderSyncInsertOrdersInputSendInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["shipper"] = this.shipper;
        data["forwardingOrg"] = this.forwardingOrg;
        data["sPhone"] = this.sPhone;
        return data; 
    }
}

export interface ISaleOrderSyncInsertOrdersInputSendInfo {
    shipper: string | undefined;
    forwardingOrg: string | undefined;
    sPhone: string | undefined;
}

export class SaleOrderSyncInsertOrdersInputInvoices implements ISaleOrderSyncInsertOrdersInputInvoices {
    invoiceType: string;
    invoiceHeader: string;
    invoiceAmount: string;
    invoiceContent: string | undefined;
    invoiceDetail: SaleOrderSyncInsertOrdersInputInvoiceDetail | undefined;

    constructor(data?: ISaleOrderSyncInsertOrdersInputInvoices) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.invoiceType = data["invoiceType"];
            this.invoiceHeader = data["invoiceHeader"];
            this.invoiceAmount = data["invoiceAmount"];
            this.invoiceContent = data["invoiceContent"];
            this.invoiceDetail = data["invoiceDetail"] ? SaleOrderSyncInsertOrdersInputInvoiceDetail.fromJS(data["invoiceDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SaleOrderSyncInsertOrdersInputInvoices {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOrderSyncInsertOrdersInputInvoices();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceType"] = this.invoiceType;
        data["invoiceHeader"] = this.invoiceHeader;
        data["invoiceAmount"] = this.invoiceAmount;
        data["invoiceContent"] = this.invoiceContent;
        data["invoiceDetail"] = this.invoiceDetail ? this.invoiceDetail.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISaleOrderSyncInsertOrdersInputInvoices {
    invoiceType: string;
    invoiceHeader: string;
    invoiceAmount: string;
    invoiceContent: string | undefined;
    invoiceDetail: SaleOrderSyncInsertOrdersInputInvoiceDetail | undefined;
}

export class SaleOrderSyncInsertOrdersInputCargo implements ISaleOrderSyncInsertOrdersInputCargo {
    orderLineNo: string;
    itemCode: string;
    name: string | undefined;
    type: string | undefined;
    unit: string | undefined;
    quantity: number | undefined;
    inventoryType: string | undefined;
    retailPrice: number | undefined;
    prodPrice: string | undefined;
    actualPrice: number | undefined;
    balancePrice: string | undefined;
    discountAmount: number | undefined;
    productDate: moment.Moment | undefined;
    expireDate: moment.Moment | undefined;
    produceCode: string | undefined;
    batchCode: string | undefined;
    remark1: string | undefined;
    remark2: string | undefined;
    remark3: string | undefined;

    constructor(data?: ISaleOrderSyncInsertOrdersInputCargo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderLineNo = data["orderLineNo"];
            this.itemCode = data["itemCode"];
            this.name = data["name"];
            this.type = data["type"];
            this.unit = data["unit"];
            this.quantity = data["quantity"];
            this.inventoryType = data["inventoryType"];
            this.retailPrice = data["retailPrice"];
            this.prodPrice = data["prodPrice"];
            this.actualPrice = data["actualPrice"];
            this.balancePrice = data["balancePrice"];
            this.discountAmount = data["discountAmount"];
            this.productDate = data["productDate"] ? moment(data["productDate"].toString()) : <any>undefined;
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.produceCode = data["produceCode"];
            this.batchCode = data["batchCode"];
            this.remark1 = data["remark1"];
            this.remark2 = data["remark2"];
            this.remark3 = data["remark3"];
        }
    }

    static fromJS(data: any): SaleOrderSyncInsertOrdersInputCargo {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOrderSyncInsertOrdersInputCargo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderLineNo"] = this.orderLineNo;
        data["itemCode"] = this.itemCode;
        data["name"] = this.name;
        data["type"] = this.type;
        data["unit"] = this.unit;
        data["quantity"] = this.quantity;
        data["inventoryType"] = this.inventoryType;
        data["retailPrice"] = this.retailPrice;
        data["prodPrice"] = this.prodPrice;
        data["actualPrice"] = this.actualPrice;
        data["balancePrice"] = this.balancePrice;
        data["discountAmount"] = this.discountAmount;
        data["productDate"] = this.productDate ? this.productDate.toISOString() : <any>undefined;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["produceCode"] = this.produceCode;
        data["batchCode"] = this.batchCode;
        data["remark1"] = this.remark1;
        data["remark2"] = this.remark2;
        data["remark3"] = this.remark3;
        return data; 
    }
}

export interface ISaleOrderSyncInsertOrdersInputCargo {
    orderLineNo: string;
    itemCode: string;
    name: string | undefined;
    type: string | undefined;
    unit: string | undefined;
    quantity: number | undefined;
    inventoryType: string | undefined;
    retailPrice: number | undefined;
    prodPrice: string | undefined;
    actualPrice: number | undefined;
    balancePrice: string | undefined;
    discountAmount: number | undefined;
    productDate: moment.Moment | undefined;
    expireDate: moment.Moment | undefined;
    produceCode: string | undefined;
    batchCode: string | undefined;
    remark1: string | undefined;
    remark2: string | undefined;
    remark3: string | undefined;
}

export class SaleOrderSyncInsertOrdersInputInvoiceDetail implements ISaleOrderSyncInsertOrdersInputInvoiceDetail {
    itemName: string | undefined;
    unit: string | undefined;
    price: number | undefined;
    quantity: number | undefined;
    amount: number | undefined;

    constructor(data?: ISaleOrderSyncInsertOrdersInputInvoiceDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemName = data["itemName"];
            this.unit = data["unit"];
            this.price = data["price"];
            this.quantity = data["quantity"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): SaleOrderSyncInsertOrdersInputInvoiceDetail {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOrderSyncInsertOrdersInputInvoiceDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemName"] = this.itemName;
        data["unit"] = this.unit;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface ISaleOrderSyncInsertOrdersInputInvoiceDetail {
    itemName: string | undefined;
    unit: string | undefined;
    price: number | undefined;
    quantity: number | undefined;
    amount: number | undefined;
}

export class SaleOrderSyncInsertOrdersOutput implements ISaleOrderSyncInsertOrdersOutput {
    code: number | undefined;
    message: string | undefined;

    constructor(data?: ISaleOrderSyncInsertOrdersOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): SaleOrderSyncInsertOrdersOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SaleOrderSyncInsertOrdersOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }
}

export interface ISaleOrderSyncInsertOrdersOutput {
    code: number | undefined;
    message: string | undefined;
}

export class G2CancelOrdersInput implements IG2CancelOrdersInput {
    type: number | undefined;
    orders: SupplyDistributeCancelOrdersInputOrder[];

    constructor(data?: IG2CancelOrdersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.orders = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["orders"] && data["orders"].constructor === Array) {
                this.orders = [];
                for (let item of data["orders"])
                    this.orders.push(SupplyDistributeCancelOrdersInputOrder.fromJS(item));
            }
        }
    }

    static fromJS(data: any): G2CancelOrdersInput {
        data = typeof data === 'object' ? data : {};
        let result = new G2CancelOrdersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.orders && this.orders.constructor === Array) {
            data["orders"] = [];
            for (let item of this.orders)
                data["orders"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IG2CancelOrdersInput {
    type: number | undefined;
    orders: SupplyDistributeCancelOrdersInputOrder[];
}

export class SupplyDistributeCancelOrdersInputOrder implements ISupplyDistributeCancelOrdersInputOrder {
    orderCode: string;
    orgCode: string | undefined;
    orderType: string;

    constructor(data?: ISupplyDistributeCancelOrdersInputOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderCode = data["orderCode"];
            this.orgCode = data["orgCode"];
            this.orderType = data["orderType"];
        }
    }

    static fromJS(data: any): SupplyDistributeCancelOrdersInputOrder {
        data = typeof data === 'object' ? data : {};
        let result = new SupplyDistributeCancelOrdersInputOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderCode"] = this.orderCode;
        data["orgCode"] = this.orgCode;
        data["orderType"] = this.orderType;
        return data; 
    }
}

export interface ISupplyDistributeCancelOrdersInputOrder {
    orderCode: string;
    orgCode: string | undefined;
    orderType: string;
}

export class SupplyDistributeCancelAllOrdersOutput implements ISupplyDistributeCancelAllOrdersOutput {
    data: SupplyDistributeData | undefined;
    code: number | undefined;
    message: string | undefined;

    constructor(data?: ISupplyDistributeCancelAllOrdersOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.data = data["data"] ? SupplyDistributeData.fromJS(data["data"]) : <any>undefined;
            this.code = data["code"];
            this.message = data["message"];
        }
    }

    static fromJS(data: any): SupplyDistributeCancelAllOrdersOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SupplyDistributeCancelAllOrdersOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["code"] = this.code;
        data["message"] = this.message;
        return data; 
    }
}

export interface ISupplyDistributeCancelAllOrdersOutput {
    data: SupplyDistributeData | undefined;
    code: number | undefined;
    message: string | undefined;
}

export class SupplyDistributeData implements ISupplyDistributeData {
    total: number | undefined;
    fail: CancelDataFail[] | undefined;
    success: CancelDataSuccess[] | undefined;

    constructor(data?: ISupplyDistributeData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.total = data["total"];
            if (data["fail"] && data["fail"].constructor === Array) {
                this.fail = [];
                for (let item of data["fail"])
                    this.fail.push(CancelDataFail.fromJS(item));
            }
            if (data["success"] && data["success"].constructor === Array) {
                this.success = [];
                for (let item of data["success"])
                    this.success.push(CancelDataSuccess.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SupplyDistributeData {
        data = typeof data === 'object' ? data : {};
        let result = new SupplyDistributeData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["total"] = this.total;
        if (this.fail && this.fail.constructor === Array) {
            data["fail"] = [];
            for (let item of this.fail)
                data["fail"].push(item.toJSON());
        }
        if (this.success && this.success.constructor === Array) {
            data["success"] = [];
            for (let item of this.success)
                data["success"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISupplyDistributeData {
    total: number | undefined;
    fail: CancelDataFail[] | undefined;
    success: CancelDataSuccess[] | undefined;
}

export class CancelDataFail implements ICancelDataFail {
    orderCode: string | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: ICancelDataFail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderCode = data["orderCode"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): CancelDataFail {
        data = typeof data === 'object' ? data : {};
        let result = new CancelDataFail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderCode"] = this.orderCode;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface ICancelDataFail {
    orderCode: string | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class CancelDataSuccess implements ICancelDataSuccess {
    orderCode: string | undefined;
    projectCode: string | undefined;

    constructor(data?: ICancelDataSuccess) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderCode = data["orderCode"];
            this.projectCode = data["projectCode"];
        }
    }

    static fromJS(data: any): CancelDataSuccess {
        data = typeof data === 'object' ? data : {};
        let result = new CancelDataSuccess();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderCode"] = this.orderCode;
        data["projectCode"] = this.projectCode;
        return data; 
    }
}

export interface ICancelDataSuccess {
    orderCode: string | undefined;
    projectCode: string | undefined;
}

export class HangfireSampleInput implements IHangfireSampleInput {
    subject: string;
    body: string;

    constructor(data?: IHangfireSampleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subject = data["subject"];
            this.body = data["body"];
        }
    }

    static fromJS(data: any): HangfireSampleInput {
        data = typeof data === 'object' ? data : {};
        let result = new HangfireSampleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["body"] = this.body;
        return data; 
    }
}

export interface IHangfireSampleInput {
    subject: string;
    body: string;
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: moment.Moment | undefined;
    subscriptionEndDateEnd: moment.Moment | undefined;
    tenantCreationStartDate: moment.Moment | undefined;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
            if (data["expiringTenants"] && data["expiringTenants"].constructor === Array) {
                this.expiringTenants = [];
                for (let item of data["expiringTenants"])
                    this.expiringTenants.push(ExpiringTenant.fromJS(item));
            }
            if (data["recentTenants"] && data["recentTenants"].constructor === Array) {
                this.recentTenants = [];
                for (let item of data["recentTenants"])
                    this.recentTenants.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (this.expiringTenants && this.expiringTenants.constructor === Array) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (this.recentTenants && this.recentTenants.constructor === Array) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: moment.Moment | undefined;
    subscriptionEndDateEnd: moment.Moment | undefined;
    tenantCreationStartDate: moment.Moment | undefined;
}

export class IncomeStastistic implements IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
}

export class TenantEdition implements ITenantEdition {
    label: string | undefined;
    value: number | undefined;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;
}

export class RecentTenant implements IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: moment.Moment | undefined;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["incomeStatistics"] && data["incomeStatistics"].constructor === Array) {
                this.incomeStatistics = [];
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.incomeStatistics && this.incomeStatistics.constructor === Array) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["editionStatistics"] && data["editionStatistics"].constructor === Array) {
                this.editionStatistics = [];
                for (let item of data["editionStatistics"])
                    this.editionStatistics.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.editionStatistics && this.editionStatistics.constructor === Array) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        return data; 
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecuritySettingsEditDto {
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class InstallDto implements IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto | undefined;
    billInfo: HostBillingSettingsEditDto | undefined;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : <any>undefined;
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto | undefined;
    billInfo: HostBillingSettingsEditDto | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (data["languages"] && data["languages"].constructor === Array) {
                this.languages = [];
                for (let item of data["languages"])
                    this.languages.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (this.languages && this.languages.constructor === Array) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class NameValue implements INameValue {
    name: string | undefined;
    value: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist: boolean | undefined;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean | undefined;
}

export class InvoiceDto implements IInvoiceDto {
    amount: number | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment | undefined;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? moment(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (data["tenantAddress"] && data["tenantAddress"].constructor === Array) {
                this.tenantAddress = [];
                for (let item of data["tenantAddress"])
                    this.tenantAddress.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (data["hostAddress"] && data["hostAddress"].constructor === Array) {
                this.hostAddress = [];
                for (let item of data["hostAddress"])
                    this.hostAddress.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (this.tenantAddress && this.tenantAddress.constructor === Array) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (this.hostAddress && this.hostAddress.constructor === Array) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data; 
    }
}

export interface IInvoiceDto {
    amount: number | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment | undefined;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId: number | undefined;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (data["languageNames"] && data["languageNames"].constructor === Array) {
                this.languageNames = [];
                for (let item of data["languageNames"])
                    this.languageNames.push(ComboboxItemDto.fromJS(item));
            }
            if (data["flags"] && data["flags"].constructor === Array) {
                this.flags = [];
                for (let item of data["flags"])
                    this.flags.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (this.languageNames && this.languageNames.constructor === Array) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (this.flags && this.flags.constructor === Array) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class Lk02OutboundOrderReportDatasGetOrdersOutput implements ILk02OutboundOrderReportDatasGetOrdersOutput {
    warehouseCode: string | undefined;
    companyCode: string | undefined;
    leadingSts: number | undefined;
    shipToState: string | undefined;
    created: moment.Moment | undefined;
    actualShipDateTime: moment.Moment | undefined;
    carrierCode: string | undefined;
    totalWeight: number | undefined;
    shippingContainerHeaders: ShippingContainerHeaderOutput[] | undefined;

    constructor(data?: ILk02OutboundOrderReportDatasGetOrdersOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.warehouseCode = data["warehouseCode"];
            this.companyCode = data["companyCode"];
            this.leadingSts = data["leadingSts"];
            this.shipToState = data["shipToState"];
            this.created = data["created"] ? moment(data["created"].toString()) : <any>undefined;
            this.actualShipDateTime = data["actualShipDateTime"] ? moment(data["actualShipDateTime"].toString()) : <any>undefined;
            this.carrierCode = data["carrierCode"];
            this.totalWeight = data["totalWeight"];
            if (data["shippingContainerHeaders"] && data["shippingContainerHeaders"].constructor === Array) {
                this.shippingContainerHeaders = [];
                for (let item of data["shippingContainerHeaders"])
                    this.shippingContainerHeaders.push(ShippingContainerHeaderOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Lk02OutboundOrderReportDatasGetOrdersOutput {
        data = typeof data === 'object' ? data : {};
        let result = new Lk02OutboundOrderReportDatasGetOrdersOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warehouseCode"] = this.warehouseCode;
        data["companyCode"] = this.companyCode;
        data["leadingSts"] = this.leadingSts;
        data["shipToState"] = this.shipToState;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["actualShipDateTime"] = this.actualShipDateTime ? this.actualShipDateTime.toISOString() : <any>undefined;
        data["carrierCode"] = this.carrierCode;
        data["totalWeight"] = this.totalWeight;
        if (this.shippingContainerHeaders && this.shippingContainerHeaders.constructor === Array) {
            data["shippingContainerHeaders"] = [];
            for (let item of this.shippingContainerHeaders)
                data["shippingContainerHeaders"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILk02OutboundOrderReportDatasGetOrdersOutput {
    warehouseCode: string | undefined;
    companyCode: string | undefined;
    leadingSts: number | undefined;
    shipToState: string | undefined;
    created: moment.Moment | undefined;
    actualShipDateTime: moment.Moment | undefined;
    carrierCode: string | undefined;
    totalWeight: number | undefined;
    shippingContainerHeaders: ShippingContainerHeaderOutput[] | undefined;
}

export class ShippingContainerHeaderOutput implements IShippingContainerHeaderOutput {
    scaledAt: moment.Moment | undefined;
    oqcEndAt: moment.Moment | undefined;
    waybillCode: string | undefined;

    constructor(data?: IShippingContainerHeaderOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scaledAt = data["scaledAt"] ? moment(data["scaledAt"].toString()) : <any>undefined;
            this.oqcEndAt = data["oqcEndAt"] ? moment(data["oqcEndAt"].toString()) : <any>undefined;
            this.waybillCode = data["waybillCode"];
        }
    }

    static fromJS(data: any): ShippingContainerHeaderOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ShippingContainerHeaderOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scaledAt"] = this.scaledAt ? this.scaledAt.toISOString() : <any>undefined;
        data["oqcEndAt"] = this.oqcEndAt ? this.oqcEndAt.toISOString() : <any>undefined;
        data["waybillCode"] = this.waybillCode;
        return data; 
    }
}

export interface IShippingContainerHeaderOutput {
    scaledAt: moment.Moment | undefined;
    oqcEndAt: moment.Moment | undefined;
    waybillCode: string | undefined;
}

export class Lk02OutboundOrderReportDatasGetOwnerCodesOutput implements ILk02OutboundOrderReportDatasGetOwnerCodesOutput {
    code: string;
    warehouseCode: string;
    name: string | undefined;

    constructor(data?: ILk02OutboundOrderReportDatasGetOwnerCodesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.warehouseCode = data["warehouseCode"];
            this.name = data["name"];
        }
    }

    static fromJS(data: any): Lk02OutboundOrderReportDatasGetOwnerCodesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new Lk02OutboundOrderReportDatasGetOwnerCodesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["warehouseCode"] = this.warehouseCode;
        data["name"] = this.name;
        return data; 
    }
}

export interface ILk02OutboundOrderReportDatasGetOwnerCodesOutput {
    code: string;
    warehouseCode: string;
    name: string | undefined;
}

export class GetEachStatusOrderAmountOutput implements IGetEachStatusOrderAmountOutput {
    trailingSts: number | undefined;
    amount: number | undefined;

    constructor(data?: IGetEachStatusOrderAmountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trailingSts = data["trailingSts"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): GetEachStatusOrderAmountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEachStatusOrderAmountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trailingSts"] = this.trailingSts;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IGetEachStatusOrderAmountOutput {
    trailingSts: number | undefined;
    amount: number | undefined;
}

export class GetEachProvinceOrderAmountOutput implements IGetEachProvinceOrderAmountOutput {
    province: string | undefined;
    amount: number | undefined;

    constructor(data?: IGetEachProvinceOrderAmountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.province = data["province"];
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): GetEachProvinceOrderAmountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEachProvinceOrderAmountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["province"] = this.province;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IGetEachProvinceOrderAmountOutput {
    province: string | undefined;
    amount: number | undefined;
}

export class GetEachCarrierOrderAmountOutput implements IGetEachCarrierOrderAmountOutput {
    carrierCode: string | undefined;
    amount: number | undefined;
    amount700: number | undefined;

    constructor(data?: IGetEachCarrierOrderAmountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.carrierCode = data["carrierCode"];
            this.amount = data["amount"];
            this.amount700 = data["amount700"];
        }
    }

    static fromJS(data: any): GetEachCarrierOrderAmountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEachCarrierOrderAmountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["carrierCode"] = this.carrierCode;
        data["amount"] = this.amount;
        data["amount700"] = this.amount700;
        return data; 
    }
}

export interface IGetEachCarrierOrderAmountOutput {
    carrierCode: string | undefined;
    amount: number | undefined;
    amount700: number | undefined;
}

export class GetEachCarrierAssignStatusOrderAmountOutput implements IGetEachCarrierAssignStatusOrderAmountOutput {
    carrierCode: string | undefined;
    amount: number | undefined;
    carrierStatusList: CarrierStatus[] | undefined;

    constructor(data?: IGetEachCarrierAssignStatusOrderAmountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.carrierCode = data["carrierCode"];
            this.amount = data["amount"];
            if (data["carrierStatusList"] && data["carrierStatusList"].constructor === Array) {
                this.carrierStatusList = [];
                for (let item of data["carrierStatusList"])
                    this.carrierStatusList.push(CarrierStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEachCarrierAssignStatusOrderAmountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEachCarrierAssignStatusOrderAmountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["carrierCode"] = this.carrierCode;
        data["amount"] = this.amount;
        if (this.carrierStatusList && this.carrierStatusList.constructor === Array) {
            data["carrierStatusList"] = [];
            for (let item of this.carrierStatusList)
                data["carrierStatusList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEachCarrierAssignStatusOrderAmountOutput {
    carrierCode: string | undefined;
    amount: number | undefined;
    carrierStatusList: CarrierStatus[] | undefined;
}

export class CarrierStatus implements ICarrierStatus {
    trailingSts: string | undefined;
    count: number | undefined;

    constructor(data?: ICarrierStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trailingSts = data["trailingSts"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): CarrierStatus {
        data = typeof data === 'object' ? data : {};
        let result = new CarrierStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trailingSts"] = this.trailingSts;
        data["count"] = this.count;
        return data; 
    }
}

export interface ICarrierStatus {
    trailingSts: string | undefined;
    count: number | undefined;
}

export class GetEachOwnerAndStatusOrderAmountOutput implements IGetEachOwnerAndStatusOrderAmountOutput {
    ownerCode: string | undefined;
    amount: number | undefined;
    orderStatusList: OrderStatus[] | undefined;

    constructor(data?: IGetEachOwnerAndStatusOrderAmountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerCode = data["ownerCode"];
            this.amount = data["amount"];
            if (data["orderStatusList"] && data["orderStatusList"].constructor === Array) {
                this.orderStatusList = [];
                for (let item of data["orderStatusList"])
                    this.orderStatusList.push(OrderStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEachOwnerAndStatusOrderAmountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEachOwnerAndStatusOrderAmountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerCode"] = this.ownerCode;
        data["amount"] = this.amount;
        if (this.orderStatusList && this.orderStatusList.constructor === Array) {
            data["orderStatusList"] = [];
            for (let item of this.orderStatusList)
                data["orderStatusList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEachOwnerAndStatusOrderAmountOutput {
    ownerCode: string | undefined;
    amount: number | undefined;
    orderStatusList: OrderStatus[] | undefined;
}

export class OrderStatus implements IOrderStatus {
    trailingSts: string | undefined;
    count: number | undefined;

    constructor(data?: IOrderStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.trailingSts = data["trailingSts"];
            this.count = data["count"];
        }
    }

    static fromJS(data: any): OrderStatus {
        data = typeof data === 'object' ? data : {};
        let result = new OrderStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trailingSts"] = this.trailingSts;
        data["count"] = this.count;
        return data; 
    }
}

export interface IOrderStatus {
    trailingSts: string | undefined;
    count: number | undefined;
}

export class GetPackageAmountOutput implements IGetPackageAmountOutput {
    amount: number | undefined;

    constructor(data?: IGetPackageAmountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): GetPackageAmountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPackageAmountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IGetPackageAmountOutput {
    amount: number | undefined;
}

export class GetOrderAmountByWeightOutput implements IGetOrderAmountByWeightOutput {
    amount: number | undefined;

    constructor(data?: IGetOrderAmountByWeightOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): GetOrderAmountByWeightOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrderAmountByWeightOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IGetOrderAmountByWeightOutput {
    amount: number | undefined;
}

export class GetOrderAmountByCreateTimeOutput implements IGetOrderAmountByCreateTimeOutput {
    amount: number | undefined;

    constructor(data?: IGetOrderAmountByCreateTimeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): GetOrderAmountByCreateTimeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOrderAmountByCreateTimeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IGetOrderAmountByCreateTimeOutput {
    amount: number | undefined;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;
}

export class UserNotification implements IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: TenantNotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            if (data["entityId"]) {
                this.entityId = {};
                for (let key in data["entityId"]) {
                    if (data["entityId"].hasOwnProperty(key))
                        this.entityId[key] = data["entityId"][key];
                }
            }
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        if (this.entityId) {
            data["entityId"] = {};
            for (let key in this.entityId) {
                if (this.entityId.hasOwnProperty(key))
                    data["entityId"][key] = this.entityId[key];
            }
        }
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: TenantNotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;
}

export class NotificationData implements INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            if (data["properties"]) {
                this.properties = {};
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties[key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string] : any; } | undefined;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id: string | undefined;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfGuid {
    id: string | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (data["notifications"] && data["notifications"].constructor === Array) {
                this.notifications = [];
                for (let item of data["notifications"])
                    this.notifications.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (this.notifications && this.notifications.constructor === Array) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["userIds"] && data["userIds"].constructor === Array) {
                this.userIds = [];
                for (let item of data["userIds"])
                    this.userIds.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.userIds && this.userIds.constructor === Array) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PagedResultDtoOfGetOwnerGroupMemberForView implements IPagedResultDtoOfGetOwnerGroupMemberForView {
    totalCount: number | undefined;
    items: GetOwnerGroupMemberForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetOwnerGroupMemberForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetOwnerGroupMemberForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetOwnerGroupMemberForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetOwnerGroupMemberForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetOwnerGroupMemberForView {
    totalCount: number | undefined;
    items: GetOwnerGroupMemberForView[] | undefined;
}

export class GetOwnerGroupMemberForView implements IGetOwnerGroupMemberForView {
    ownerGroupMember: OwnerGroupMemberDto | undefined;
    ownerGroupGroupName: string | undefined;

    constructor(data?: IGetOwnerGroupMemberForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerGroupMember = data["ownerGroupMember"] ? OwnerGroupMemberDto.fromJS(data["ownerGroupMember"]) : <any>undefined;
            this.ownerGroupGroupName = data["ownerGroupGroupName"];
        }
    }

    static fromJS(data: any): GetOwnerGroupMemberForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetOwnerGroupMemberForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerGroupMember"] = this.ownerGroupMember ? this.ownerGroupMember.toJSON() : <any>undefined;
        data["ownerGroupGroupName"] = this.ownerGroupGroupName;
        return data; 
    }
}

export interface IGetOwnerGroupMemberForView {
    ownerGroupMember: OwnerGroupMemberDto | undefined;
    ownerGroupGroupName: string | undefined;
}

export class OwnerGroupMemberDto implements IOwnerGroupMemberDto {
    ownerCode: string | undefined;
    ownerName: string | undefined;
    ownerGroupId: number | undefined;
    id: number | undefined;

    constructor(data?: IOwnerGroupMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerCode = data["ownerCode"];
            this.ownerName = data["ownerName"];
            this.ownerGroupId = data["ownerGroupId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OwnerGroupMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerGroupMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerCode"] = this.ownerCode;
        data["ownerName"] = this.ownerName;
        data["ownerGroupId"] = this.ownerGroupId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOwnerGroupMemberDto {
    ownerCode: string | undefined;
    ownerName: string | undefined;
    ownerGroupId: number | undefined;
    id: number | undefined;
}

export class GetOwnerGroupMemberForEditOutput implements IGetOwnerGroupMemberForEditOutput {
    ownerGroupMember: CreateOrEditOwnerGroupMemberDto | undefined;
    ownerGroupGroupName: string | undefined;

    constructor(data?: IGetOwnerGroupMemberForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerGroupMember = data["ownerGroupMember"] ? CreateOrEditOwnerGroupMemberDto.fromJS(data["ownerGroupMember"]) : <any>undefined;
            this.ownerGroupGroupName = data["ownerGroupGroupName"];
        }
    }

    static fromJS(data: any): GetOwnerGroupMemberForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOwnerGroupMemberForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerGroupMember"] = this.ownerGroupMember ? this.ownerGroupMember.toJSON() : <any>undefined;
        data["ownerGroupGroupName"] = this.ownerGroupGroupName;
        return data; 
    }
}

export interface IGetOwnerGroupMemberForEditOutput {
    ownerGroupMember: CreateOrEditOwnerGroupMemberDto | undefined;
    ownerGroupGroupName: string | undefined;
}

export class CreateOrEditOwnerGroupMemberDto implements ICreateOrEditOwnerGroupMemberDto {
    ownerCode: string;
    ownerName: string;
    ownerGroupId: number | undefined;
    id: number | undefined;

    constructor(data?: ICreateOrEditOwnerGroupMemberDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerCode = data["ownerCode"];
            this.ownerName = data["ownerName"];
            this.ownerGroupId = data["ownerGroupId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditOwnerGroupMemberDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditOwnerGroupMemberDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerCode"] = this.ownerCode;
        data["ownerName"] = this.ownerName;
        data["ownerGroupId"] = this.ownerGroupId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditOwnerGroupMemberDto {
    ownerCode: string;
    ownerName: string;
    ownerGroupId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOwnerGroupLookupTableDto implements IPagedResultDtoOfOwnerGroupLookupTableDto {
    totalCount: number | undefined;
    items: OwnerGroupLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOwnerGroupLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(OwnerGroupLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOwnerGroupLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOwnerGroupLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOwnerGroupLookupTableDto {
    totalCount: number | undefined;
    items: OwnerGroupLookupTableDto[] | undefined;
}

export class OwnerGroupLookupTableDto implements IOwnerGroupLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;

    constructor(data?: IOwnerGroupLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): OwnerGroupLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerGroupLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IOwnerGroupLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetOwnerGroupForView implements IPagedResultDtoOfGetOwnerGroupForView {
    totalCount: number | undefined;
    items: GetOwnerGroupForView[] | undefined;

    constructor(data?: IPagedResultDtoOfGetOwnerGroupForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(GetOwnerGroupForView.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetOwnerGroupForView {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetOwnerGroupForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetOwnerGroupForView {
    totalCount: number | undefined;
    items: GetOwnerGroupForView[] | undefined;
}

export class GetOwnerGroupForView implements IGetOwnerGroupForView {
    ownerGroup: OwnerGroupDto | undefined;

    constructor(data?: IGetOwnerGroupForView) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerGroup = data["ownerGroup"] ? OwnerGroupDto.fromJS(data["ownerGroup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetOwnerGroupForView {
        data = typeof data === 'object' ? data : {};
        let result = new GetOwnerGroupForView();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerGroup"] = this.ownerGroup ? this.ownerGroup.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetOwnerGroupForView {
    ownerGroup: OwnerGroupDto | undefined;
}

export class OwnerGroupDto implements IOwnerGroupDto {
    groupCode: string | undefined;
    groupName: string | undefined;
    ownerGroupMembers: OwnerGroupMemberDto[] | undefined;
    id: number | undefined;

    constructor(data?: IOwnerGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupCode = data["groupCode"];
            this.groupName = data["groupName"];
            if (data["ownerGroupMembers"] && data["ownerGroupMembers"].constructor === Array) {
                this.ownerGroupMembers = [];
                for (let item of data["ownerGroupMembers"])
                    this.ownerGroupMembers.push(OwnerGroupMemberDto.fromJS(item));
            }
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OwnerGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new OwnerGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupCode"] = this.groupCode;
        data["groupName"] = this.groupName;
        if (this.ownerGroupMembers && this.ownerGroupMembers.constructor === Array) {
            data["ownerGroupMembers"] = [];
            for (let item of this.ownerGroupMembers)
                data["ownerGroupMembers"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data; 
    }
}

export interface IOwnerGroupDto {
    groupCode: string | undefined;
    groupName: string | undefined;
    ownerGroupMembers: OwnerGroupMemberDto[] | undefined;
    id: number | undefined;
}

export class GetOwnerGroupForEditOutput implements IGetOwnerGroupForEditOutput {
    ownerGroup: CreateOrEditOwnerGroupDto | undefined;

    constructor(data?: IGetOwnerGroupForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerGroup = data["ownerGroup"] ? CreateOrEditOwnerGroupDto.fromJS(data["ownerGroup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetOwnerGroupForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetOwnerGroupForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerGroup"] = this.ownerGroup ? this.ownerGroup.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetOwnerGroupForEditOutput {
    ownerGroup: CreateOrEditOwnerGroupDto | undefined;
}

export class CreateOrEditOwnerGroupDto implements ICreateOrEditOwnerGroupDto {
    groupCode: string;
    groupName: string;
    id: number | undefined;

    constructor(data?: ICreateOrEditOwnerGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.groupCode = data["groupCode"];
            this.groupName = data["groupName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditOwnerGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditOwnerGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["groupCode"] = this.groupCode;
        data["groupName"] = this.groupName;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditOwnerGroupDto {
    groupCode: string;
    groupName: string;
    id: number | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition: EditionSelectDto | undefined;
    additionalPrice: number | undefined;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto | undefined;
    additionalPrice: number | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean | undefined;
    additionalData: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEditionSelectDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean | undefined;
    additionalData: AdditionalData | undefined;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId: number | undefined;
    editionPaymentType: CreatePaymentDtoEditionPaymentType | undefined;
    paymentPeriodType: CreatePaymentDtoPaymentPeriodType | undefined;
    subscriptionPaymentGatewayType: CreatePaymentDtoSubscriptionPaymentGatewayType | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        return data; 
    }
}

export interface ICreatePaymentDto {
    editionId: number | undefined;
    editionPaymentType: CreatePaymentDtoEditionPaymentType | undefined;
    paymentPeriodType: CreatePaymentDtoPaymentPeriodType | undefined;
    subscriptionPaymentGatewayType: CreatePaymentDtoSubscriptionPaymentGatewayType | undefined;
}

export class ExecutePaymentDto implements IExecutePaymentDto {
    gateway: ExecutePaymentDtoGateway | undefined;
    editionPaymentType: ExecutePaymentDtoEditionPaymentType | undefined;
    editionId: number | undefined;
    paymentPeriodType: ExecutePaymentDtoPaymentPeriodType | undefined;
    additionalData: { [key: string] : string; } | undefined;

    constructor(data?: IExecutePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.editionPaymentType = data["editionPaymentType"];
            this.editionId = data["editionId"];
            this.paymentPeriodType = data["paymentPeriodType"];
            if (data["additionalData"]) {
                this.additionalData = {};
                for (let key in data["additionalData"]) {
                    if (data["additionalData"].hasOwnProperty(key))
                        this.additionalData[key] = data["additionalData"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExecutePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExecutePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["editionPaymentType"] = this.editionPaymentType;
        data["editionId"] = this.editionId;
        data["paymentPeriodType"] = this.paymentPeriodType;
        if (this.additionalData) {
            data["additionalData"] = {};
            for (let key in this.additionalData) {
                if (this.additionalData.hasOwnProperty(key))
                    data["additionalData"][key] = this.additionalData[key];
            }
        }
        return data; 
    }
}

export interface IExecutePaymentDto {
    gateway: ExecutePaymentDtoGateway | undefined;
    editionPaymentType: ExecutePaymentDtoEditionPaymentType | undefined;
    editionId: number | undefined;
    paymentPeriodType: ExecutePaymentDtoPaymentPeriodType | undefined;
    additionalData: { [key: string] : string; } | undefined;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number | undefined;
    items: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number | undefined;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number | undefined;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number | undefined;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        return data; 
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword: string;
    newPassword: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileName: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IUpdateProfilePictureInput {
    fileName: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: moment.Moment | undefined;
    paymentPeriodType: TenantLoginInfoDtoPaymentPeriodType | undefined;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: moment.Moment | undefined;
    paymentPeriodType: TenantLoginInfoDtoPaymentPeriodType | undefined;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            if (data["features"]) {
                this.features = {};
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features[key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    features: { [key: string] : boolean; } | undefined;
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data; 
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
            if (data["features"] && data["features"].constructor === Array) {
                this.features = [];
                for (let item of data["features"])
                    this.features.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (this.features && this.features.constructor === Array) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id: number | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDto {
    id: number | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["memberActivities"] && data["memberActivities"].constructor === Array) {
                this.memberActivities = [];
                for (let item of data["memberActivities"])
                    this.memberActivities.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.memberActivities && this.memberActivities.constructor === Array) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class MemberActivity implements IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number | undefined;
    closed: number | undefined;
    rate: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number | undefined;
    closed: number | undefined;
    rate: string | undefined;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (data["dailySales"] && data["dailySales"].constructor === Array) {
                this.dailySales = [];
                for (let item of data["dailySales"])
                    this.dailySales.push(item);
            }
            if (data["profitShares"] && data["profitShares"].constructor === Array) {
                this.profitShares = [];
                for (let item of data["profitShares"])
                    this.profitShares.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (this.dailySales && this.dailySales.constructor === Array) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (this.profitShares && this.profitShares.constructor === Array) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class SalesSummaryData implements ISalesSummaryData {
    period: string | undefined;
    sales: number | undefined;
    profit: number | undefined;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number | undefined;
    profit: number | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["salesSummary"] && data["salesSummary"].constructor === Array) {
                this.salesSummary = [];
                for (let item of data["salesSummary"])
                    this.salesSummary.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.salesSummary && this.salesSummary.constructor === Array) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["stats"] && data["stats"].constructor === Array) {
                this.stats = [];
                for (let item of data["stats"])
                    this.stats.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.stats && this.stats.constructor === Array) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName: string | undefined;
    sales: number | undefined;
    change: number[] | undefined;
    averagePrice: number | undefined;
    totalPrice: number | undefined;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.sales = data["sales"];
            if (data["change"] && data["change"].constructor === Array) {
                this.change = [];
                for (let item of data["change"])
                    this.change.push(item);
            }
            this.averagePrice = data["averagePrice"];
            this.totalPrice = data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (this.change && this.change.constructor === Array) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number | undefined;
    change: number[] | undefined;
    averagePrice: number | undefined;
    totalPrice: number | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: RegisterTenantInputSubscriptionStartType | undefined;
    gateway: RegisterTenantInputGateway | undefined;
    editionId: number | undefined;
    paymentId: string | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.gateway = data["gateway"];
            this.editionId = data["editionId"];
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["gateway"] = this.gateway;
        data["editionId"] = this.editionId;
        data["paymentId"] = this.paymentId;
        return data; 
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: RegisterTenantInputSubscriptionStartType | undefined;
    gateway: RegisterTenantInputGateway | undefined;
    editionId: number | undefined;
    paymentId: string | undefined;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean | undefined;
    isActive: boolean | undefined;
    isEmailConfirmationRequired: boolean | undefined;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }
}

export interface IRegisterTenantOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean | undefined;
    isActive: boolean | undefined;
    isEmailConfirmationRequired: boolean | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
    tenantEditionId: number | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["allFeatures"] && data["allFeatures"].constructor === Array) {
                this.allFeatures = [];
                for (let item of data["allFeatures"])
                    this.allFeatures.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (data["editionsWithFeatures"] && data["editionsWithFeatures"].constructor === Array) {
                this.editionsWithFeatures = [];
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures.push(EditionWithFeaturesDto.fromJS(item));
            }
            this.tenantEditionId = data["tenantEditionId"];
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.allFeatures && this.allFeatures.constructor === Array) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (this.editionsWithFeatures && this.editionsWithFeatures.constructor === Array) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        data["tenantEditionId"] = this.tenantEditionId;
        return data; 
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
    tenantEditionId: number | undefined;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType | undefined;
    textHtmlColor: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : <any>undefined;
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType | undefined;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition: EditionSelectDto | undefined;
    featureValues: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            if (data["featureValues"] && data["featureValues"].constructor === Array) {
                this.featureValues = [];
                for (let item of data["featureValues"])
                    this.featureValues.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (this.featureValues && this.featureValues.constructor === Array) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto | undefined;
    featureValues: NameValueDto[] | undefined;
}

export class IInputType implements IIInputType {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {};
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes[key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string] : any; } | undefined;
    validator: IValueValidator | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: EmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        return data; 
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean | undefined;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean | undefined;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (data["twoFactorAuthProviders"] && data["twoFactorAuthProviders"].constructor === Array) {
                this.twoFactorAuthProviders = [];
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (this.twoFactorAuthProviders && this.twoFactorAuthProviders.constructor === Array) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId: number | undefined;
    provider: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number | undefined;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
    returnUrl: string | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
    returnUrl: string | undefined;
}

export class UiCustomizationSettingsEditDto implements IUiCustomizationSettingsEditDto {
    layout: UiCustomizationLayoutSettingsEditDto | undefined;
    header: UiCustomizationHeaderSettingsEditDto | undefined;
    menu: UiCustomizationMenuSettingsEditDto | undefined;
    footer: UiCustomizationFooterSettingsEditDto | undefined;

    constructor(data?: IUiCustomizationSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layout = data["layout"] ? UiCustomizationLayoutSettingsEditDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? UiCustomizationHeaderSettingsEditDto.fromJS(data["header"]) : <any>undefined;
            this.menu = data["menu"] ? UiCustomizationMenuSettingsEditDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? UiCustomizationFooterSettingsEditDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UiCustomizationSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUiCustomizationSettingsEditDto {
    layout: UiCustomizationLayoutSettingsEditDto | undefined;
    header: UiCustomizationHeaderSettingsEditDto | undefined;
    menu: UiCustomizationMenuSettingsEditDto | undefined;
    footer: UiCustomizationFooterSettingsEditDto | undefined;
}

export class UiCustomizationLayoutSettingsEditDto implements IUiCustomizationLayoutSettingsEditDto {
    layoutType: string | undefined;
    contentSkin: string | undefined;
    theme: string | undefined;

    constructor(data?: IUiCustomizationLayoutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
            this.contentSkin = data["contentSkin"];
            this.theme = data["theme"];
        }
    }

    static fromJS(data: any): UiCustomizationLayoutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationLayoutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        data["contentSkin"] = this.contentSkin;
        data["theme"] = this.theme;
        return data; 
    }
}

export interface IUiCustomizationLayoutSettingsEditDto {
    layoutType: string | undefined;
    contentSkin: string | undefined;
    theme: string | undefined;
}

export class UiCustomizationHeaderSettingsEditDto implements IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader: boolean | undefined;
    desktopMinimizeMode: string | undefined;
    mobileFixedHeader: boolean | undefined;
    dropdownSkinDesktop: string | undefined;
    displaySubmenuArrowDesktop: boolean | undefined;
    dropdownSkin: string | undefined;

    constructor(data?: IUiCustomizationHeaderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.desktopMinimizeMode = data["desktopMinimizeMode"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.dropdownSkinDesktop = data["dropdownSkinDesktop"];
            this.displaySubmenuArrowDesktop = data["displaySubmenuArrowDesktop"];
            this.dropdownSkin = data["dropdownSkin"];
        }
    }

    static fromJS(data: any): UiCustomizationHeaderSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationHeaderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["desktopMinimizeMode"] = this.desktopMinimizeMode;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["dropdownSkinDesktop"] = this.dropdownSkinDesktop;
        data["displaySubmenuArrowDesktop"] = this.displaySubmenuArrowDesktop;
        data["dropdownSkin"] = this.dropdownSkin;
        return data; 
    }
}

export interface IUiCustomizationHeaderSettingsEditDto {
    desktopFixedHeader: boolean | undefined;
    desktopMinimizeMode: string | undefined;
    mobileFixedHeader: boolean | undefined;
    dropdownSkinDesktop: string | undefined;
    displaySubmenuArrowDesktop: boolean | undefined;
    dropdownSkin: string | undefined;
}

export class UiCustomizationMenuSettingsEditDto implements IUiCustomizationMenuSettingsEditDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    allowAsideHiding: boolean | undefined;
    defaultHiddenAside: boolean | undefined;
    submenuToggle: string | undefined;
    dropdownSubmenuSkin: string | undefined;
    dropdownSubmenuArrow: boolean | undefined;

    constructor(data?: IUiCustomizationMenuSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.allowAsideHiding = data["allowAsideHiding"];
            this.defaultHiddenAside = data["defaultHiddenAside"];
            this.submenuToggle = data["submenuToggle"];
            this.dropdownSubmenuSkin = data["dropdownSubmenuSkin"];
            this.dropdownSubmenuArrow = data["dropdownSubmenuArrow"];
        }
    }

    static fromJS(data: any): UiCustomizationMenuSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationMenuSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["allowAsideHiding"] = this.allowAsideHiding;
        data["defaultHiddenAside"] = this.defaultHiddenAside;
        data["submenuToggle"] = this.submenuToggle;
        data["dropdownSubmenuSkin"] = this.dropdownSubmenuSkin;
        data["dropdownSubmenuArrow"] = this.dropdownSubmenuArrow;
        return data; 
    }
}

export interface IUiCustomizationMenuSettingsEditDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    allowAsideHiding: boolean | undefined;
    defaultHiddenAside: boolean | undefined;
    submenuToggle: string | undefined;
    dropdownSubmenuSkin: string | undefined;
    dropdownSubmenuArrow: boolean | undefined;
}

export class UiCustomizationFooterSettingsEditDto implements IUiCustomizationFooterSettingsEditDto {
    fixedFooter: boolean | undefined;

    constructor(data?: IUiCustomizationFooterSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): UiCustomizationFooterSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationFooterSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }
}

export interface IUiCustomizationFooterSettingsEditDto {
    fixedFooter: boolean | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;
}

export class UserListDto implements IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    lastLoginTime: moment.Moment | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserListRoleDto.fromJS(item));
            }
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    lastLoginTime: moment.Moment | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (data["roles"] && data["roles"].constructor === Array) {
                this.roles = [];
                for (let item of data["roles"])
                    this.roles.push(UserRoleDto.fromJS(item));
            }
            if (data["allOrganizationUnits"] && data["allOrganizationUnits"].constructor === Array) {
                this.allOrganizationUnits = [];
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits.push(OrganizationUnitDto.fromJS(item));
            }
            if (data["memberedOrganizationUnits"] && data["memberedOrganizationUnits"].constructor === Array) {
                this.memberedOrganizationUnits = [];
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.roles && this.roles.constructor === Array) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (this.allOrganizationUnits && this.allOrganizationUnits.constructor === Array) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (this.memberedOrganizationUnits && this.memberedOrganizationUnits.constructor === Array) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        return data; 
    }
}

export interface IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["permissions"] && data["permissions"].constructor === Array) {
                this.permissions = [];
                for (let item of data["permissions"])
                    this.permissions.push(FlatPermissionDto.fromJS(item));
            }
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.permissions && this.permissions.constructor === Array) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id: number | undefined;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfInt64 {
    id: number | undefined;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (data["grantedPermissionNames"] && data["grantedPermissionNames"].constructor === Array) {
                this.grantedPermissionNames = [];
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (this.grantedPermissionNames && this.grantedPermissionNames.constructor === Array) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    organizationUnits: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (data["assignedRoleNames"] && data["assignedRoleNames"].constructor === Array) {
                this.assignedRoleNames = [];
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            if (data["organizationUnits"] && data["organizationUnits"].constructor === Array) {
                this.organizationUnits = [];
                for (let item of data["organizationUnits"])
                    this.organizationUnits.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (this.assignedRoleNames && this.assignedRoleNames.constructor === Array) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (this.organizationUnits && this.organizationUnits.constructor === Array) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    organizationUnits: number[] | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    id: number | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.lastLoginTime = data["lastLoginTime"] ? moment(data["lastLoginTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["lastLoginTime"] = this.lastLoginTime ? this.lastLoginTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    lastLoginTime: moment.Moment | undefined;
    id: number | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["latestWebLogLines"] && data["latestWebLogLines"].constructor === Array) {
                this.latestWebLogLines = [];
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.latestWebLogLines && this.latestWebLogLines.constructor === Array) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class ConsignOrderNotifyInput implements IConsignOrderNotifyInput {
    ownerUserId: string;
    ownerUserName: string | undefined;
    storeCode: string;
    orderCode: string;
    erpOrderCode: string | undefined;
    orderType: number | undefined;
    userId: string | undefined;
    userName: string | undefined;
    orderFlag: string | undefined;
    orderSource: number | undefined;
    orderCreateTime: moment.Moment | undefined;
    orderPayTime: moment.Moment | undefined;
    orderExaminationTime: moment.Moment | undefined;
    orderShopCreateTime: moment.Moment | undefined;
    orderAmount: number | undefined;
    discountAmount: number | undefined;
    arAmount: number | undefined;
    gotAmount: number | undefined;
    postfee: number | undefined;
    serviceFee: number | undefined;
    tmsServiceCode: string | undefined;
    tmsServiceName: string | undefined;
    tmsOrderCode: string | undefined;
    prevOrderCode: string | undefined;
    prevErpOrderCode: string | undefined;
    invoiceInfo: string | undefined;
    timeZone: string | undefined;
    currency: string | undefined;
    remark: string | undefined;
    buyerMessage: string | undefined;
    sellerMessage: string | undefined;
    bizType: string | undefined;
    deliverRequirements: DeliverRequirements | undefined;
    operationRequireTime: OperationRequireTime | undefined;
    receiverInfo: ReceiverInfo | undefined;
    uniReceiverInfo: UniReceiverInfo | undefined;
    senderInfo: ConsignOrderNotifyInputSenderInfo | undefined;
    invoiceInfoList: InvoinceItem[] | undefined;
    orderItemList: WmsConsignOrderItem[] | undefined;
    packageRequirements: WmsConsignOrderPackageRequirement[] | undefined;
    dmRequirements: WmsDmRequirement[] | undefined;
    ffServices: string[] | undefined;

    constructor(data?: IConsignOrderNotifyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerUserId = data["ownerUserId"];
            this.ownerUserName = data["ownerUserName"];
            this.storeCode = data["storeCode"];
            this.orderCode = data["orderCode"];
            this.erpOrderCode = data["erpOrderCode"];
            this.orderType = data["orderType"];
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.orderFlag = data["orderFlag"];
            this.orderSource = data["orderSource"];
            this.orderCreateTime = data["orderCreateTime"] ? moment(data["orderCreateTime"].toString()) : <any>undefined;
            this.orderPayTime = data["orderPayTime"] ? moment(data["orderPayTime"].toString()) : <any>undefined;
            this.orderExaminationTime = data["orderExaminationTime"] ? moment(data["orderExaminationTime"].toString()) : <any>undefined;
            this.orderShopCreateTime = data["orderShopCreateTime"] ? moment(data["orderShopCreateTime"].toString()) : <any>undefined;
            this.orderAmount = data["orderAmount"];
            this.discountAmount = data["discountAmount"];
            this.arAmount = data["arAmount"];
            this.gotAmount = data["gotAmount"];
            this.postfee = data["postfee"];
            this.serviceFee = data["serviceFee"];
            this.tmsServiceCode = data["tmsServiceCode"];
            this.tmsServiceName = data["tmsServiceName"];
            this.tmsOrderCode = data["tmsOrderCode"];
            this.prevOrderCode = data["prevOrderCode"];
            this.prevErpOrderCode = data["prevErpOrderCode"];
            this.invoiceInfo = data["invoiceInfo"];
            this.timeZone = data["timeZone"];
            this.currency = data["currency"];
            this.remark = data["remark"];
            this.buyerMessage = data["buyerMessage"];
            this.sellerMessage = data["sellerMessage"];
            this.bizType = data["bizType"];
            this.deliverRequirements = data["deliverRequirements"] ? DeliverRequirements.fromJS(data["deliverRequirements"]) : <any>undefined;
            this.operationRequireTime = data["operationRequireTime"] ? OperationRequireTime.fromJS(data["operationRequireTime"]) : <any>undefined;
            this.receiverInfo = data["receiverInfo"] ? ReceiverInfo.fromJS(data["receiverInfo"]) : <any>undefined;
            this.uniReceiverInfo = data["uniReceiverInfo"] ? UniReceiverInfo.fromJS(data["uniReceiverInfo"]) : <any>undefined;
            this.senderInfo = data["senderInfo"] ? ConsignOrderNotifyInputSenderInfo.fromJS(data["senderInfo"]) : <any>undefined;
            if (data["invoiceInfoList"] && data["invoiceInfoList"].constructor === Array) {
                this.invoiceInfoList = [];
                for (let item of data["invoiceInfoList"])
                    this.invoiceInfoList.push(InvoinceItem.fromJS(item));
            }
            if (data["orderItemList"] && data["orderItemList"].constructor === Array) {
                this.orderItemList = [];
                for (let item of data["orderItemList"])
                    this.orderItemList.push(WmsConsignOrderItem.fromJS(item));
            }
            if (data["packageRequirements"] && data["packageRequirements"].constructor === Array) {
                this.packageRequirements = [];
                for (let item of data["packageRequirements"])
                    this.packageRequirements.push(WmsConsignOrderPackageRequirement.fromJS(item));
            }
            if (data["dmRequirements"] && data["dmRequirements"].constructor === Array) {
                this.dmRequirements = [];
                for (let item of data["dmRequirements"])
                    this.dmRequirements.push(WmsDmRequirement.fromJS(item));
            }
            if (data["ffServices"] && data["ffServices"].constructor === Array) {
                this.ffServices = [];
                for (let item of data["ffServices"])
                    this.ffServices.push(item);
            }
        }
    }

    static fromJS(data: any): ConsignOrderNotifyInput {
        data = typeof data === 'object' ? data : {};
        let result = new ConsignOrderNotifyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerUserId"] = this.ownerUserId;
        data["ownerUserName"] = this.ownerUserName;
        data["storeCode"] = this.storeCode;
        data["orderCode"] = this.orderCode;
        data["erpOrderCode"] = this.erpOrderCode;
        data["orderType"] = this.orderType;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["orderFlag"] = this.orderFlag;
        data["orderSource"] = this.orderSource;
        data["orderCreateTime"] = this.orderCreateTime ? this.orderCreateTime.toISOString() : <any>undefined;
        data["orderPayTime"] = this.orderPayTime ? this.orderPayTime.toISOString() : <any>undefined;
        data["orderExaminationTime"] = this.orderExaminationTime ? this.orderExaminationTime.toISOString() : <any>undefined;
        data["orderShopCreateTime"] = this.orderShopCreateTime ? this.orderShopCreateTime.toISOString() : <any>undefined;
        data["orderAmount"] = this.orderAmount;
        data["discountAmount"] = this.discountAmount;
        data["arAmount"] = this.arAmount;
        data["gotAmount"] = this.gotAmount;
        data["postfee"] = this.postfee;
        data["serviceFee"] = this.serviceFee;
        data["tmsServiceCode"] = this.tmsServiceCode;
        data["tmsServiceName"] = this.tmsServiceName;
        data["tmsOrderCode"] = this.tmsOrderCode;
        data["prevOrderCode"] = this.prevOrderCode;
        data["prevErpOrderCode"] = this.prevErpOrderCode;
        data["invoiceInfo"] = this.invoiceInfo;
        data["timeZone"] = this.timeZone;
        data["currency"] = this.currency;
        data["remark"] = this.remark;
        data["buyerMessage"] = this.buyerMessage;
        data["sellerMessage"] = this.sellerMessage;
        data["bizType"] = this.bizType;
        data["deliverRequirements"] = this.deliverRequirements ? this.deliverRequirements.toJSON() : <any>undefined;
        data["operationRequireTime"] = this.operationRequireTime ? this.operationRequireTime.toJSON() : <any>undefined;
        data["receiverInfo"] = this.receiverInfo ? this.receiverInfo.toJSON() : <any>undefined;
        data["uniReceiverInfo"] = this.uniReceiverInfo ? this.uniReceiverInfo.toJSON() : <any>undefined;
        data["senderInfo"] = this.senderInfo ? this.senderInfo.toJSON() : <any>undefined;
        if (this.invoiceInfoList && this.invoiceInfoList.constructor === Array) {
            data["invoiceInfoList"] = [];
            for (let item of this.invoiceInfoList)
                data["invoiceInfoList"].push(item.toJSON());
        }
        if (this.orderItemList && this.orderItemList.constructor === Array) {
            data["orderItemList"] = [];
            for (let item of this.orderItemList)
                data["orderItemList"].push(item.toJSON());
        }
        if (this.packageRequirements && this.packageRequirements.constructor === Array) {
            data["packageRequirements"] = [];
            for (let item of this.packageRequirements)
                data["packageRequirements"].push(item.toJSON());
        }
        if (this.dmRequirements && this.dmRequirements.constructor === Array) {
            data["dmRequirements"] = [];
            for (let item of this.dmRequirements)
                data["dmRequirements"].push(item.toJSON());
        }
        if (this.ffServices && this.ffServices.constructor === Array) {
            data["ffServices"] = [];
            for (let item of this.ffServices)
                data["ffServices"].push(item);
        }
        return data; 
    }
}

export interface IConsignOrderNotifyInput {
    ownerUserId: string;
    ownerUserName: string | undefined;
    storeCode: string;
    orderCode: string;
    erpOrderCode: string | undefined;
    orderType: number | undefined;
    userId: string | undefined;
    userName: string | undefined;
    orderFlag: string | undefined;
    orderSource: number | undefined;
    orderCreateTime: moment.Moment | undefined;
    orderPayTime: moment.Moment | undefined;
    orderExaminationTime: moment.Moment | undefined;
    orderShopCreateTime: moment.Moment | undefined;
    orderAmount: number | undefined;
    discountAmount: number | undefined;
    arAmount: number | undefined;
    gotAmount: number | undefined;
    postfee: number | undefined;
    serviceFee: number | undefined;
    tmsServiceCode: string | undefined;
    tmsServiceName: string | undefined;
    tmsOrderCode: string | undefined;
    prevOrderCode: string | undefined;
    prevErpOrderCode: string | undefined;
    invoiceInfo: string | undefined;
    timeZone: string | undefined;
    currency: string | undefined;
    remark: string | undefined;
    buyerMessage: string | undefined;
    sellerMessage: string | undefined;
    bizType: string | undefined;
    deliverRequirements: DeliverRequirements | undefined;
    operationRequireTime: OperationRequireTime | undefined;
    receiverInfo: ReceiverInfo | undefined;
    uniReceiverInfo: UniReceiverInfo | undefined;
    senderInfo: ConsignOrderNotifyInputSenderInfo | undefined;
    invoiceInfoList: InvoinceItem[] | undefined;
    orderItemList: WmsConsignOrderItem[] | undefined;
    packageRequirements: WmsConsignOrderPackageRequirement[] | undefined;
    dmRequirements: WmsDmRequirement[] | undefined;
    ffServices: string[] | undefined;
}

export class DeliverRequirements implements IDeliverRequirements {
    scheduleType: number | undefined;
    expressScheduleType: string | undefined;
    scheduleDay: string | undefined;
    scheduleStart: string | undefined;
    scheduleEnd: string | undefined;
    scheduleArriveTime: string | undefined;

    constructor(data?: IDeliverRequirements) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scheduleType = data["scheduleType"];
            this.expressScheduleType = data["expressScheduleType"];
            this.scheduleDay = data["scheduleDay"];
            this.scheduleStart = data["scheduleStart"];
            this.scheduleEnd = data["scheduleEnd"];
            this.scheduleArriveTime = data["scheduleArriveTime"];
        }
    }

    static fromJS(data: any): DeliverRequirements {
        data = typeof data === 'object' ? data : {};
        let result = new DeliverRequirements();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleType"] = this.scheduleType;
        data["expressScheduleType"] = this.expressScheduleType;
        data["scheduleDay"] = this.scheduleDay;
        data["scheduleStart"] = this.scheduleStart;
        data["scheduleEnd"] = this.scheduleEnd;
        data["scheduleArriveTime"] = this.scheduleArriveTime;
        return data; 
    }
}

export interface IDeliverRequirements {
    scheduleType: number | undefined;
    expressScheduleType: string | undefined;
    scheduleDay: string | undefined;
    scheduleStart: string | undefined;
    scheduleEnd: string | undefined;
    scheduleArriveTime: string | undefined;
}

export class OperationRequireTime implements IOperationRequireTime {
    scheduleStockOutTime: string | undefined;

    constructor(data?: IOperationRequireTime) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scheduleStockOutTime = data["scheduleStockOutTime"];
        }
    }

    static fromJS(data: any): OperationRequireTime {
        data = typeof data === 'object' ? data : {};
        let result = new OperationRequireTime();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleStockOutTime"] = this.scheduleStockOutTime;
        return data; 
    }
}

export interface IOperationRequireTime {
    scheduleStockOutTime: string | undefined;
}

export class ReceiverInfo implements IReceiverInfo {
    receiverZipCode: string | undefined;
    receiverCountry: string | undefined;
    receiverProvince: string;
    receiverCity: string;
    receiverArea: string | undefined;
    receiveTown: string | undefined;
    receiverAddress: string | undefined;
    receiverDivisionId: string | undefined;
    receiverName: string;
    receiverNick: string | undefined;
    receiverMobile: string | undefined;
    receiverPhone: string | undefined;
    receiverEmail: string | undefined;

    constructor(data?: IReceiverInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiverZipCode = data["receiverZipCode"];
            this.receiverCountry = data["receiverCountry"];
            this.receiverProvince = data["receiverProvince"];
            this.receiverCity = data["receiverCity"];
            this.receiverArea = data["receiverArea"];
            this.receiveTown = data["receiveTown"];
            this.receiverAddress = data["receiverAddress"];
            this.receiverDivisionId = data["receiverDivisionId"];
            this.receiverName = data["receiverName"];
            this.receiverNick = data["receiverNick"];
            this.receiverMobile = data["receiverMobile"];
            this.receiverPhone = data["receiverPhone"];
            this.receiverEmail = data["receiverEmail"];
        }
    }

    static fromJS(data: any): ReceiverInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ReceiverInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiverZipCode"] = this.receiverZipCode;
        data["receiverCountry"] = this.receiverCountry;
        data["receiverProvince"] = this.receiverProvince;
        data["receiverCity"] = this.receiverCity;
        data["receiverArea"] = this.receiverArea;
        data["receiveTown"] = this.receiveTown;
        data["receiverAddress"] = this.receiverAddress;
        data["receiverDivisionId"] = this.receiverDivisionId;
        data["receiverName"] = this.receiverName;
        data["receiverNick"] = this.receiverNick;
        data["receiverMobile"] = this.receiverMobile;
        data["receiverPhone"] = this.receiverPhone;
        data["receiverEmail"] = this.receiverEmail;
        return data; 
    }
}

export interface IReceiverInfo {
    receiverZipCode: string | undefined;
    receiverCountry: string | undefined;
    receiverProvince: string;
    receiverCity: string;
    receiverArea: string | undefined;
    receiveTown: string | undefined;
    receiverAddress: string | undefined;
    receiverDivisionId: string | undefined;
    receiverName: string;
    receiverNick: string | undefined;
    receiverMobile: string | undefined;
    receiverPhone: string | undefined;
    receiverEmail: string | undefined;
}

export class UniReceiverInfo implements IUniReceiverInfo {
    receiverZipCode: string | undefined;
    receiverCountry: string | undefined;
    receiverProvince: string | undefined;
    receiverCity: string | undefined;
    receiverArea: string | undefined;
    receiveTown: string | undefined;
    receiverAddress: string | undefined;
    receiverDivisionId: string | undefined;
    receiverName: string | undefined;
    receiverNick: string | undefined;
    receiverMobile: string | undefined;
    receiverPhone: string | undefined;
    receiverEmail: string | undefined;

    constructor(data?: IUniReceiverInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiverZipCode = data["receiverZipCode"];
            this.receiverCountry = data["receiverCountry"];
            this.receiverProvince = data["receiverProvince"];
            this.receiverCity = data["receiverCity"];
            this.receiverArea = data["receiverArea"];
            this.receiveTown = data["receiveTown"];
            this.receiverAddress = data["receiverAddress"];
            this.receiverDivisionId = data["receiverDivisionId"];
            this.receiverName = data["receiverName"];
            this.receiverNick = data["receiverNick"];
            this.receiverMobile = data["receiverMobile"];
            this.receiverPhone = data["receiverPhone"];
            this.receiverEmail = data["receiverEmail"];
        }
    }

    static fromJS(data: any): UniReceiverInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UniReceiverInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiverZipCode"] = this.receiverZipCode;
        data["receiverCountry"] = this.receiverCountry;
        data["receiverProvince"] = this.receiverProvince;
        data["receiverCity"] = this.receiverCity;
        data["receiverArea"] = this.receiverArea;
        data["receiveTown"] = this.receiveTown;
        data["receiverAddress"] = this.receiverAddress;
        data["receiverDivisionId"] = this.receiverDivisionId;
        data["receiverName"] = this.receiverName;
        data["receiverNick"] = this.receiverNick;
        data["receiverMobile"] = this.receiverMobile;
        data["receiverPhone"] = this.receiverPhone;
        data["receiverEmail"] = this.receiverEmail;
        return data; 
    }
}

export interface IUniReceiverInfo {
    receiverZipCode: string | undefined;
    receiverCountry: string | undefined;
    receiverProvince: string | undefined;
    receiverCity: string | undefined;
    receiverArea: string | undefined;
    receiveTown: string | undefined;
    receiverAddress: string | undefined;
    receiverDivisionId: string | undefined;
    receiverName: string | undefined;
    receiverNick: string | undefined;
    receiverMobile: string | undefined;
    receiverPhone: string | undefined;
    receiverEmail: string | undefined;
}

export class ConsignOrderNotifyInputSenderInfo implements IConsignOrderNotifyInputSenderInfo {
    senderZipCode: string | undefined;
    senderCountry: string | undefined;
    senderProvince: string | undefined;
    senderCity: string | undefined;
    senderArea: string | undefined;
    senderTown: string | undefined;
    senderAddress: string | undefined;
    senderDivisionId: string | undefined;
    senderName: string | undefined;
    senderMobile: string | undefined;
    senderPhone: string | undefined;
    senderEmail: string | undefined;

    constructor(data?: IConsignOrderNotifyInputSenderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.senderZipCode = data["senderZipCode"];
            this.senderCountry = data["senderCountry"];
            this.senderProvince = data["senderProvince"];
            this.senderCity = data["senderCity"];
            this.senderArea = data["senderArea"];
            this.senderTown = data["senderTown"];
            this.senderAddress = data["senderAddress"];
            this.senderDivisionId = data["senderDivisionId"];
            this.senderName = data["senderName"];
            this.senderMobile = data["senderMobile"];
            this.senderPhone = data["senderPhone"];
            this.senderEmail = data["senderEmail"];
        }
    }

    static fromJS(data: any): ConsignOrderNotifyInputSenderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ConsignOrderNotifyInputSenderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderZipCode"] = this.senderZipCode;
        data["senderCountry"] = this.senderCountry;
        data["senderProvince"] = this.senderProvince;
        data["senderCity"] = this.senderCity;
        data["senderArea"] = this.senderArea;
        data["senderTown"] = this.senderTown;
        data["senderAddress"] = this.senderAddress;
        data["senderDivisionId"] = this.senderDivisionId;
        data["senderName"] = this.senderName;
        data["senderMobile"] = this.senderMobile;
        data["senderPhone"] = this.senderPhone;
        data["senderEmail"] = this.senderEmail;
        return data; 
    }
}

export interface IConsignOrderNotifyInputSenderInfo {
    senderZipCode: string | undefined;
    senderCountry: string | undefined;
    senderProvince: string | undefined;
    senderCity: string | undefined;
    senderArea: string | undefined;
    senderTown: string | undefined;
    senderAddress: string | undefined;
    senderDivisionId: string | undefined;
    senderName: string | undefined;
    senderMobile: string | undefined;
    senderPhone: string | undefined;
    senderEmail: string | undefined;
}

export class InvoinceItem implements IInvoinceItem {
    billType: string | undefined;
    billId: number | undefined;
    billTitle: string | undefined;
    billAccount: string | undefined;
    billContent: string | undefined;
    buyerNo: string | undefined;
    buyerAddrPhone: string | undefined;
    buyerBankAccount: string | undefined;
    detailList: ItemDetail[] | undefined;

    constructor(data?: IInvoinceItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billType = data["billType"];
            this.billId = data["billId"];
            this.billTitle = data["billTitle"];
            this.billAccount = data["billAccount"];
            this.billContent = data["billContent"];
            this.buyerNo = data["buyerNo"];
            this.buyerAddrPhone = data["buyerAddrPhone"];
            this.buyerBankAccount = data["buyerBankAccount"];
            if (data["detailList"] && data["detailList"].constructor === Array) {
                this.detailList = [];
                for (let item of data["detailList"])
                    this.detailList.push(ItemDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InvoinceItem {
        data = typeof data === 'object' ? data : {};
        let result = new InvoinceItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billType"] = this.billType;
        data["billId"] = this.billId;
        data["billTitle"] = this.billTitle;
        data["billAccount"] = this.billAccount;
        data["billContent"] = this.billContent;
        data["buyerNo"] = this.buyerNo;
        data["buyerAddrPhone"] = this.buyerAddrPhone;
        data["buyerBankAccount"] = this.buyerBankAccount;
        if (this.detailList && this.detailList.constructor === Array) {
            data["detailList"] = [];
            for (let item of this.detailList)
                data["detailList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInvoinceItem {
    billType: string | undefined;
    billId: number | undefined;
    billTitle: string | undefined;
    billAccount: string | undefined;
    billContent: string | undefined;
    buyerNo: string | undefined;
    buyerAddrPhone: string | undefined;
    buyerBankAccount: string | undefined;
    detailList: ItemDetail[] | undefined;
}

export class WmsConsignOrderItem implements IWmsConsignOrderItem {
    orderItemId: string;
    orderSourceCode: string | undefined;
    subSourceCode: string | undefined;
    userId: string;
    userName: string;
    ownerUserId: string;
    ownerUserName: string;
    itemId: string;
    itemName: string;
    itemCode: string;
    batchCode: string | undefined;
    purchaseOrderCode: string | undefined;
    produceDate: moment.Moment | undefined;
    dueDate: moment.Moment | undefined;
    inventoryType: number | undefined;
    itemQuantity: number | undefined;
    actualPrice: number | undefined;
    itemPrice: number | undefined;
    taxRate: number | undefined;
    discountAmount: number | undefined;
    itemVersion: number | undefined;
    batchRemark: string | undefined;
    orderItemPackagingScheme: WmsOrderItemPackagingScheme | undefined;

    constructor(data?: IWmsConsignOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderItemId = data["orderItemId"];
            this.orderSourceCode = data["orderSourceCode"];
            this.subSourceCode = data["subSourceCode"];
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.ownerUserId = data["ownerUserId"];
            this.ownerUserName = data["ownerUserName"];
            this.itemId = data["itemId"];
            this.itemName = data["itemName"];
            this.itemCode = data["itemCode"];
            this.batchCode = data["batchCode"];
            this.purchaseOrderCode = data["purchaseOrderCode"];
            this.produceDate = data["produceDate"] ? moment(data["produceDate"].toString()) : <any>undefined;
            this.dueDate = data["dueDate"] ? moment(data["dueDate"].toString()) : <any>undefined;
            this.inventoryType = data["inventoryType"];
            this.itemQuantity = data["itemQuantity"];
            this.actualPrice = data["actualPrice"];
            this.itemPrice = data["itemPrice"];
            this.taxRate = data["taxRate"];
            this.discountAmount = data["discountAmount"];
            this.itemVersion = data["itemVersion"];
            this.batchRemark = data["batchRemark"];
            this.orderItemPackagingScheme = data["orderItemPackagingScheme"] ? WmsOrderItemPackagingScheme.fromJS(data["orderItemPackagingScheme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): WmsConsignOrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new WmsConsignOrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderItemId"] = this.orderItemId;
        data["orderSourceCode"] = this.orderSourceCode;
        data["subSourceCode"] = this.subSourceCode;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["ownerUserId"] = this.ownerUserId;
        data["ownerUserName"] = this.ownerUserName;
        data["itemId"] = this.itemId;
        data["itemName"] = this.itemName;
        data["itemCode"] = this.itemCode;
        data["batchCode"] = this.batchCode;
        data["purchaseOrderCode"] = this.purchaseOrderCode;
        data["produceDate"] = this.produceDate ? this.produceDate.toISOString() : <any>undefined;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["inventoryType"] = this.inventoryType;
        data["itemQuantity"] = this.itemQuantity;
        data["actualPrice"] = this.actualPrice;
        data["itemPrice"] = this.itemPrice;
        data["taxRate"] = this.taxRate;
        data["discountAmount"] = this.discountAmount;
        data["itemVersion"] = this.itemVersion;
        data["batchRemark"] = this.batchRemark;
        data["orderItemPackagingScheme"] = this.orderItemPackagingScheme ? this.orderItemPackagingScheme.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IWmsConsignOrderItem {
    orderItemId: string;
    orderSourceCode: string | undefined;
    subSourceCode: string | undefined;
    userId: string;
    userName: string;
    ownerUserId: string;
    ownerUserName: string;
    itemId: string;
    itemName: string;
    itemCode: string;
    batchCode: string | undefined;
    purchaseOrderCode: string | undefined;
    produceDate: moment.Moment | undefined;
    dueDate: moment.Moment | undefined;
    inventoryType: number | undefined;
    itemQuantity: number | undefined;
    actualPrice: number | undefined;
    itemPrice: number | undefined;
    taxRate: number | undefined;
    discountAmount: number | undefined;
    itemVersion: number | undefined;
    batchRemark: string | undefined;
    orderItemPackagingScheme: WmsOrderItemPackagingScheme | undefined;
}

export class WmsConsignOrderPackageRequirement implements IWmsConsignOrderPackageRequirement {
    materialTypes: string | undefined;
    materialClass: string | undefined;
    materialGroup: string | undefined;
    priority: number | undefined;

    constructor(data?: IWmsConsignOrderPackageRequirement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.materialTypes = data["materialTypes"];
            this.materialClass = data["materialClass"];
            this.materialGroup = data["materialGroup"];
            this.priority = data["priority"];
        }
    }

    static fromJS(data: any): WmsConsignOrderPackageRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new WmsConsignOrderPackageRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialTypes"] = this.materialTypes;
        data["materialClass"] = this.materialClass;
        data["materialGroup"] = this.materialGroup;
        data["priority"] = this.priority;
        return data; 
    }
}

export interface IWmsConsignOrderPackageRequirement {
    materialTypes: string | undefined;
    materialClass: string | undefined;
    materialGroup: string | undefined;
    priority: number | undefined;
}

export class WmsDmRequirement implements IWmsDmRequirement {
    dmId: string | undefined;
    dmQuantity: number | undefined;
    dmOwnerId: string | undefined;

    constructor(data?: IWmsDmRequirement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dmId = data["dmId"];
            this.dmQuantity = data["dmQuantity"];
            this.dmOwnerId = data["dmOwnerId"];
        }
    }

    static fromJS(data: any): WmsDmRequirement {
        data = typeof data === 'object' ? data : {};
        let result = new WmsDmRequirement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dmId"] = this.dmId;
        data["dmQuantity"] = this.dmQuantity;
        data["dmOwnerId"] = this.dmOwnerId;
        return data; 
    }
}

export interface IWmsDmRequirement {
    dmId: string | undefined;
    dmQuantity: number | undefined;
    dmOwnerId: string | undefined;
}

export class ItemDetail implements IItemDetail {
    itemName: string;
    unit: string | undefined;
    price: number | undefined;
    quantity: number | undefined;
    amount: number | undefined;
    pecificModel: string | undefined;
    taxRate: number | undefined;
    taxAmount: number | undefined;
    taxCode: string | undefined;

    constructor(data?: IItemDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemName = data["itemName"];
            this.unit = data["unit"];
            this.price = data["price"];
            this.quantity = data["quantity"];
            this.amount = data["amount"];
            this.pecificModel = data["pecificModel"];
            this.taxRate = data["taxRate"];
            this.taxAmount = data["taxAmount"];
            this.taxCode = data["taxCode"];
        }
    }

    static fromJS(data: any): ItemDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ItemDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemName"] = this.itemName;
        data["unit"] = this.unit;
        data["price"] = this.price;
        data["quantity"] = this.quantity;
        data["amount"] = this.amount;
        data["pecificModel"] = this.pecificModel;
        data["taxRate"] = this.taxRate;
        data["taxAmount"] = this.taxAmount;
        data["taxCode"] = this.taxCode;
        return data; 
    }
}

export interface IItemDetail {
    itemName: string;
    unit: string | undefined;
    price: number | undefined;
    quantity: number | undefined;
    amount: number | undefined;
    pecificModel: string | undefined;
    taxRate: number | undefined;
    taxAmount: number | undefined;
    taxCode: string | undefined;
}

export class WmsOrderItemPackagingScheme implements IWmsOrderItemPackagingScheme {
    specialPackaging: number | undefined;
    packageMaterialScope: number | undefined;
    packageMaterialType: number | undefined;
    packageMaterialGroup: string | undefined;
    packageMaterialClass: string | undefined;
    packageMaterialFallback: number | undefined;
    consumptiveMaterialOwnerId: string | undefined;
    consumptiveMaterialId: number | undefined;
    consumptiveMaterialQuantity: string | undefined;
    packagingPlanCode: string | undefined;
    groupBoxProperty: string | undefined;

    constructor(data?: IWmsOrderItemPackagingScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.specialPackaging = data["specialPackaging"];
            this.packageMaterialScope = data["packageMaterialScope"];
            this.packageMaterialType = data["packageMaterialType"];
            this.packageMaterialGroup = data["packageMaterialGroup"];
            this.packageMaterialClass = data["packageMaterialClass"];
            this.packageMaterialFallback = data["packageMaterialFallback"];
            this.consumptiveMaterialOwnerId = data["consumptiveMaterialOwnerId"];
            this.consumptiveMaterialId = data["consumptiveMaterialId"];
            this.consumptiveMaterialQuantity = data["consumptiveMaterialQuantity"];
            this.packagingPlanCode = data["packagingPlanCode"];
            this.groupBoxProperty = data["groupBoxProperty"];
        }
    }

    static fromJS(data: any): WmsOrderItemPackagingScheme {
        data = typeof data === 'object' ? data : {};
        let result = new WmsOrderItemPackagingScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["specialPackaging"] = this.specialPackaging;
        data["packageMaterialScope"] = this.packageMaterialScope;
        data["packageMaterialType"] = this.packageMaterialType;
        data["packageMaterialGroup"] = this.packageMaterialGroup;
        data["packageMaterialClass"] = this.packageMaterialClass;
        data["packageMaterialFallback"] = this.packageMaterialFallback;
        data["consumptiveMaterialOwnerId"] = this.consumptiveMaterialOwnerId;
        data["consumptiveMaterialId"] = this.consumptiveMaterialId;
        data["consumptiveMaterialQuantity"] = this.consumptiveMaterialQuantity;
        data["packagingPlanCode"] = this.packagingPlanCode;
        data["groupBoxProperty"] = this.groupBoxProperty;
        return data; 
    }
}

export interface IWmsOrderItemPackagingScheme {
    specialPackaging: number | undefined;
    packageMaterialScope: number | undefined;
    packageMaterialType: number | undefined;
    packageMaterialGroup: string | undefined;
    packageMaterialClass: string | undefined;
    packageMaterialFallback: number | undefined;
    consumptiveMaterialOwnerId: string | undefined;
    consumptiveMaterialId: number | undefined;
    consumptiveMaterialQuantity: string | undefined;
    packagingPlanCode: string | undefined;
    groupBoxProperty: string | undefined;
}

export class ConsignOrderNotifyOutput implements IConsignOrderNotifyOutput {
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: IConsignOrderNotifyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): ConsignOrderNotifyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ConsignOrderNotifyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface IConsignOrderNotifyOutput {
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class CnWmsDeliveryorderCreateInput implements ICnWmsDeliveryorderCreateInput {
    deliveryOrder: CnWmsDeliveryorderCreateInputDeliveryOrder | undefined;
    orderLines: CnWmsDeliveryorderCreateInputOrderLine[] | undefined;

    constructor(data?: ICnWmsDeliveryorderCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deliveryOrder = data["deliveryOrder"] ? CnWmsDeliveryorderCreateInputDeliveryOrder.fromJS(data["deliveryOrder"]) : <any>undefined;
            if (data["orderLines"] && data["orderLines"].constructor === Array) {
                this.orderLines = [];
                for (let item of data["orderLines"])
                    this.orderLines.push(CnWmsDeliveryorderCreateInputOrderLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CnWmsDeliveryorderCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsDeliveryorderCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryOrder"] = this.deliveryOrder ? this.deliveryOrder.toJSON() : <any>undefined;
        if (this.orderLines && this.orderLines.constructor === Array) {
            data["orderLines"] = [];
            for (let item of this.orderLines)
                data["orderLines"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICnWmsDeliveryorderCreateInput {
    deliveryOrder: CnWmsDeliveryorderCreateInputDeliveryOrder | undefined;
    orderLines: CnWmsDeliveryorderCreateInputOrderLine[] | undefined;
}

export class CnWmsDeliveryorderCreateInputDeliveryOrder implements ICnWmsDeliveryorderCreateInputDeliveryOrder {
    deliveryOrderCode: string;
    cnOrderCode: string;
    ownerCode: string;
    preDeliveryOrderCode: string | undefined;
    preCnOrderCode: string | undefined;
    orderType: string;
    warehouseCode: string;
    orderFlag: string | undefined;
    sourcePlatformCode: string | undefined;
    sourcePlatformName: string | undefined;
    createTime: moment.Moment | undefined;
    placeOrderTime: moment.Moment | undefined;
    payTime: moment.Moment | undefined;
    payNo: string | undefined;
    operatorCode: string | undefined;
    operatorName: string | undefined;
    operateTime: moment.Moment | undefined;
    shopNick: string;
    sellerNick: string | undefined;
    buyerNick: string | undefined;
    totalAmount: string | undefined;
    itemAmount: string | undefined;
    discountAmount: string | undefined;
    freight: string | undefined;
    arAmount: string | undefined;
    gotAmount: string | undefined;
    logisticsCode: string;
    logisticsName: string | undefined;
    expressCode: string | undefined;
    logisticsAreaCode: string | undefined;
    deliveryRequirements: CnWmsDeliveryorderCreateInputDeliveryRequirements | undefined;
    senderInfo: CnWmsDeliveryorderCreateInputDeliveryOrderSenderInfo | undefined;
    receiverInfo: CnWmsDeliveryorderCreateInputDeliveryOrderReceiverInfo | undefined;
    isUrgency: string | undefined;
    invoiceFlag: string | undefined;
    invoices: CnWmsDeliveryorderCreateInputDeliveryOrderInvoice[] | undefined;
    buyerMessage: string | undefined;
    sellerMessage: string | undefined;
    remark: string | undefined;
    serviceCode: string | undefined;

    constructor(data?: ICnWmsDeliveryorderCreateInputDeliveryOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deliveryOrderCode = data["deliveryOrderCode"];
            this.cnOrderCode = data["cnOrderCode"];
            this.ownerCode = data["ownerCode"];
            this.preDeliveryOrderCode = data["preDeliveryOrderCode"];
            this.preCnOrderCode = data["preCnOrderCode"];
            this.orderType = data["orderType"];
            this.warehouseCode = data["warehouseCode"];
            this.orderFlag = data["orderFlag"];
            this.sourcePlatformCode = data["sourcePlatformCode"];
            this.sourcePlatformName = data["sourcePlatformName"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.placeOrderTime = data["placeOrderTime"] ? moment(data["placeOrderTime"].toString()) : <any>undefined;
            this.payTime = data["payTime"] ? moment(data["payTime"].toString()) : <any>undefined;
            this.payNo = data["payNo"];
            this.operatorCode = data["operatorCode"];
            this.operatorName = data["operatorName"];
            this.operateTime = data["operateTime"] ? moment(data["operateTime"].toString()) : <any>undefined;
            this.shopNick = data["shopNick"];
            this.sellerNick = data["sellerNick"];
            this.buyerNick = data["buyerNick"];
            this.totalAmount = data["totalAmount"];
            this.itemAmount = data["itemAmount"];
            this.discountAmount = data["discountAmount"];
            this.freight = data["freight"];
            this.arAmount = data["arAmount"];
            this.gotAmount = data["gotAmount"];
            this.logisticsCode = data["logisticsCode"];
            this.logisticsName = data["logisticsName"];
            this.expressCode = data["expressCode"];
            this.logisticsAreaCode = data["logisticsAreaCode"];
            this.deliveryRequirements = data["deliveryRequirements"] ? CnWmsDeliveryorderCreateInputDeliveryRequirements.fromJS(data["deliveryRequirements"]) : <any>undefined;
            this.senderInfo = data["senderInfo"] ? CnWmsDeliveryorderCreateInputDeliveryOrderSenderInfo.fromJS(data["senderInfo"]) : <any>undefined;
            this.receiverInfo = data["receiverInfo"] ? CnWmsDeliveryorderCreateInputDeliveryOrderReceiverInfo.fromJS(data["receiverInfo"]) : <any>undefined;
            this.isUrgency = data["isUrgency"];
            this.invoiceFlag = data["invoiceFlag"];
            if (data["invoices"] && data["invoices"].constructor === Array) {
                this.invoices = [];
                for (let item of data["invoices"])
                    this.invoices.push(CnWmsDeliveryorderCreateInputDeliveryOrderInvoice.fromJS(item));
            }
            this.buyerMessage = data["buyerMessage"];
            this.sellerMessage = data["sellerMessage"];
            this.remark = data["remark"];
            this.serviceCode = data["serviceCode"];
        }
    }

    static fromJS(data: any): CnWmsDeliveryorderCreateInputDeliveryOrder {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsDeliveryorderCreateInputDeliveryOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryOrderCode"] = this.deliveryOrderCode;
        data["cnOrderCode"] = this.cnOrderCode;
        data["ownerCode"] = this.ownerCode;
        data["preDeliveryOrderCode"] = this.preDeliveryOrderCode;
        data["preCnOrderCode"] = this.preCnOrderCode;
        data["orderType"] = this.orderType;
        data["warehouseCode"] = this.warehouseCode;
        data["orderFlag"] = this.orderFlag;
        data["sourcePlatformCode"] = this.sourcePlatformCode;
        data["sourcePlatformName"] = this.sourcePlatformName;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["placeOrderTime"] = this.placeOrderTime ? this.placeOrderTime.toISOString() : <any>undefined;
        data["payTime"] = this.payTime ? this.payTime.toISOString() : <any>undefined;
        data["payNo"] = this.payNo;
        data["operatorCode"] = this.operatorCode;
        data["operatorName"] = this.operatorName;
        data["operateTime"] = this.operateTime ? this.operateTime.toISOString() : <any>undefined;
        data["shopNick"] = this.shopNick;
        data["sellerNick"] = this.sellerNick;
        data["buyerNick"] = this.buyerNick;
        data["totalAmount"] = this.totalAmount;
        data["itemAmount"] = this.itemAmount;
        data["discountAmount"] = this.discountAmount;
        data["freight"] = this.freight;
        data["arAmount"] = this.arAmount;
        data["gotAmount"] = this.gotAmount;
        data["logisticsCode"] = this.logisticsCode;
        data["logisticsName"] = this.logisticsName;
        data["expressCode"] = this.expressCode;
        data["logisticsAreaCode"] = this.logisticsAreaCode;
        data["deliveryRequirements"] = this.deliveryRequirements ? this.deliveryRequirements.toJSON() : <any>undefined;
        data["senderInfo"] = this.senderInfo ? this.senderInfo.toJSON() : <any>undefined;
        data["receiverInfo"] = this.receiverInfo ? this.receiverInfo.toJSON() : <any>undefined;
        data["isUrgency"] = this.isUrgency;
        data["invoiceFlag"] = this.invoiceFlag;
        if (this.invoices && this.invoices.constructor === Array) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        data["buyerMessage"] = this.buyerMessage;
        data["sellerMessage"] = this.sellerMessage;
        data["remark"] = this.remark;
        data["serviceCode"] = this.serviceCode;
        return data; 
    }
}

export interface ICnWmsDeliveryorderCreateInputDeliveryOrder {
    deliveryOrderCode: string;
    cnOrderCode: string;
    ownerCode: string;
    preDeliveryOrderCode: string | undefined;
    preCnOrderCode: string | undefined;
    orderType: string;
    warehouseCode: string;
    orderFlag: string | undefined;
    sourcePlatformCode: string | undefined;
    sourcePlatformName: string | undefined;
    createTime: moment.Moment | undefined;
    placeOrderTime: moment.Moment | undefined;
    payTime: moment.Moment | undefined;
    payNo: string | undefined;
    operatorCode: string | undefined;
    operatorName: string | undefined;
    operateTime: moment.Moment | undefined;
    shopNick: string;
    sellerNick: string | undefined;
    buyerNick: string | undefined;
    totalAmount: string | undefined;
    itemAmount: string | undefined;
    discountAmount: string | undefined;
    freight: string | undefined;
    arAmount: string | undefined;
    gotAmount: string | undefined;
    logisticsCode: string;
    logisticsName: string | undefined;
    expressCode: string | undefined;
    logisticsAreaCode: string | undefined;
    deliveryRequirements: CnWmsDeliveryorderCreateInputDeliveryRequirements | undefined;
    senderInfo: CnWmsDeliveryorderCreateInputDeliveryOrderSenderInfo | undefined;
    receiverInfo: CnWmsDeliveryorderCreateInputDeliveryOrderReceiverInfo | undefined;
    isUrgency: string | undefined;
    invoiceFlag: string | undefined;
    invoices: CnWmsDeliveryorderCreateInputDeliveryOrderInvoice[] | undefined;
    buyerMessage: string | undefined;
    sellerMessage: string | undefined;
    remark: string | undefined;
    serviceCode: string | undefined;
}

export class CnWmsDeliveryorderCreateInputOrderLine implements ICnWmsDeliveryorderCreateInputOrderLine {
    orderLineNo: string;
    sourceOrderCode: string | undefined;
    subSourceOrderCode: string | undefined;
    payNo: string | undefined;
    ownerCode: string;
    itemCode: string;
    inventoryType: string | undefined;
    itemName: string | undefined;
    extCode: string | undefined;
    retailPrice: string | undefined;
    actualPrice: string | undefined;
    discountAmount: string | undefined;
    batchCode: string | undefined;
    productDate: moment.Moment | undefined;
    expireDate: moment.Moment | undefined;
    produceCode: string | undefined;
    planQty: number | undefined;

    constructor(data?: ICnWmsDeliveryorderCreateInputOrderLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderLineNo = data["orderLineNo"];
            this.sourceOrderCode = data["sourceOrderCode"];
            this.subSourceOrderCode = data["subSourceOrderCode"];
            this.payNo = data["payNo"];
            this.ownerCode = data["ownerCode"];
            this.itemCode = data["itemCode"];
            this.inventoryType = data["inventoryType"];
            this.itemName = data["itemName"];
            this.extCode = data["extCode"];
            this.retailPrice = data["retailPrice"];
            this.actualPrice = data["actualPrice"];
            this.discountAmount = data["discountAmount"];
            this.batchCode = data["batchCode"];
            this.productDate = data["productDate"] ? moment(data["productDate"].toString()) : <any>undefined;
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.produceCode = data["produceCode"];
            this.planQty = data["planQty"];
        }
    }

    static fromJS(data: any): CnWmsDeliveryorderCreateInputOrderLine {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsDeliveryorderCreateInputOrderLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderLineNo"] = this.orderLineNo;
        data["sourceOrderCode"] = this.sourceOrderCode;
        data["subSourceOrderCode"] = this.subSourceOrderCode;
        data["payNo"] = this.payNo;
        data["ownerCode"] = this.ownerCode;
        data["itemCode"] = this.itemCode;
        data["inventoryType"] = this.inventoryType;
        data["itemName"] = this.itemName;
        data["extCode"] = this.extCode;
        data["retailPrice"] = this.retailPrice;
        data["actualPrice"] = this.actualPrice;
        data["discountAmount"] = this.discountAmount;
        data["batchCode"] = this.batchCode;
        data["productDate"] = this.productDate ? this.productDate.toISOString() : <any>undefined;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["produceCode"] = this.produceCode;
        data["planQty"] = this.planQty;
        return data; 
    }
}

export interface ICnWmsDeliveryorderCreateInputOrderLine {
    orderLineNo: string;
    sourceOrderCode: string | undefined;
    subSourceOrderCode: string | undefined;
    payNo: string | undefined;
    ownerCode: string;
    itemCode: string;
    inventoryType: string | undefined;
    itemName: string | undefined;
    extCode: string | undefined;
    retailPrice: string | undefined;
    actualPrice: string | undefined;
    discountAmount: string | undefined;
    batchCode: string | undefined;
    productDate: moment.Moment | undefined;
    expireDate: moment.Moment | undefined;
    produceCode: string | undefined;
    planQty: number | undefined;
}

export class CnWmsDeliveryorderCreateInputDeliveryRequirements implements ICnWmsDeliveryorderCreateInputDeliveryRequirements {
    scheduleType: number | undefined;
    scheduleDay: string | undefined;
    scheduleStartTime: string | undefined;
    scheduleEndTime: string | undefined;
    deliveryType: string | undefined;

    constructor(data?: ICnWmsDeliveryorderCreateInputDeliveryRequirements) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.scheduleType = data["scheduleType"];
            this.scheduleDay = data["scheduleDay"];
            this.scheduleStartTime = data["scheduleStartTime"];
            this.scheduleEndTime = data["scheduleEndTime"];
            this.deliveryType = data["deliveryType"];
        }
    }

    static fromJS(data: any): CnWmsDeliveryorderCreateInputDeliveryRequirements {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsDeliveryorderCreateInputDeliveryRequirements();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scheduleType"] = this.scheduleType;
        data["scheduleDay"] = this.scheduleDay;
        data["scheduleStartTime"] = this.scheduleStartTime;
        data["scheduleEndTime"] = this.scheduleEndTime;
        data["deliveryType"] = this.deliveryType;
        return data; 
    }
}

export interface ICnWmsDeliveryorderCreateInputDeliveryRequirements {
    scheduleType: number | undefined;
    scheduleDay: string | undefined;
    scheduleStartTime: string | undefined;
    scheduleEndTime: string | undefined;
    deliveryType: string | undefined;
}

export class CnWmsDeliveryorderCreateInputDeliveryOrderSenderInfo implements ICnWmsDeliveryorderCreateInputDeliveryOrderSenderInfo {
    company: string | undefined;
    name: string | undefined;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string | undefined;

    constructor(data?: ICnWmsDeliveryorderCreateInputDeliveryOrderSenderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.company = data["company"];
            this.name = data["name"];
            this.zipCode = data["zipCode"];
            this.tel = data["tel"];
            this.mobile = data["mobile"];
            this.idType = data["idType"];
            this.idNumber = data["idNumber"];
            this.email = data["email"];
            this.countryCode = data["countryCode"];
            this.province = data["province"];
            this.city = data["city"];
            this.area = data["area"];
            this.town = data["town"];
            this.detailAddress = data["detailAddress"];
        }
    }

    static fromJS(data: any): CnWmsDeliveryorderCreateInputDeliveryOrderSenderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsDeliveryorderCreateInputDeliveryOrderSenderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["name"] = this.name;
        data["zipCode"] = this.zipCode;
        data["tel"] = this.tel;
        data["mobile"] = this.mobile;
        data["idType"] = this.idType;
        data["idNumber"] = this.idNumber;
        data["email"] = this.email;
        data["countryCode"] = this.countryCode;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["town"] = this.town;
        data["detailAddress"] = this.detailAddress;
        return data; 
    }
}

export interface ICnWmsDeliveryorderCreateInputDeliveryOrderSenderInfo {
    company: string | undefined;
    name: string | undefined;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string | undefined;
}

export class CnWmsDeliveryorderCreateInputDeliveryOrderReceiverInfo implements ICnWmsDeliveryorderCreateInputDeliveryOrderReceiverInfo {
    company: string | undefined;
    name: string;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string;
    city: string;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string;

    constructor(data?: ICnWmsDeliveryorderCreateInputDeliveryOrderReceiverInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.company = data["company"];
            this.name = data["name"];
            this.zipCode = data["zipCode"];
            this.tel = data["tel"];
            this.mobile = data["mobile"];
            this.idType = data["idType"];
            this.idNumber = data["idNumber"];
            this.email = data["email"];
            this.countryCode = data["countryCode"];
            this.province = data["province"];
            this.city = data["city"];
            this.area = data["area"];
            this.town = data["town"];
            this.detailAddress = data["detailAddress"];
        }
    }

    static fromJS(data: any): CnWmsDeliveryorderCreateInputDeliveryOrderReceiverInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsDeliveryorderCreateInputDeliveryOrderReceiverInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["name"] = this.name;
        data["zipCode"] = this.zipCode;
        data["tel"] = this.tel;
        data["mobile"] = this.mobile;
        data["idType"] = this.idType;
        data["idNumber"] = this.idNumber;
        data["email"] = this.email;
        data["countryCode"] = this.countryCode;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["town"] = this.town;
        data["detailAddress"] = this.detailAddress;
        return data; 
    }
}

export interface ICnWmsDeliveryorderCreateInputDeliveryOrderReceiverInfo {
    company: string | undefined;
    name: string;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string;
    city: string;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string;
}

export class CnWmsDeliveryorderCreateInputDeliveryOrderInvoice implements ICnWmsDeliveryorderCreateInputDeliveryOrderInvoice {
    type: string | undefined;
    header: string | undefined;
    amount: string | undefined;
    content: string | undefined;
    detail: CnWmsDeliveryorderCreateInputInvoiceDetail | undefined;
    taxNumber: string | undefined;

    constructor(data?: ICnWmsDeliveryorderCreateInputDeliveryOrderInvoice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.header = data["header"];
            this.amount = data["amount"];
            this.content = data["content"];
            this.detail = data["detail"] ? CnWmsDeliveryorderCreateInputInvoiceDetail.fromJS(data["detail"]) : <any>undefined;
            this.taxNumber = data["taxNumber"];
        }
    }

    static fromJS(data: any): CnWmsDeliveryorderCreateInputDeliveryOrderInvoice {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsDeliveryorderCreateInputDeliveryOrderInvoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["header"] = this.header;
        data["amount"] = this.amount;
        data["content"] = this.content;
        data["detail"] = this.detail ? this.detail.toJSON() : <any>undefined;
        data["taxNumber"] = this.taxNumber;
        return data; 
    }
}

export interface ICnWmsDeliveryorderCreateInputDeliveryOrderInvoice {
    type: string | undefined;
    header: string | undefined;
    amount: string | undefined;
    content: string | undefined;
    detail: CnWmsDeliveryorderCreateInputInvoiceDetail | undefined;
    taxNumber: string | undefined;
}

export class CnWmsDeliveryorderCreateInputInvoiceDetail implements ICnWmsDeliveryorderCreateInputInvoiceDetail {
    items: CnWmsDeliveryorderCreateInputInvoiceDetailItem[] | undefined;

    constructor(data?: ICnWmsDeliveryorderCreateInputInvoiceDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CnWmsDeliveryorderCreateInputInvoiceDetailItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CnWmsDeliveryorderCreateInputInvoiceDetail {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsDeliveryorderCreateInputInvoiceDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICnWmsDeliveryorderCreateInputInvoiceDetail {
    items: CnWmsDeliveryorderCreateInputInvoiceDetailItem[] | undefined;
}

export class CnWmsDeliveryorderCreateInputInvoiceDetailItem implements ICnWmsDeliveryorderCreateInputInvoiceDetailItem {
    itemName: string | undefined;
    unit: string | undefined;
    price: string | undefined;
    amount: string | undefined;
    quantity: number | undefined;

    constructor(data?: ICnWmsDeliveryorderCreateInputInvoiceDetailItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemName = data["itemName"];
            this.unit = data["unit"];
            this.price = data["price"];
            this.amount = data["amount"];
            this.quantity = data["quantity"];
        }
    }

    static fromJS(data: any): CnWmsDeliveryorderCreateInputInvoiceDetailItem {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsDeliveryorderCreateInputInvoiceDetailItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemName"] = this.itemName;
        data["unit"] = this.unit;
        data["price"] = this.price;
        data["amount"] = this.amount;
        data["quantity"] = this.quantity;
        return data; 
    }
}

export interface ICnWmsDeliveryorderCreateInputInvoiceDetailItem {
    itemName: string | undefined;
    unit: string | undefined;
    price: string | undefined;
    amount: string | undefined;
    quantity: number | undefined;
}

export class CnWmsDeliveryorderCreateOutput implements ICnWmsDeliveryorderCreateOutput {
    code: string | undefined;
    _success: boolean | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: ICnWmsDeliveryorderCreateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this._success = data["_success"];
            this.flag = data["flag"];
            this.message = data["message"];
            this.needRetry = data["needRetry"];
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): CnWmsDeliveryorderCreateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsDeliveryorderCreateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["_success"] = this._success;
        data["flag"] = this.flag;
        data["message"] = this.message;
        data["needRetry"] = this.needRetry;
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface ICnWmsDeliveryorderCreateOutput {
    code: string | undefined;
    _success: boolean | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class CnWmsEntryorderCreateInput implements ICnWmsEntryorderCreateInput {
    entryOrder: CnWmsEntryorderCreateInputEntryOrder | undefined;
    orderLines: CnWmsEntryorderCreateInputOrderLine[] | undefined;

    constructor(data?: ICnWmsEntryorderCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entryOrder = data["entryOrder"] ? CnWmsEntryorderCreateInputEntryOrder.fromJS(data["entryOrder"]) : <any>undefined;
            if (data["orderLines"] && data["orderLines"].constructor === Array) {
                this.orderLines = [];
                for (let item of data["orderLines"])
                    this.orderLines.push(CnWmsEntryorderCreateInputOrderLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CnWmsEntryorderCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsEntryorderCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entryOrder"] = this.entryOrder ? this.entryOrder.toJSON() : <any>undefined;
        if (this.orderLines && this.orderLines.constructor === Array) {
            data["orderLines"] = [];
            for (let item of this.orderLines)
                data["orderLines"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICnWmsEntryorderCreateInput {
    entryOrder: CnWmsEntryorderCreateInputEntryOrder | undefined;
    orderLines: CnWmsEntryorderCreateInputOrderLine[] | undefined;
}

export class CnWmsEntryorderCreateInputEntryOrder implements ICnWmsEntryorderCreateInputEntryOrder {
    entryOrderCode: string;
    cnOrderCode: string;
    ownerCode: string;
    purchaseOrderCode: string | undefined;
    warehouseCode: string;
    orderCreateTime: moment.Moment | undefined;
    orderType: string | undefined;
    expectStartTime: moment.Moment | undefined;
    expectEndTime: moment.Moment | undefined;
    logisticsCode: string | undefined;
    logisticsName: string | undefined;
    expressCode: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    operatorCode: string | undefined;
    operatorName: string | undefined;
    operateTime: moment.Moment | undefined;
    remark: string | undefined;
    senderInfo: CnWmsEntryorderCreateInputEntryOrderSenderInfo | undefined;
    receiverInfo: CnWmsEntryorderCreateInputEntryOrderReceiverInfo | undefined;

    constructor(data?: ICnWmsEntryorderCreateInputEntryOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entryOrderCode = data["entryOrderCode"];
            this.cnOrderCode = data["cnOrderCode"];
            this.ownerCode = data["ownerCode"];
            this.purchaseOrderCode = data["purchaseOrderCode"];
            this.warehouseCode = data["warehouseCode"];
            this.orderCreateTime = data["orderCreateTime"] ? moment(data["orderCreateTime"].toString()) : <any>undefined;
            this.orderType = data["orderType"];
            this.expectStartTime = data["expectStartTime"] ? moment(data["expectStartTime"].toString()) : <any>undefined;
            this.expectEndTime = data["expectEndTime"] ? moment(data["expectEndTime"].toString()) : <any>undefined;
            this.logisticsCode = data["logisticsCode"];
            this.logisticsName = data["logisticsName"];
            this.expressCode = data["expressCode"];
            this.supplierCode = data["supplierCode"];
            this.supplierName = data["supplierName"];
            this.operatorCode = data["operatorCode"];
            this.operatorName = data["operatorName"];
            this.operateTime = data["operateTime"] ? moment(data["operateTime"].toString()) : <any>undefined;
            this.remark = data["remark"];
            this.senderInfo = data["senderInfo"] ? CnWmsEntryorderCreateInputEntryOrderSenderInfo.fromJS(data["senderInfo"]) : <any>undefined;
            this.receiverInfo = data["receiverInfo"] ? CnWmsEntryorderCreateInputEntryOrderReceiverInfo.fromJS(data["receiverInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CnWmsEntryorderCreateInputEntryOrder {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsEntryorderCreateInputEntryOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entryOrderCode"] = this.entryOrderCode;
        data["cnOrderCode"] = this.cnOrderCode;
        data["ownerCode"] = this.ownerCode;
        data["purchaseOrderCode"] = this.purchaseOrderCode;
        data["warehouseCode"] = this.warehouseCode;
        data["orderCreateTime"] = this.orderCreateTime ? this.orderCreateTime.toISOString() : <any>undefined;
        data["orderType"] = this.orderType;
        data["expectStartTime"] = this.expectStartTime ? this.expectStartTime.toISOString() : <any>undefined;
        data["expectEndTime"] = this.expectEndTime ? this.expectEndTime.toISOString() : <any>undefined;
        data["logisticsCode"] = this.logisticsCode;
        data["logisticsName"] = this.logisticsName;
        data["expressCode"] = this.expressCode;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["operatorCode"] = this.operatorCode;
        data["operatorName"] = this.operatorName;
        data["operateTime"] = this.operateTime ? this.operateTime.toISOString() : <any>undefined;
        data["remark"] = this.remark;
        data["senderInfo"] = this.senderInfo ? this.senderInfo.toJSON() : <any>undefined;
        data["receiverInfo"] = this.receiverInfo ? this.receiverInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICnWmsEntryorderCreateInputEntryOrder {
    entryOrderCode: string;
    cnOrderCode: string;
    ownerCode: string;
    purchaseOrderCode: string | undefined;
    warehouseCode: string;
    orderCreateTime: moment.Moment | undefined;
    orderType: string | undefined;
    expectStartTime: moment.Moment | undefined;
    expectEndTime: moment.Moment | undefined;
    logisticsCode: string | undefined;
    logisticsName: string | undefined;
    expressCode: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    operatorCode: string | undefined;
    operatorName: string | undefined;
    operateTime: moment.Moment | undefined;
    remark: string | undefined;
    senderInfo: CnWmsEntryorderCreateInputEntryOrderSenderInfo | undefined;
    receiverInfo: CnWmsEntryorderCreateInputEntryOrderReceiverInfo | undefined;
}

export class CnWmsEntryorderCreateInputOrderLine implements ICnWmsEntryorderCreateInputOrderLine {
    orderLineNo: string;
    ownerCode: string;
    itemCode: string;
    itemName: string | undefined;
    planQty: number | undefined;
    purchasePrice: string | undefined;
    retailPrice: string | undefined;
    inventoryType: string | undefined;
    productDate: string | undefined;
    expireDate: string | undefined;
    produceCode: string | undefined;
    batchCode: string | undefined;

    constructor(data?: ICnWmsEntryorderCreateInputOrderLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderLineNo = data["orderLineNo"];
            this.ownerCode = data["ownerCode"];
            this.itemCode = data["itemCode"];
            this.itemName = data["itemName"];
            this.planQty = data["planQty"];
            this.purchasePrice = data["purchasePrice"];
            this.retailPrice = data["retailPrice"];
            this.inventoryType = data["inventoryType"];
            this.productDate = data["productDate"];
            this.expireDate = data["expireDate"];
            this.produceCode = data["produceCode"];
            this.batchCode = data["batchCode"];
        }
    }

    static fromJS(data: any): CnWmsEntryorderCreateInputOrderLine {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsEntryorderCreateInputOrderLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderLineNo"] = this.orderLineNo;
        data["ownerCode"] = this.ownerCode;
        data["itemCode"] = this.itemCode;
        data["itemName"] = this.itemName;
        data["planQty"] = this.planQty;
        data["purchasePrice"] = this.purchasePrice;
        data["retailPrice"] = this.retailPrice;
        data["inventoryType"] = this.inventoryType;
        data["productDate"] = this.productDate;
        data["expireDate"] = this.expireDate;
        data["produceCode"] = this.produceCode;
        data["batchCode"] = this.batchCode;
        return data; 
    }
}

export interface ICnWmsEntryorderCreateInputOrderLine {
    orderLineNo: string;
    ownerCode: string;
    itemCode: string;
    itemName: string | undefined;
    planQty: number | undefined;
    purchasePrice: string | undefined;
    retailPrice: string | undefined;
    inventoryType: string | undefined;
    productDate: string | undefined;
    expireDate: string | undefined;
    produceCode: string | undefined;
    batchCode: string | undefined;
}

export class CnWmsEntryorderCreateInputEntryOrderSenderInfo implements ICnWmsEntryorderCreateInputEntryOrderSenderInfo {
    company: string | undefined;
    name: string | undefined;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string | undefined;

    constructor(data?: ICnWmsEntryorderCreateInputEntryOrderSenderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.company = data["company"];
            this.name = data["name"];
            this.zipCode = data["zipCode"];
            this.tel = data["tel"];
            this.mobile = data["mobile"];
            this.idType = data["idType"];
            this.idNumber = data["idNumber"];
            this.email = data["email"];
            this.countryCode = data["countryCode"];
            this.province = data["province"];
            this.city = data["city"];
            this.area = data["area"];
            this.town = data["town"];
            this.detailAddress = data["detailAddress"];
        }
    }

    static fromJS(data: any): CnWmsEntryorderCreateInputEntryOrderSenderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsEntryorderCreateInputEntryOrderSenderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["name"] = this.name;
        data["zipCode"] = this.zipCode;
        data["tel"] = this.tel;
        data["mobile"] = this.mobile;
        data["idType"] = this.idType;
        data["idNumber"] = this.idNumber;
        data["email"] = this.email;
        data["countryCode"] = this.countryCode;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["town"] = this.town;
        data["detailAddress"] = this.detailAddress;
        return data; 
    }
}

export interface ICnWmsEntryorderCreateInputEntryOrderSenderInfo {
    company: string | undefined;
    name: string | undefined;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string | undefined;
}

export class CnWmsEntryorderCreateInputEntryOrderReceiverInfo implements ICnWmsEntryorderCreateInputEntryOrderReceiverInfo {
    company: string | undefined;
    name: string | undefined;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string | undefined;

    constructor(data?: ICnWmsEntryorderCreateInputEntryOrderReceiverInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.company = data["company"];
            this.name = data["name"];
            this.zipCode = data["zipCode"];
            this.tel = data["tel"];
            this.mobile = data["mobile"];
            this.idType = data["idType"];
            this.idNumber = data["idNumber"];
            this.email = data["email"];
            this.countryCode = data["countryCode"];
            this.province = data["province"];
            this.city = data["city"];
            this.area = data["area"];
            this.town = data["town"];
            this.detailAddress = data["detailAddress"];
        }
    }

    static fromJS(data: any): CnWmsEntryorderCreateInputEntryOrderReceiverInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsEntryorderCreateInputEntryOrderReceiverInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["name"] = this.name;
        data["zipCode"] = this.zipCode;
        data["tel"] = this.tel;
        data["mobile"] = this.mobile;
        data["idType"] = this.idType;
        data["idNumber"] = this.idNumber;
        data["email"] = this.email;
        data["countryCode"] = this.countryCode;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["town"] = this.town;
        data["detailAddress"] = this.detailAddress;
        return data; 
    }
}

export interface ICnWmsEntryorderCreateInputEntryOrderReceiverInfo {
    company: string | undefined;
    name: string | undefined;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string | undefined;
}

export class CnWmsEntryorderCreateOutput implements ICnWmsEntryorderCreateOutput {
    code: string | undefined;
    _success: boolean | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: ICnWmsEntryorderCreateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this._success = data["_success"];
            this.flag = data["flag"];
            this.message = data["message"];
            this.needRetry = data["needRetry"];
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): CnWmsEntryorderCreateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsEntryorderCreateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["_success"] = this._success;
        data["flag"] = this.flag;
        data["message"] = this.message;
        data["needRetry"] = this.needRetry;
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface ICnWmsEntryorderCreateOutput {
    code: string | undefined;
    _success: boolean | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class CnWmsInventoryQueryInput implements ICnWmsInventoryQueryInput {
    criteriaList: CnWmsInventoryQqueryInputCriteria[] | undefined;
    ownerCode: string | undefined;
    warehouseCode: string | undefined;
    remark: string | undefined;

    constructor(data?: ICnWmsInventoryQueryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["criteriaList"] && data["criteriaList"].constructor === Array) {
                this.criteriaList = [];
                for (let item of data["criteriaList"])
                    this.criteriaList.push(CnWmsInventoryQqueryInputCriteria.fromJS(item));
            }
            this.ownerCode = data["ownerCode"];
            this.warehouseCode = data["warehouseCode"];
            this.remark = data["remark"];
        }
    }

    static fromJS(data: any): CnWmsInventoryQueryInput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsInventoryQueryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.criteriaList && this.criteriaList.constructor === Array) {
            data["criteriaList"] = [];
            for (let item of this.criteriaList)
                data["criteriaList"].push(item.toJSON());
        }
        data["ownerCode"] = this.ownerCode;
        data["warehouseCode"] = this.warehouseCode;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface ICnWmsInventoryQueryInput {
    criteriaList: CnWmsInventoryQqueryInputCriteria[] | undefined;
    ownerCode: string | undefined;
    warehouseCode: string | undefined;
    remark: string | undefined;
}

export class CnWmsInventoryQqueryInputCriteria implements ICnWmsInventoryQqueryInputCriteria {
    warehouseCode: string | undefined;
    ownerCode: string | undefined;
    itemCode: string;
    itemId: string | undefined;
    inventoryType: string | undefined;
    remark: string | undefined;

    constructor(data?: ICnWmsInventoryQqueryInputCriteria) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.warehouseCode = data["warehouseCode"];
            this.ownerCode = data["ownerCode"];
            this.itemCode = data["itemCode"];
            this.itemId = data["itemId"];
            this.inventoryType = data["inventoryType"];
            this.remark = data["remark"];
        }
    }

    static fromJS(data: any): CnWmsInventoryQqueryInputCriteria {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsInventoryQqueryInputCriteria();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warehouseCode"] = this.warehouseCode;
        data["ownerCode"] = this.ownerCode;
        data["itemCode"] = this.itemCode;
        data["itemId"] = this.itemId;
        data["inventoryType"] = this.inventoryType;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface ICnWmsInventoryQqueryInputCriteria {
    warehouseCode: string | undefined;
    ownerCode: string | undefined;
    itemCode: string;
    itemId: string | undefined;
    inventoryType: string | undefined;
    remark: string | undefined;
}

export class CnWmsInventoryQueryOutput implements ICnWmsInventoryQueryOutput {
    code: string | undefined;
    _success: boolean | undefined;
    items: CnWmsInventoryQueryOutputItem[] | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: ICnWmsInventoryQueryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this._success = data["_success"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(CnWmsInventoryQueryOutputItem.fromJS(item));
            }
            this.flag = data["flag"];
            this.message = data["message"];
            this.needRetry = data["needRetry"];
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): CnWmsInventoryQueryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsInventoryQueryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["_success"] = this._success;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["flag"] = this.flag;
        data["message"] = this.message;
        data["needRetry"] = this.needRetry;
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface ICnWmsInventoryQueryOutput {
    code: string | undefined;
    _success: boolean | undefined;
    items: CnWmsInventoryQueryOutputItem[] | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class CnWmsInventoryQueryOutputItem implements ICnWmsInventoryQueryOutputItem {
    warehouseCode: string;
    itemCode: string;
    itemId: string;
    inventoryType: string;
    quantity: number | undefined;
    lockQuantity: number | undefined;
    batchCode: string;
    productDate: moment.Moment;
    expireDate: moment.Moment;
    produceCode: string;

    constructor(data?: ICnWmsInventoryQueryOutputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.warehouseCode = data["warehouseCode"];
            this.itemCode = data["itemCode"];
            this.itemId = data["itemId"];
            this.inventoryType = data["inventoryType"];
            this.quantity = data["quantity"];
            this.lockQuantity = data["lockQuantity"];
            this.batchCode = data["batchCode"];
            this.productDate = data["productDate"] ? moment(data["productDate"].toString()) : <any>undefined;
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.produceCode = data["produceCode"];
        }
    }

    static fromJS(data: any): CnWmsInventoryQueryOutputItem {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsInventoryQueryOutputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warehouseCode"] = this.warehouseCode;
        data["itemCode"] = this.itemCode;
        data["itemId"] = this.itemId;
        data["inventoryType"] = this.inventoryType;
        data["quantity"] = this.quantity;
        data["lockQuantity"] = this.lockQuantity;
        data["batchCode"] = this.batchCode;
        data["productDate"] = this.productDate ? this.productDate.toISOString() : <any>undefined;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["produceCode"] = this.produceCode;
        return data; 
    }
}

export interface ICnWmsInventoryQueryOutputItem {
    warehouseCode: string;
    itemCode: string;
    itemId: string;
    inventoryType: string;
    quantity: number | undefined;
    lockQuantity: number | undefined;
    batchCode: string;
    productDate: moment.Moment;
    expireDate: moment.Moment;
    produceCode: string;
}

export class CnWmsOrderCancelInput implements ICnWmsOrderCancelInput {
    warehouseCode: string;
    ownerCode: string;
    orderCode: string;
    cnOrderCode: string;
    orderType: string | undefined;
    cancelReason: string | undefined;

    constructor(data?: ICnWmsOrderCancelInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.warehouseCode = data["warehouseCode"];
            this.ownerCode = data["ownerCode"];
            this.orderCode = data["orderCode"];
            this.cnOrderCode = data["cnOrderCode"];
            this.orderType = data["orderType"];
            this.cancelReason = data["cancelReason"];
        }
    }

    static fromJS(data: any): CnWmsOrderCancelInput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsOrderCancelInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warehouseCode"] = this.warehouseCode;
        data["ownerCode"] = this.ownerCode;
        data["orderCode"] = this.orderCode;
        data["cnOrderCode"] = this.cnOrderCode;
        data["orderType"] = this.orderType;
        data["cancelReason"] = this.cancelReason;
        return data; 
    }
}

export interface ICnWmsOrderCancelInput {
    warehouseCode: string;
    ownerCode: string;
    orderCode: string;
    cnOrderCode: string;
    orderType: string | undefined;
    cancelReason: string | undefined;
}

export class CnWmsOrderCancelOutput implements ICnWmsOrderCancelOutput {
    code: string | undefined;
    _success: boolean | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: ICnWmsOrderCancelOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this._success = data["_success"];
            this.flag = data["flag"];
            this.message = data["message"];
            this.needRetry = data["needRetry"];
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): CnWmsOrderCancelOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsOrderCancelOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["_success"] = this._success;
        data["flag"] = this.flag;
        data["message"] = this.message;
        data["needRetry"] = this.needRetry;
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface ICnWmsOrderCancelOutput {
    code: string | undefined;
    _success: boolean | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class CnWmsReturnorderCreateInput implements ICnWmsReturnorderCreateInput {
    returnOrder: CnWmsReturnorderCreateInputReturnOrder | undefined;
    orderLines: CnWmsReturnorderCreateInputOrderLine[] | undefined;

    constructor(data?: ICnWmsReturnorderCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.returnOrder = data["returnOrder"] ? CnWmsReturnorderCreateInputReturnOrder.fromJS(data["returnOrder"]) : <any>undefined;
            if (data["orderLines"] && data["orderLines"].constructor === Array) {
                this.orderLines = [];
                for (let item of data["orderLines"])
                    this.orderLines.push(CnWmsReturnorderCreateInputOrderLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CnWmsReturnorderCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsReturnorderCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["returnOrder"] = this.returnOrder ? this.returnOrder.toJSON() : <any>undefined;
        if (this.orderLines && this.orderLines.constructor === Array) {
            data["orderLines"] = [];
            for (let item of this.orderLines)
                data["orderLines"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICnWmsReturnorderCreateInput {
    returnOrder: CnWmsReturnorderCreateInputReturnOrder | undefined;
    orderLines: CnWmsReturnorderCreateInputOrderLine[] | undefined;
}

export class CnWmsReturnorderCreateInputReturnOrder implements ICnWmsReturnorderCreateInputReturnOrder {
    returnOrderCode: string;
    cnOrderCode: string;
    warehouseCode: string;
    ownerCode: string;
    orderType: string | undefined;
    orderFlag: string | undefined;
    preDeliveryOrderCode: string | undefined;
    preCnOrderCode: string | undefined;
    logisticsCode: string | undefined;
    logisticsName: string | undefined;
    expressCode: string | undefined;
    returnReason: string | undefined;
    buyerNick: string | undefined;
    remark: string | undefined;
    senderInfo: CnWmsReturnorderCreateInputReturnOrderSenderInfo | undefined;

    constructor(data?: ICnWmsReturnorderCreateInputReturnOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.returnOrderCode = data["returnOrderCode"];
            this.cnOrderCode = data["cnOrderCode"];
            this.warehouseCode = data["warehouseCode"];
            this.ownerCode = data["ownerCode"];
            this.orderType = data["orderType"];
            this.orderFlag = data["orderFlag"];
            this.preDeliveryOrderCode = data["preDeliveryOrderCode"];
            this.preCnOrderCode = data["preCnOrderCode"];
            this.logisticsCode = data["logisticsCode"];
            this.logisticsName = data["logisticsName"];
            this.expressCode = data["expressCode"];
            this.returnReason = data["returnReason"];
            this.buyerNick = data["buyerNick"];
            this.remark = data["remark"];
            this.senderInfo = data["senderInfo"] ? CnWmsReturnorderCreateInputReturnOrderSenderInfo.fromJS(data["senderInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CnWmsReturnorderCreateInputReturnOrder {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsReturnorderCreateInputReturnOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["returnOrderCode"] = this.returnOrderCode;
        data["cnOrderCode"] = this.cnOrderCode;
        data["warehouseCode"] = this.warehouseCode;
        data["ownerCode"] = this.ownerCode;
        data["orderType"] = this.orderType;
        data["orderFlag"] = this.orderFlag;
        data["preDeliveryOrderCode"] = this.preDeliveryOrderCode;
        data["preCnOrderCode"] = this.preCnOrderCode;
        data["logisticsCode"] = this.logisticsCode;
        data["logisticsName"] = this.logisticsName;
        data["expressCode"] = this.expressCode;
        data["returnReason"] = this.returnReason;
        data["buyerNick"] = this.buyerNick;
        data["remark"] = this.remark;
        data["senderInfo"] = this.senderInfo ? this.senderInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICnWmsReturnorderCreateInputReturnOrder {
    returnOrderCode: string;
    cnOrderCode: string;
    warehouseCode: string;
    ownerCode: string;
    orderType: string | undefined;
    orderFlag: string | undefined;
    preDeliveryOrderCode: string | undefined;
    preCnOrderCode: string | undefined;
    logisticsCode: string | undefined;
    logisticsName: string | undefined;
    expressCode: string | undefined;
    returnReason: string | undefined;
    buyerNick: string | undefined;
    remark: string | undefined;
    senderInfo: CnWmsReturnorderCreateInputReturnOrderSenderInfo | undefined;
}

export class CnWmsReturnorderCreateInputOrderLine implements ICnWmsReturnorderCreateInputOrderLine {
    orderLineNo: string;
    sourceOrderCode: string | undefined;
    subSourceOrderCode: string | undefined;
    ownerCode: string;
    itemName: string | undefined;
    itemCode: string;
    inventoryType: string | undefined;
    planQty: number | undefined;
    batchCode: string | undefined;
    productDate: string | undefined;
    expireDate: string | undefined;
    produceCode: string | undefined;

    constructor(data?: ICnWmsReturnorderCreateInputOrderLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderLineNo = data["orderLineNo"];
            this.sourceOrderCode = data["sourceOrderCode"];
            this.subSourceOrderCode = data["subSourceOrderCode"];
            this.ownerCode = data["ownerCode"];
            this.itemName = data["itemName"];
            this.itemCode = data["itemCode"];
            this.inventoryType = data["inventoryType"];
            this.planQty = data["planQty"];
            this.batchCode = data["batchCode"];
            this.productDate = data["productDate"];
            this.expireDate = data["expireDate"];
            this.produceCode = data["produceCode"];
        }
    }

    static fromJS(data: any): CnWmsReturnorderCreateInputOrderLine {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsReturnorderCreateInputOrderLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderLineNo"] = this.orderLineNo;
        data["sourceOrderCode"] = this.sourceOrderCode;
        data["subSourceOrderCode"] = this.subSourceOrderCode;
        data["ownerCode"] = this.ownerCode;
        data["itemName"] = this.itemName;
        data["itemCode"] = this.itemCode;
        data["inventoryType"] = this.inventoryType;
        data["planQty"] = this.planQty;
        data["batchCode"] = this.batchCode;
        data["productDate"] = this.productDate;
        data["expireDate"] = this.expireDate;
        data["produceCode"] = this.produceCode;
        return data; 
    }
}

export interface ICnWmsReturnorderCreateInputOrderLine {
    orderLineNo: string;
    sourceOrderCode: string | undefined;
    subSourceOrderCode: string | undefined;
    ownerCode: string;
    itemName: string | undefined;
    itemCode: string;
    inventoryType: string | undefined;
    planQty: number | undefined;
    batchCode: string | undefined;
    productDate: string | undefined;
    expireDate: string | undefined;
    produceCode: string | undefined;
}

export class CnWmsReturnorderCreateInputReturnOrderSenderInfo implements ICnWmsReturnorderCreateInputReturnOrderSenderInfo {
    company: string | undefined;
    name: string | undefined;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string | undefined;

    constructor(data?: ICnWmsReturnorderCreateInputReturnOrderSenderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.company = data["company"];
            this.name = data["name"];
            this.zipCode = data["zipCode"];
            this.tel = data["tel"];
            this.mobile = data["mobile"];
            this.idType = data["idType"];
            this.idNumber = data["idNumber"];
            this.email = data["email"];
            this.countryCode = data["countryCode"];
            this.province = data["province"];
            this.city = data["city"];
            this.area = data["area"];
            this.town = data["town"];
            this.detailAddress = data["detailAddress"];
        }
    }

    static fromJS(data: any): CnWmsReturnorderCreateInputReturnOrderSenderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsReturnorderCreateInputReturnOrderSenderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["name"] = this.name;
        data["zipCode"] = this.zipCode;
        data["tel"] = this.tel;
        data["mobile"] = this.mobile;
        data["idType"] = this.idType;
        data["idNumber"] = this.idNumber;
        data["email"] = this.email;
        data["countryCode"] = this.countryCode;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["town"] = this.town;
        data["detailAddress"] = this.detailAddress;
        return data; 
    }
}

export interface ICnWmsReturnorderCreateInputReturnOrderSenderInfo {
    company: string | undefined;
    name: string | undefined;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string | undefined;
}

export class CnWmsReturnorderCreateOutput implements ICnWmsReturnorderCreateOutput {
    code: string | undefined;
    _success: boolean | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: ICnWmsReturnorderCreateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this._success = data["_success"];
            this.flag = data["flag"];
            this.message = data["message"];
            this.needRetry = data["needRetry"];
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): CnWmsReturnorderCreateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsReturnorderCreateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["_success"] = this._success;
        data["flag"] = this.flag;
        data["message"] = this.message;
        data["needRetry"] = this.needRetry;
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface ICnWmsReturnorderCreateOutput {
    code: string | undefined;
    _success: boolean | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class CnWmsSingleitemSynchronizeInput implements ICnWmsSingleitemSynchronizeInput {
    actionType: string;
    warehouseCode: string | undefined;
    ownerCode: string;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    item: CnWmsSingleitemSynchronizeInputItem | undefined;

    constructor(data?: ICnWmsSingleitemSynchronizeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.actionType = data["actionType"];
            this.warehouseCode = data["warehouseCode"];
            this.ownerCode = data["ownerCode"];
            this.supplierCode = data["supplierCode"];
            this.supplierName = data["supplierName"];
            this.item = data["item"] ? CnWmsSingleitemSynchronizeInputItem.fromJS(data["item"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CnWmsSingleitemSynchronizeInput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsSingleitemSynchronizeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["actionType"] = this.actionType;
        data["warehouseCode"] = this.warehouseCode;
        data["ownerCode"] = this.ownerCode;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["item"] = this.item ? this.item.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICnWmsSingleitemSynchronizeInput {
    actionType: string;
    warehouseCode: string | undefined;
    ownerCode: string;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    item: CnWmsSingleitemSynchronizeInputItem | undefined;
}

export class CnWmsSingleitemSynchronizeInputItem implements ICnWmsSingleitemSynchronizeInputItem {
    itemCode: string;
    itemId: string | undefined;
    goodsCode: string | undefined;
    itemName: string;
    shortName: string | undefined;
    englishName: string | undefined;
    barCode: string;
    skuProperty: string | undefined;
    stockUnit: string | undefined;
    length: string | undefined;
    width: string | undefined;
    height: string | undefined;
    volume: string | undefined;
    grossWeight: string | undefined;
    netWeight: string | undefined;
    color: string | undefined;
    size: string | undefined;
    title: string | undefined;
    categoryId: string | undefined;
    categoryName: string | undefined;
    pricingCategory: string | undefined;
    safetyStock: number | undefined;
    itemType: string;
    tagPrice: string | undefined;
    retailPrice: string | undefined;
    costPrice: string | undefined;
    purchasePrice: string | undefined;
    seasonCode: string | undefined;
    seasonName: string | undefined;
    brandCode: string | undefined;
    brandName: string | undefined;
    isSNMgmt: string | undefined;
    productDate: string | undefined;
    expireDate: string | undefined;
    isShelfLifeMgmt: string | undefined;
    shelfLife: number | undefined;
    rejectLifecycle: number | undefined;
    lockupLifecycle: number | undefined;
    adventLifecycle: number | undefined;
    isBatchMgmt: string | undefined;
    batchCode: string | undefined;
    batchRemark: string | undefined;
    packCode: string | undefined;
    pcs: string | undefined;
    originAddress: string | undefined;
    approvalNumber: string | undefined;
    isFragile: string | undefined;
    isHazardous: string | undefined;
    remark: string | undefined;
    createTime: moment.Moment | undefined;
    updateTime: moment.Moment | undefined;
    isValid: string | undefined;
    isSku: string | undefined;
    packageMaterial: string | undefined;
    supplierCode: string | undefined;
    value: string | undefined;

    constructor(data?: ICnWmsSingleitemSynchronizeInputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemCode = data["itemCode"];
            this.itemId = data["itemId"];
            this.goodsCode = data["goodsCode"];
            this.itemName = data["itemName"];
            this.shortName = data["shortName"];
            this.englishName = data["englishName"];
            this.barCode = data["barCode"];
            this.skuProperty = data["skuProperty"];
            this.stockUnit = data["stockUnit"];
            this.length = data["length"];
            this.width = data["width"];
            this.height = data["height"];
            this.volume = data["volume"];
            this.grossWeight = data["grossWeight"];
            this.netWeight = data["netWeight"];
            this.color = data["color"];
            this.size = data["size"];
            this.title = data["title"];
            this.categoryId = data["categoryId"];
            this.categoryName = data["categoryName"];
            this.pricingCategory = data["pricingCategory"];
            this.safetyStock = data["safetyStock"];
            this.itemType = data["itemType"];
            this.tagPrice = data["tagPrice"];
            this.retailPrice = data["retailPrice"];
            this.costPrice = data["costPrice"];
            this.purchasePrice = data["purchasePrice"];
            this.seasonCode = data["seasonCode"];
            this.seasonName = data["seasonName"];
            this.brandCode = data["brandCode"];
            this.brandName = data["brandName"];
            this.isSNMgmt = data["isSNMgmt"];
            this.productDate = data["productDate"];
            this.expireDate = data["expireDate"];
            this.isShelfLifeMgmt = data["isShelfLifeMgmt"];
            this.shelfLife = data["shelfLife"];
            this.rejectLifecycle = data["rejectLifecycle"];
            this.lockupLifecycle = data["lockupLifecycle"];
            this.adventLifecycle = data["adventLifecycle"];
            this.isBatchMgmt = data["isBatchMgmt"];
            this.batchCode = data["batchCode"];
            this.batchRemark = data["batchRemark"];
            this.packCode = data["packCode"];
            this.pcs = data["pcs"];
            this.originAddress = data["originAddress"];
            this.approvalNumber = data["approvalNumber"];
            this.isFragile = data["isFragile"];
            this.isHazardous = data["isHazardous"];
            this.remark = data["remark"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.updateTime = data["updateTime"] ? moment(data["updateTime"].toString()) : <any>undefined;
            this.isValid = data["isValid"];
            this.isSku = data["isSku"];
            this.packageMaterial = data["packageMaterial"];
            this.supplierCode = data["supplierCode"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): CnWmsSingleitemSynchronizeInputItem {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsSingleitemSynchronizeInputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemCode"] = this.itemCode;
        data["itemId"] = this.itemId;
        data["goodsCode"] = this.goodsCode;
        data["itemName"] = this.itemName;
        data["shortName"] = this.shortName;
        data["englishName"] = this.englishName;
        data["barCode"] = this.barCode;
        data["skuProperty"] = this.skuProperty;
        data["stockUnit"] = this.stockUnit;
        data["length"] = this.length;
        data["width"] = this.width;
        data["height"] = this.height;
        data["volume"] = this.volume;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["color"] = this.color;
        data["size"] = this.size;
        data["title"] = this.title;
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        data["pricingCategory"] = this.pricingCategory;
        data["safetyStock"] = this.safetyStock;
        data["itemType"] = this.itemType;
        data["tagPrice"] = this.tagPrice;
        data["retailPrice"] = this.retailPrice;
        data["costPrice"] = this.costPrice;
        data["purchasePrice"] = this.purchasePrice;
        data["seasonCode"] = this.seasonCode;
        data["seasonName"] = this.seasonName;
        data["brandCode"] = this.brandCode;
        data["brandName"] = this.brandName;
        data["isSNMgmt"] = this.isSNMgmt;
        data["productDate"] = this.productDate;
        data["expireDate"] = this.expireDate;
        data["isShelfLifeMgmt"] = this.isShelfLifeMgmt;
        data["shelfLife"] = this.shelfLife;
        data["rejectLifecycle"] = this.rejectLifecycle;
        data["lockupLifecycle"] = this.lockupLifecycle;
        data["adventLifecycle"] = this.adventLifecycle;
        data["isBatchMgmt"] = this.isBatchMgmt;
        data["batchCode"] = this.batchCode;
        data["batchRemark"] = this.batchRemark;
        data["packCode"] = this.packCode;
        data["pcs"] = this.pcs;
        data["originAddress"] = this.originAddress;
        data["approvalNumber"] = this.approvalNumber;
        data["isFragile"] = this.isFragile;
        data["isHazardous"] = this.isHazardous;
        data["remark"] = this.remark;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["updateTime"] = this.updateTime ? this.updateTime.toISOString() : <any>undefined;
        data["isValid"] = this.isValid;
        data["isSku"] = this.isSku;
        data["packageMaterial"] = this.packageMaterial;
        data["supplierCode"] = this.supplierCode;
        data["value"] = this.value;
        return data; 
    }
}

export interface ICnWmsSingleitemSynchronizeInputItem {
    itemCode: string;
    itemId: string | undefined;
    goodsCode: string | undefined;
    itemName: string;
    shortName: string | undefined;
    englishName: string | undefined;
    barCode: string;
    skuProperty: string | undefined;
    stockUnit: string | undefined;
    length: string | undefined;
    width: string | undefined;
    height: string | undefined;
    volume: string | undefined;
    grossWeight: string | undefined;
    netWeight: string | undefined;
    color: string | undefined;
    size: string | undefined;
    title: string | undefined;
    categoryId: string | undefined;
    categoryName: string | undefined;
    pricingCategory: string | undefined;
    safetyStock: number | undefined;
    itemType: string;
    tagPrice: string | undefined;
    retailPrice: string | undefined;
    costPrice: string | undefined;
    purchasePrice: string | undefined;
    seasonCode: string | undefined;
    seasonName: string | undefined;
    brandCode: string | undefined;
    brandName: string | undefined;
    isSNMgmt: string | undefined;
    productDate: string | undefined;
    expireDate: string | undefined;
    isShelfLifeMgmt: string | undefined;
    shelfLife: number | undefined;
    rejectLifecycle: number | undefined;
    lockupLifecycle: number | undefined;
    adventLifecycle: number | undefined;
    isBatchMgmt: string | undefined;
    batchCode: string | undefined;
    batchRemark: string | undefined;
    packCode: string | undefined;
    pcs: string | undefined;
    originAddress: string | undefined;
    approvalNumber: string | undefined;
    isFragile: string | undefined;
    isHazardous: string | undefined;
    remark: string | undefined;
    createTime: moment.Moment | undefined;
    updateTime: moment.Moment | undefined;
    isValid: string | undefined;
    isSku: string | undefined;
    packageMaterial: string | undefined;
    supplierCode: string | undefined;
    value: string | undefined;
}

export class CnWmsSingleitemSynchronizeOutput implements ICnWmsSingleitemSynchronizeOutput {
    code: string | undefined;
    _success: boolean | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: ICnWmsSingleitemSynchronizeOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this._success = data["_success"];
            this.flag = data["flag"];
            this.message = data["message"];
            this.needRetry = data["needRetry"];
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): CnWmsSingleitemSynchronizeOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsSingleitemSynchronizeOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["_success"] = this._success;
        data["flag"] = this.flag;
        data["message"] = this.message;
        data["needRetry"] = this.needRetry;
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface ICnWmsSingleitemSynchronizeOutput {
    code: string | undefined;
    _success: boolean | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class CnWmsStockoutCreateInput implements ICnWmsStockoutCreateInput {
    deliveryOrder: CnWmsStockoutCreateInputDeliveryOrder | undefined;
    orderLines: CnWmsStockoutCreateInputOrderLine[] | undefined;

    constructor(data?: ICnWmsStockoutCreateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deliveryOrder = data["deliveryOrder"] ? CnWmsStockoutCreateInputDeliveryOrder.fromJS(data["deliveryOrder"]) : <any>undefined;
            if (data["orderLines"] && data["orderLines"].constructor === Array) {
                this.orderLines = [];
                for (let item of data["orderLines"])
                    this.orderLines.push(CnWmsStockoutCreateInputOrderLine.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CnWmsStockoutCreateInput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsStockoutCreateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryOrder"] = this.deliveryOrder ? this.deliveryOrder.toJSON() : <any>undefined;
        if (this.orderLines && this.orderLines.constructor === Array) {
            data["orderLines"] = [];
            for (let item of this.orderLines)
                data["orderLines"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICnWmsStockoutCreateInput {
    deliveryOrder: CnWmsStockoutCreateInputDeliveryOrder | undefined;
    orderLines: CnWmsStockoutCreateInputOrderLine[] | undefined;
}

export class CnWmsStockoutCreateInputDeliveryOrder implements ICnWmsStockoutCreateInputDeliveryOrder {
    deliveryOrderCode: string;
    cnOrderCode: string;
    ownerCode: string;
    orderType: string;
    warehouseCode: string;
    createTime: moment.Moment | undefined;
    scheduleDate: string | undefined;
    logisticsCode: string | undefined;
    logisticsName: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    transportMode: string | undefined;
    pickerInfo: CnWmsStockoutCreateInputDeliveryOrderPickerInfo | undefined;
    senderInfo: CnWmsStockoutCreateInputDeliveryOrderSenderInfo | undefined;
    receiverInfo: CnWmsStockoutCreateInputDeliveryOrderReceiverInfo | undefined;
    remark: string | undefined;
    orderSourceType: string | undefined;

    constructor(data?: ICnWmsStockoutCreateInputDeliveryOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.deliveryOrderCode = data["deliveryOrderCode"];
            this.cnOrderCode = data["cnOrderCode"];
            this.ownerCode = data["ownerCode"];
            this.orderType = data["orderType"];
            this.warehouseCode = data["warehouseCode"];
            this.createTime = data["createTime"] ? moment(data["createTime"].toString()) : <any>undefined;
            this.scheduleDate = data["scheduleDate"];
            this.logisticsCode = data["logisticsCode"];
            this.logisticsName = data["logisticsName"];
            this.supplierCode = data["supplierCode"];
            this.supplierName = data["supplierName"];
            this.transportMode = data["transportMode"];
            this.pickerInfo = data["pickerInfo"] ? CnWmsStockoutCreateInputDeliveryOrderPickerInfo.fromJS(data["pickerInfo"]) : <any>undefined;
            this.senderInfo = data["senderInfo"] ? CnWmsStockoutCreateInputDeliveryOrderSenderInfo.fromJS(data["senderInfo"]) : <any>undefined;
            this.receiverInfo = data["receiverInfo"] ? CnWmsStockoutCreateInputDeliveryOrderReceiverInfo.fromJS(data["receiverInfo"]) : <any>undefined;
            this.remark = data["remark"];
            this.orderSourceType = data["orderSourceType"];
        }
    }

    static fromJS(data: any): CnWmsStockoutCreateInputDeliveryOrder {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsStockoutCreateInputDeliveryOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deliveryOrderCode"] = this.deliveryOrderCode;
        data["cnOrderCode"] = this.cnOrderCode;
        data["ownerCode"] = this.ownerCode;
        data["orderType"] = this.orderType;
        data["warehouseCode"] = this.warehouseCode;
        data["createTime"] = this.createTime ? this.createTime.toISOString() : <any>undefined;
        data["scheduleDate"] = this.scheduleDate;
        data["logisticsCode"] = this.logisticsCode;
        data["logisticsName"] = this.logisticsName;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["transportMode"] = this.transportMode;
        data["pickerInfo"] = this.pickerInfo ? this.pickerInfo.toJSON() : <any>undefined;
        data["senderInfo"] = this.senderInfo ? this.senderInfo.toJSON() : <any>undefined;
        data["receiverInfo"] = this.receiverInfo ? this.receiverInfo.toJSON() : <any>undefined;
        data["remark"] = this.remark;
        data["orderSourceType"] = this.orderSourceType;
        return data; 
    }
}

export interface ICnWmsStockoutCreateInputDeliveryOrder {
    deliveryOrderCode: string;
    cnOrderCode: string;
    ownerCode: string;
    orderType: string;
    warehouseCode: string;
    createTime: moment.Moment | undefined;
    scheduleDate: string | undefined;
    logisticsCode: string | undefined;
    logisticsName: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    transportMode: string | undefined;
    pickerInfo: CnWmsStockoutCreateInputDeliveryOrderPickerInfo | undefined;
    senderInfo: CnWmsStockoutCreateInputDeliveryOrderSenderInfo | undefined;
    receiverInfo: CnWmsStockoutCreateInputDeliveryOrderReceiverInfo | undefined;
    remark: string | undefined;
    orderSourceType: string | undefined;
}

export class CnWmsStockoutCreateInputOrderLine implements ICnWmsStockoutCreateInputOrderLine {
    orderLineNo: string;
    ownerCode: string;
    itemCode: string;
    inventoryType: string | undefined;
    itemName: string | undefined;
    planQty: number | undefined;
    batchCode: string | undefined;
    productDate: moment.Moment | undefined;
    expireDate: moment.Moment | undefined;
    produceCode: string | undefined;

    constructor(data?: ICnWmsStockoutCreateInputOrderLine) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderLineNo = data["orderLineNo"];
            this.ownerCode = data["ownerCode"];
            this.itemCode = data["itemCode"];
            this.inventoryType = data["inventoryType"];
            this.itemName = data["itemName"];
            this.planQty = data["planQty"];
            this.batchCode = data["batchCode"];
            this.productDate = data["productDate"] ? moment(data["productDate"].toString()) : <any>undefined;
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.produceCode = data["produceCode"];
        }
    }

    static fromJS(data: any): CnWmsStockoutCreateInputOrderLine {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsStockoutCreateInputOrderLine();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderLineNo"] = this.orderLineNo;
        data["ownerCode"] = this.ownerCode;
        data["itemCode"] = this.itemCode;
        data["inventoryType"] = this.inventoryType;
        data["itemName"] = this.itemName;
        data["planQty"] = this.planQty;
        data["batchCode"] = this.batchCode;
        data["productDate"] = this.productDate ? this.productDate.toISOString() : <any>undefined;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["produceCode"] = this.produceCode;
        return data; 
    }
}

export interface ICnWmsStockoutCreateInputOrderLine {
    orderLineNo: string;
    ownerCode: string;
    itemCode: string;
    inventoryType: string | undefined;
    itemName: string | undefined;
    planQty: number | undefined;
    batchCode: string | undefined;
    productDate: moment.Moment | undefined;
    expireDate: moment.Moment | undefined;
    produceCode: string | undefined;
}

export class CnWmsStockoutCreateInputDeliveryOrderPickerInfo implements ICnWmsStockoutCreateInputDeliveryOrderPickerInfo {
    company: string | undefined;
    name: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    id: string | undefined;
    carNo: string | undefined;

    constructor(data?: ICnWmsStockoutCreateInputDeliveryOrderPickerInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.company = data["company"];
            this.name = data["name"];
            this.tel = data["tel"];
            this.mobile = data["mobile"];
            this.id = data["id"];
            this.carNo = data["carNo"];
        }
    }

    static fromJS(data: any): CnWmsStockoutCreateInputDeliveryOrderPickerInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsStockoutCreateInputDeliveryOrderPickerInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["name"] = this.name;
        data["tel"] = this.tel;
        data["mobile"] = this.mobile;
        data["id"] = this.id;
        data["carNo"] = this.carNo;
        return data; 
    }
}

export interface ICnWmsStockoutCreateInputDeliveryOrderPickerInfo {
    company: string | undefined;
    name: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    id: string | undefined;
    carNo: string | undefined;
}

export class CnWmsStockoutCreateInputDeliveryOrderSenderInfo implements ICnWmsStockoutCreateInputDeliveryOrderSenderInfo {
    company: string | undefined;
    name: string | undefined;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string | undefined;

    constructor(data?: ICnWmsStockoutCreateInputDeliveryOrderSenderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.company = data["company"];
            this.name = data["name"];
            this.zipCode = data["zipCode"];
            this.tel = data["tel"];
            this.mobile = data["mobile"];
            this.idType = data["idType"];
            this.idNumber = data["idNumber"];
            this.email = data["email"];
            this.countryCode = data["countryCode"];
            this.province = data["province"];
            this.city = data["city"];
            this.area = data["area"];
            this.town = data["town"];
            this.detailAddress = data["detailAddress"];
        }
    }

    static fromJS(data: any): CnWmsStockoutCreateInputDeliveryOrderSenderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsStockoutCreateInputDeliveryOrderSenderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["name"] = this.name;
        data["zipCode"] = this.zipCode;
        data["tel"] = this.tel;
        data["mobile"] = this.mobile;
        data["idType"] = this.idType;
        data["idNumber"] = this.idNumber;
        data["email"] = this.email;
        data["countryCode"] = this.countryCode;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["town"] = this.town;
        data["detailAddress"] = this.detailAddress;
        return data; 
    }
}

export interface ICnWmsStockoutCreateInputDeliveryOrderSenderInfo {
    company: string | undefined;
    name: string | undefined;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string | undefined;
}

export class CnWmsStockoutCreateInputDeliveryOrderReceiverInfo implements ICnWmsStockoutCreateInputDeliveryOrderReceiverInfo {
    company: string | undefined;
    name: string | undefined;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string;
    id: string | undefined;

    constructor(data?: ICnWmsStockoutCreateInputDeliveryOrderReceiverInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.company = data["company"];
            this.name = data["name"];
            this.zipCode = data["zipCode"];
            this.tel = data["tel"];
            this.mobile = data["mobile"];
            this.idType = data["idType"];
            this.idNumber = data["idNumber"];
            this.email = data["email"];
            this.countryCode = data["countryCode"];
            this.province = data["province"];
            this.city = data["city"];
            this.area = data["area"];
            this.town = data["town"];
            this.detailAddress = data["detailAddress"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CnWmsStockoutCreateInputDeliveryOrderReceiverInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsStockoutCreateInputDeliveryOrderReceiverInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["company"] = this.company;
        data["name"] = this.name;
        data["zipCode"] = this.zipCode;
        data["tel"] = this.tel;
        data["mobile"] = this.mobile;
        data["idType"] = this.idType;
        data["idNumber"] = this.idNumber;
        data["email"] = this.email;
        data["countryCode"] = this.countryCode;
        data["province"] = this.province;
        data["city"] = this.city;
        data["area"] = this.area;
        data["town"] = this.town;
        data["detailAddress"] = this.detailAddress;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICnWmsStockoutCreateInputDeliveryOrderReceiverInfo {
    company: string | undefined;
    name: string | undefined;
    zipCode: string | undefined;
    tel: string | undefined;
    mobile: string | undefined;
    idType: string | undefined;
    idNumber: string | undefined;
    email: string | undefined;
    countryCode: string | undefined;
    province: string | undefined;
    city: string | undefined;
    area: string | undefined;
    town: string | undefined;
    detailAddress: string;
    id: string | undefined;
}

export class CnWmsStockoutCreateOutput implements ICnWmsStockoutCreateOutput {
    code: string | undefined;
    _success: boolean | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: ICnWmsStockoutCreateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this._success = data["_success"];
            this.flag = data["flag"];
            this.message = data["message"];
            this.needRetry = data["needRetry"];
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): CnWmsStockoutCreateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CnWmsStockoutCreateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["_success"] = this._success;
        data["flag"] = this.flag;
        data["message"] = this.message;
        data["needRetry"] = this.needRetry;
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface ICnWmsStockoutCreateOutput {
    code: string | undefined;
    _success: boolean | undefined;
    flag: string | undefined;
    message: string | undefined;
    needRetry: string | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class InventoryQuantityQueryInput implements IInventoryQuantityQueryInput {
    wmsInventoryQuantityQueryList: WmsInventoryQuantityQuery[] | undefined;

    constructor(data?: IInventoryQuantityQueryInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["wmsInventoryQuantityQueryList"] && data["wmsInventoryQuantityQueryList"].constructor === Array) {
                this.wmsInventoryQuantityQueryList = [];
                for (let item of data["wmsInventoryQuantityQueryList"])
                    this.wmsInventoryQuantityQueryList.push(WmsInventoryQuantityQuery.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InventoryQuantityQueryInput {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryQuantityQueryInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.wmsInventoryQuantityQueryList && this.wmsInventoryQuantityQueryList.constructor === Array) {
            data["wmsInventoryQuantityQueryList"] = [];
            for (let item of this.wmsInventoryQuantityQueryList)
                data["wmsInventoryQuantityQueryList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInventoryQuantityQueryInput {
    wmsInventoryQuantityQueryList: WmsInventoryQuantityQuery[] | undefined;
}

export class WmsInventoryQuantityQuery implements IWmsInventoryQuantityQuery {
    ownerUserId: string;
    storeCode: string;
    itemId: string | undefined;
    itemCode: string;
    inventoryType: number | undefined;

    constructor(data?: IWmsInventoryQuantityQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerUserId = data["ownerUserId"];
            this.storeCode = data["storeCode"];
            this.itemId = data["itemId"];
            this.itemCode = data["itemCode"];
            this.inventoryType = data["inventoryType"];
        }
    }

    static fromJS(data: any): WmsInventoryQuantityQuery {
        data = typeof data === 'object' ? data : {};
        let result = new WmsInventoryQuantityQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerUserId"] = this.ownerUserId;
        data["storeCode"] = this.storeCode;
        data["itemId"] = this.itemId;
        data["itemCode"] = this.itemCode;
        data["inventoryType"] = this.inventoryType;
        return data; 
    }
}

export interface IWmsInventoryQuantityQuery {
    ownerUserId: string;
    storeCode: string;
    itemId: string | undefined;
    itemCode: string;
    inventoryType: number | undefined;
}

export class InventoryQuantityQueryOutput implements IInventoryQuantityQueryOutput {
    totalCount: number | undefined;
    items: Item[] | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: IInventoryQuantityQueryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["items"] && data["items"].constructor === Array) {
                this.items = [];
                for (let item of data["items"])
                    this.items.push(Item.fromJS(item));
            }
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): InventoryQuantityQueryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryQuantityQueryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.items && this.items.constructor === Array) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface IInventoryQuantityQueryOutput {
    totalCount: number | undefined;
    items: Item[] | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class Item implements IItem {
    itemId: string | undefined;
    itemCode: string | undefined;
    storeCode: string | undefined;
    inventoryType: number | undefined;
    quantity: number | undefined;
    lockQuantity: number | undefined;

    constructor(data?: IItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemId = data["itemId"];
            this.itemCode = data["itemCode"];
            this.storeCode = data["storeCode"];
            this.inventoryType = data["inventoryType"];
            this.quantity = data["quantity"];
            this.lockQuantity = data["lockQuantity"];
        }
    }

    static fromJS(data: any): Item {
        data = typeof data === 'object' ? data : {};
        let result = new Item();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["itemCode"] = this.itemCode;
        data["storeCode"] = this.storeCode;
        data["inventoryType"] = this.inventoryType;
        data["quantity"] = this.quantity;
        data["lockQuantity"] = this.lockQuantity;
        return data; 
    }
}

export interface IItem {
    itemId: string | undefined;
    itemCode: string | undefined;
    storeCode: string | undefined;
    inventoryType: number | undefined;
    quantity: number | undefined;
    lockQuantity: number | undefined;
}

export class GetItemsInput implements IGetItemsInput {
    ownerCode: string | undefined;
    providerTpId: number | undefined;
    itemIds: number[] | undefined;
    itemCodes: string[] | undefined;

    constructor(data?: IGetItemsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerCode = data["ownerCode"];
            this.providerTpId = data["providerTpId"];
            if (data["itemIds"] && data["itemIds"].constructor === Array) {
                this.itemIds = [];
                for (let item of data["itemIds"])
                    this.itemIds.push(item);
            }
            if (data["itemCodes"] && data["itemCodes"].constructor === Array) {
                this.itemCodes = [];
                for (let item of data["itemCodes"])
                    this.itemCodes.push(item);
            }
        }
    }

    static fromJS(data: any): GetItemsInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetItemsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerCode"] = this.ownerCode;
        data["providerTpId"] = this.providerTpId;
        if (this.itemIds && this.itemIds.constructor === Array) {
            data["itemIds"] = [];
            for (let item of this.itemIds)
                data["itemIds"].push(item);
        }
        if (this.itemCodes && this.itemCodes.constructor === Array) {
            data["itemCodes"] = [];
            for (let item of this.itemCodes)
                data["itemCodes"].push(item);
        }
        return data; 
    }
}

export interface IGetItemsInput {
    ownerCode: string | undefined;
    providerTpId: number | undefined;
    itemIds: number[] | undefined;
    itemCodes: string[] | undefined;
}

export class ItemQueryOutput implements IItemQueryOutput {
    totalCount: number | undefined;
    itemList: QueryItemDto[] | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: IItemQueryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (data["itemList"] && data["itemList"].constructor === Array) {
                this.itemList = [];
                for (let item of data["itemList"])
                    this.itemList.push(QueryItemDto.fromJS(item));
            }
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): ItemQueryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ItemQueryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (this.itemList && this.itemList.constructor === Array) {
            data["itemList"] = [];
            for (let item of this.itemList)
                data["itemList"].push(item.toJSON());
        }
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface IItemQueryOutput {
    totalCount: number | undefined;
    itemList: QueryItemDto[] | undefined;
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class QueryItemDto implements IQueryItemDto {
    itemId: number | undefined;
    itemCode: string;
    version: number | undefined;
    itemName: string | undefined;
    providerTpId: number | undefined;
    barCode: string | undefined;
    type: string;
    brand: string | undefined;
    brandName: string | undefined;
    specification: string | undefined;
    color: string | undefined;
    size: string | undefined;
    approvalNumber: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    length: number | undefined;
    width: number | undefined;
    height: number | undefined;
    volume: number | undefined;
    pcs: number | undefined;
    isShelflife: boolean | undefined;
    lifecycle: number | undefined;
    rejectLifecycle: number | undefined;
    lockupLifecycle: number | undefined;
    adventLifecycle: number | undefined;
    isSnMgt: boolean | undefined;
    isHygroscopic: boolean | undefined;
    isDanger: boolean | undefined;
    snMode: string | undefined;
    packagingScheme: string | undefined;
    isProduceCodeMgt: boolean | undefined;
    cartonLength: number | undefined;
    cartonWidth: number | undefined;
    cartonHeight: number | undefined;
    cartonWeight: number | undefined;
    cartonVolume: number | undefined;
    isPoMgt: boolean | undefined;
    isPrecious: boolean | undefined;
    temperatureRequirement: string | undefined;
    dosageForms: string | undefined;
    producingArea: string | undefined;
    manufacturer: string | undefined;
    classification: string | undefined;
    firstState: boolean | undefined;
    isImported: boolean | undefined;
    isDrugs: boolean | undefined;
    category: string | undefined;
    categoryName: string | undefined;
    unit: string | undefined;
    includeBattery: string | undefined;
    packageUnit: string | undefined;
    materialGroup: string | undefined;
    materialClass: string | undefined;
    costPrice: number | undefined;
    tagPrice: number | undefined;
    retailPrice: number | undefined;
    purchasePrice: number | undefined;
    innerLength: number | undefined;
    innerWidth: number | undefined;
    innerHeight: number | undefined;
    loadbearing: number | undefined;
    materialType: number | undefined;
    isStandardCarton: boolean | undefined;
    isStandard: boolean | undefined;
    isUnifiedAllWh: boolean | undefined;
    isUnifiedAllWhCarton: boolean | undefined;
    needMeasureImage: boolean | undefined;
    needMeasureImageCarton: boolean | undefined;
    fifoMgt: boolean | undefined;
    picture: string | undefined;
    grayFlag: string | undefined;
    isCustomsDeclaration: boolean | undefined;
    isInspectionDeclaration: boolean | undefined;
    innerVolumeExtra: string | undefined;
    tags: number[] | undefined;

    constructor(data?: IQueryItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemId = data["itemId"];
            this.itemCode = data["itemCode"];
            this.version = data["version"];
            this.itemName = data["itemName"];
            this.providerTpId = data["providerTpId"];
            this.barCode = data["barCode"];
            this.type = data["type"];
            this.brand = data["brand"];
            this.brandName = data["brandName"];
            this.specification = data["specification"];
            this.color = data["color"];
            this.size = data["size"];
            this.approvalNumber = data["approvalNumber"];
            this.grossWeight = data["grossWeight"];
            this.netWeight = data["netWeight"];
            this.length = data["length"];
            this.width = data["width"];
            this.height = data["height"];
            this.volume = data["volume"];
            this.pcs = data["pcs"];
            this.isShelflife = data["isShelflife"];
            this.lifecycle = data["lifecycle"];
            this.rejectLifecycle = data["rejectLifecycle"];
            this.lockupLifecycle = data["lockupLifecycle"];
            this.adventLifecycle = data["adventLifecycle"];
            this.isSnMgt = data["isSnMgt"];
            this.isHygroscopic = data["isHygroscopic"];
            this.isDanger = data["isDanger"];
            this.snMode = data["snMode"];
            this.packagingScheme = data["packagingScheme"];
            this.isProduceCodeMgt = data["isProduceCodeMgt"];
            this.cartonLength = data["cartonLength"];
            this.cartonWidth = data["cartonWidth"];
            this.cartonHeight = data["cartonHeight"];
            this.cartonWeight = data["cartonWeight"];
            this.cartonVolume = data["cartonVolume"];
            this.isPoMgt = data["isPoMgt"];
            this.isPrecious = data["isPrecious"];
            this.temperatureRequirement = data["temperatureRequirement"];
            this.dosageForms = data["dosageForms"];
            this.producingArea = data["producingArea"];
            this.manufacturer = data["manufacturer"];
            this.classification = data["classification"];
            this.firstState = data["firstState"];
            this.isImported = data["isImported"];
            this.isDrugs = data["isDrugs"];
            this.category = data["category"];
            this.categoryName = data["categoryName"];
            this.unit = data["unit"];
            this.includeBattery = data["includeBattery"];
            this.packageUnit = data["packageUnit"];
            this.materialGroup = data["materialGroup"];
            this.materialClass = data["materialClass"];
            this.costPrice = data["costPrice"];
            this.tagPrice = data["tagPrice"];
            this.retailPrice = data["retailPrice"];
            this.purchasePrice = data["purchasePrice"];
            this.innerLength = data["innerLength"];
            this.innerWidth = data["innerWidth"];
            this.innerHeight = data["innerHeight"];
            this.loadbearing = data["loadbearing"];
            this.materialType = data["materialType"];
            this.isStandardCarton = data["isStandardCarton"];
            this.isStandard = data["isStandard"];
            this.isUnifiedAllWh = data["isUnifiedAllWh"];
            this.isUnifiedAllWhCarton = data["isUnifiedAllWhCarton"];
            this.needMeasureImage = data["needMeasureImage"];
            this.needMeasureImageCarton = data["needMeasureImageCarton"];
            this.fifoMgt = data["fifoMgt"];
            this.picture = data["picture"];
            this.grayFlag = data["grayFlag"];
            this.isCustomsDeclaration = data["isCustomsDeclaration"];
            this.isInspectionDeclaration = data["isInspectionDeclaration"];
            this.innerVolumeExtra = data["innerVolumeExtra"];
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(item);
            }
        }
    }

    static fromJS(data: any): QueryItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new QueryItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemId"] = this.itemId;
        data["itemCode"] = this.itemCode;
        data["version"] = this.version;
        data["itemName"] = this.itemName;
        data["providerTpId"] = this.providerTpId;
        data["barCode"] = this.barCode;
        data["type"] = this.type;
        data["brand"] = this.brand;
        data["brandName"] = this.brandName;
        data["specification"] = this.specification;
        data["color"] = this.color;
        data["size"] = this.size;
        data["approvalNumber"] = this.approvalNumber;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["length"] = this.length;
        data["width"] = this.width;
        data["height"] = this.height;
        data["volume"] = this.volume;
        data["pcs"] = this.pcs;
        data["isShelflife"] = this.isShelflife;
        data["lifecycle"] = this.lifecycle;
        data["rejectLifecycle"] = this.rejectLifecycle;
        data["lockupLifecycle"] = this.lockupLifecycle;
        data["adventLifecycle"] = this.adventLifecycle;
        data["isSnMgt"] = this.isSnMgt;
        data["isHygroscopic"] = this.isHygroscopic;
        data["isDanger"] = this.isDanger;
        data["snMode"] = this.snMode;
        data["packagingScheme"] = this.packagingScheme;
        data["isProduceCodeMgt"] = this.isProduceCodeMgt;
        data["cartonLength"] = this.cartonLength;
        data["cartonWidth"] = this.cartonWidth;
        data["cartonHeight"] = this.cartonHeight;
        data["cartonWeight"] = this.cartonWeight;
        data["cartonVolume"] = this.cartonVolume;
        data["isPoMgt"] = this.isPoMgt;
        data["isPrecious"] = this.isPrecious;
        data["temperatureRequirement"] = this.temperatureRequirement;
        data["dosageForms"] = this.dosageForms;
        data["producingArea"] = this.producingArea;
        data["manufacturer"] = this.manufacturer;
        data["classification"] = this.classification;
        data["firstState"] = this.firstState;
        data["isImported"] = this.isImported;
        data["isDrugs"] = this.isDrugs;
        data["category"] = this.category;
        data["categoryName"] = this.categoryName;
        data["unit"] = this.unit;
        data["includeBattery"] = this.includeBattery;
        data["packageUnit"] = this.packageUnit;
        data["materialGroup"] = this.materialGroup;
        data["materialClass"] = this.materialClass;
        data["costPrice"] = this.costPrice;
        data["tagPrice"] = this.tagPrice;
        data["retailPrice"] = this.retailPrice;
        data["purchasePrice"] = this.purchasePrice;
        data["innerLength"] = this.innerLength;
        data["innerWidth"] = this.innerWidth;
        data["innerHeight"] = this.innerHeight;
        data["loadbearing"] = this.loadbearing;
        data["materialType"] = this.materialType;
        data["isStandardCarton"] = this.isStandardCarton;
        data["isStandard"] = this.isStandard;
        data["isUnifiedAllWh"] = this.isUnifiedAllWh;
        data["isUnifiedAllWhCarton"] = this.isUnifiedAllWhCarton;
        data["needMeasureImage"] = this.needMeasureImage;
        data["needMeasureImageCarton"] = this.needMeasureImageCarton;
        data["fifoMgt"] = this.fifoMgt;
        data["picture"] = this.picture;
        data["grayFlag"] = this.grayFlag;
        data["isCustomsDeclaration"] = this.isCustomsDeclaration;
        data["isInspectionDeclaration"] = this.isInspectionDeclaration;
        data["innerVolumeExtra"] = this.innerVolumeExtra;
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data; 
    }
}

export interface IQueryItemDto {
    itemId: number | undefined;
    itemCode: string;
    version: number | undefined;
    itemName: string | undefined;
    providerTpId: number | undefined;
    barCode: string | undefined;
    type: string;
    brand: string | undefined;
    brandName: string | undefined;
    specification: string | undefined;
    color: string | undefined;
    size: string | undefined;
    approvalNumber: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    length: number | undefined;
    width: number | undefined;
    height: number | undefined;
    volume: number | undefined;
    pcs: number | undefined;
    isShelflife: boolean | undefined;
    lifecycle: number | undefined;
    rejectLifecycle: number | undefined;
    lockupLifecycle: number | undefined;
    adventLifecycle: number | undefined;
    isSnMgt: boolean | undefined;
    isHygroscopic: boolean | undefined;
    isDanger: boolean | undefined;
    snMode: string | undefined;
    packagingScheme: string | undefined;
    isProduceCodeMgt: boolean | undefined;
    cartonLength: number | undefined;
    cartonWidth: number | undefined;
    cartonHeight: number | undefined;
    cartonWeight: number | undefined;
    cartonVolume: number | undefined;
    isPoMgt: boolean | undefined;
    isPrecious: boolean | undefined;
    temperatureRequirement: string | undefined;
    dosageForms: string | undefined;
    producingArea: string | undefined;
    manufacturer: string | undefined;
    classification: string | undefined;
    firstState: boolean | undefined;
    isImported: boolean | undefined;
    isDrugs: boolean | undefined;
    category: string | undefined;
    categoryName: string | undefined;
    unit: string | undefined;
    includeBattery: string | undefined;
    packageUnit: string | undefined;
    materialGroup: string | undefined;
    materialClass: string | undefined;
    costPrice: number | undefined;
    tagPrice: number | undefined;
    retailPrice: number | undefined;
    purchasePrice: number | undefined;
    innerLength: number | undefined;
    innerWidth: number | undefined;
    innerHeight: number | undefined;
    loadbearing: number | undefined;
    materialType: number | undefined;
    isStandardCarton: boolean | undefined;
    isStandard: boolean | undefined;
    isUnifiedAllWh: boolean | undefined;
    isUnifiedAllWhCarton: boolean | undefined;
    needMeasureImage: boolean | undefined;
    needMeasureImageCarton: boolean | undefined;
    fifoMgt: boolean | undefined;
    picture: string | undefined;
    grayFlag: string | undefined;
    isCustomsDeclaration: boolean | undefined;
    isInspectionDeclaration: boolean | undefined;
    innerVolumeExtra: string | undefined;
    tags: number[] | undefined;
}

export class OrderCancelNotifyInput implements IOrderCancelNotifyInput {
    ownerUserId: string;
    orderCode: string;
    storeCode: string;
    orderType: string;

    constructor(data?: IOrderCancelNotifyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerUserId = data["ownerUserId"];
            this.orderCode = data["orderCode"];
            this.storeCode = data["storeCode"];
            this.orderType = data["orderType"];
        }
    }

    static fromJS(data: any): OrderCancelNotifyInput {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCancelNotifyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerUserId"] = this.ownerUserId;
        data["orderCode"] = this.orderCode;
        data["storeCode"] = this.storeCode;
        data["orderType"] = this.orderType;
        return data; 
    }
}

export interface IOrderCancelNotifyInput {
    ownerUserId: string;
    orderCode: string;
    storeCode: string;
    orderType: string;
}

export class OrderCancelNotifyOutput implements IOrderCancelNotifyOutput {
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: IOrderCancelNotifyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): OrderCancelNotifyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new OrderCancelNotifyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface IOrderCancelNotifyOutput {
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class SkuInfoNotifyInput implements ISkuInfoNotifyInput {
    ownerUserId: string;
    itemId: string;
    itemCode: string;
    storeCode: string | undefined;
    name: string | undefined;
    barCode: string;
    goodsNo: string | undefined;
    actionType: string | undefined;
    itemVersion: number | undefined;
    type: string | undefined;
    category: string | undefined;
    categoryName: string | undefined;
    brand: string | undefined;
    brandName: string | undefined;
    specification: string | undefined;
    color: string | undefined;
    size: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    length: number | undefined;
    width: number | undefined;
    height: number | undefined;
    volume: number | undefined;
    pcs: number | undefined;
    approvalNumber: string | undefined;
    isShelflife: boolean | undefined;
    lifecycle: number | undefined;
    rejectLifecycle: number | undefined;
    lockupLifecycle: number | undefined;
    adventLifecycle: number | undefined;
    isSnMgt: boolean | undefined;
    isHygroscopic: boolean | undefined;
    isDanger: boolean | undefined;
    snMode: string | undefined;
    isPoMgt: boolean | undefined;
    isPrecious: boolean | undefined;
    temperatureRequirement: string | undefined;
    dosageForms: string | undefined;
    producingArea: string | undefined;
    manufacturer: string | undefined;
    classification: string | undefined;
    firstState: boolean | undefined;
    isImported: boolean | undefined;
    isDrugs: boolean | undefined;
    packagingScheme: string | undefined;
    currency: string | undefined;
    costPrice: number | undefined;
    tagPrice: number | undefined;
    retailPrice: number | undefined;
    purchasePrice: number | undefined;
    isProduceCodeMgt: boolean | undefined;
    unit: string | undefined;
    cartonLength: number | undefined;
    cartonWidth: number | undefined;
    cartonHeight: number | undefined;
    cartonWeight: number | undefined;
    cartonVolume: number | undefined;
    includeBattery: string | undefined;
    packageUnit: string | undefined;
    materialGroup: string | undefined;
    materialClass: string | undefined;
    isCustomsDeclaration: boolean | undefined;
    isCustomsDeclaratio: boolean | undefined;
    grayFlag: string | undefined;
    innerLength: number | undefined;
    innerWidth: number | undefined;
    innerHeight: number | undefined;
    loadbearing: number | undefined;
    materialType: number | undefined;
    picture: string | undefined;
    isStandardCarton: boolean | undefined;
    fifoMgt: boolean | undefined;
    innerVolumeExtra: string | undefined;
    isStandard: boolean | undefined;
    isUnifiedAllWh: boolean | undefined;
    isUnifiedAllWhCarton: boolean | undefined;
    needMeasureImage: boolean | undefined;
    needMeasureImageCarton: boolean | undefined;
    snSampleList: SnSample[] | undefined;
    tags: number[] | undefined;

    constructor(data?: ISkuInfoNotifyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerUserId = data["ownerUserId"];
            this.itemId = data["itemId"];
            this.itemCode = data["itemCode"];
            this.storeCode = data["storeCode"];
            this.name = data["name"];
            this.barCode = data["barCode"];
            this.goodsNo = data["goodsNo"];
            this.actionType = data["actionType"];
            this.itemVersion = data["itemVersion"];
            this.type = data["type"];
            this.category = data["category"];
            this.categoryName = data["categoryName"];
            this.brand = data["brand"];
            this.brandName = data["brandName"];
            this.specification = data["specification"];
            this.color = data["color"];
            this.size = data["size"];
            this.grossWeight = data["grossWeight"];
            this.netWeight = data["netWeight"];
            this.length = data["length"];
            this.width = data["width"];
            this.height = data["height"];
            this.volume = data["volume"];
            this.pcs = data["pcs"];
            this.approvalNumber = data["approvalNumber"];
            this.isShelflife = data["isShelflife"];
            this.lifecycle = data["lifecycle"];
            this.rejectLifecycle = data["rejectLifecycle"];
            this.lockupLifecycle = data["lockupLifecycle"];
            this.adventLifecycle = data["adventLifecycle"];
            this.isSnMgt = data["isSnMgt"];
            this.isHygroscopic = data["isHygroscopic"];
            this.isDanger = data["isDanger"];
            this.snMode = data["snMode"];
            this.isPoMgt = data["isPoMgt"];
            this.isPrecious = data["isPrecious"];
            this.temperatureRequirement = data["temperatureRequirement"];
            this.dosageForms = data["dosageForms"];
            this.producingArea = data["producingArea"];
            this.manufacturer = data["manufacturer"];
            this.classification = data["classification"];
            this.firstState = data["firstState"];
            this.isImported = data["isImported"];
            this.isDrugs = data["isDrugs"];
            this.packagingScheme = data["packagingScheme"];
            this.currency = data["currency"];
            this.costPrice = data["costPrice"];
            this.tagPrice = data["tagPrice"];
            this.retailPrice = data["retailPrice"];
            this.purchasePrice = data["purchasePrice"];
            this.isProduceCodeMgt = data["isProduceCodeMgt"];
            this.unit = data["unit"];
            this.cartonLength = data["cartonLength"];
            this.cartonWidth = data["cartonWidth"];
            this.cartonHeight = data["cartonHeight"];
            this.cartonWeight = data["cartonWeight"];
            this.cartonVolume = data["cartonVolume"];
            this.includeBattery = data["includeBattery"];
            this.packageUnit = data["packageUnit"];
            this.materialGroup = data["materialGroup"];
            this.materialClass = data["materialClass"];
            this.isCustomsDeclaration = data["isCustomsDeclaration"];
            this.isCustomsDeclaratio = data["isCustomsDeclaratio"];
            this.grayFlag = data["grayFlag"];
            this.innerLength = data["innerLength"];
            this.innerWidth = data["innerWidth"];
            this.innerHeight = data["innerHeight"];
            this.loadbearing = data["loadbearing"];
            this.materialType = data["materialType"];
            this.picture = data["picture"];
            this.isStandardCarton = data["isStandardCarton"];
            this.fifoMgt = data["fifoMgt"];
            this.innerVolumeExtra = data["innerVolumeExtra"];
            this.isStandard = data["isStandard"];
            this.isUnifiedAllWh = data["isUnifiedAllWh"];
            this.isUnifiedAllWhCarton = data["isUnifiedAllWhCarton"];
            this.needMeasureImage = data["needMeasureImage"];
            this.needMeasureImageCarton = data["needMeasureImageCarton"];
            if (data["snSampleList"] && data["snSampleList"].constructor === Array) {
                this.snSampleList = [];
                for (let item of data["snSampleList"])
                    this.snSampleList.push(SnSample.fromJS(item));
            }
            if (data["tags"] && data["tags"].constructor === Array) {
                this.tags = [];
                for (let item of data["tags"])
                    this.tags.push(item);
            }
        }
    }

    static fromJS(data: any): SkuInfoNotifyInput {
        data = typeof data === 'object' ? data : {};
        let result = new SkuInfoNotifyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerUserId"] = this.ownerUserId;
        data["itemId"] = this.itemId;
        data["itemCode"] = this.itemCode;
        data["storeCode"] = this.storeCode;
        data["name"] = this.name;
        data["barCode"] = this.barCode;
        data["goodsNo"] = this.goodsNo;
        data["actionType"] = this.actionType;
        data["itemVersion"] = this.itemVersion;
        data["type"] = this.type;
        data["category"] = this.category;
        data["categoryName"] = this.categoryName;
        data["brand"] = this.brand;
        data["brandName"] = this.brandName;
        data["specification"] = this.specification;
        data["color"] = this.color;
        data["size"] = this.size;
        data["grossWeight"] = this.grossWeight;
        data["netWeight"] = this.netWeight;
        data["length"] = this.length;
        data["width"] = this.width;
        data["height"] = this.height;
        data["volume"] = this.volume;
        data["pcs"] = this.pcs;
        data["approvalNumber"] = this.approvalNumber;
        data["isShelflife"] = this.isShelflife;
        data["lifecycle"] = this.lifecycle;
        data["rejectLifecycle"] = this.rejectLifecycle;
        data["lockupLifecycle"] = this.lockupLifecycle;
        data["adventLifecycle"] = this.adventLifecycle;
        data["isSnMgt"] = this.isSnMgt;
        data["isHygroscopic"] = this.isHygroscopic;
        data["isDanger"] = this.isDanger;
        data["snMode"] = this.snMode;
        data["isPoMgt"] = this.isPoMgt;
        data["isPrecious"] = this.isPrecious;
        data["temperatureRequirement"] = this.temperatureRequirement;
        data["dosageForms"] = this.dosageForms;
        data["producingArea"] = this.producingArea;
        data["manufacturer"] = this.manufacturer;
        data["classification"] = this.classification;
        data["firstState"] = this.firstState;
        data["isImported"] = this.isImported;
        data["isDrugs"] = this.isDrugs;
        data["packagingScheme"] = this.packagingScheme;
        data["currency"] = this.currency;
        data["costPrice"] = this.costPrice;
        data["tagPrice"] = this.tagPrice;
        data["retailPrice"] = this.retailPrice;
        data["purchasePrice"] = this.purchasePrice;
        data["isProduceCodeMgt"] = this.isProduceCodeMgt;
        data["unit"] = this.unit;
        data["cartonLength"] = this.cartonLength;
        data["cartonWidth"] = this.cartonWidth;
        data["cartonHeight"] = this.cartonHeight;
        data["cartonWeight"] = this.cartonWeight;
        data["cartonVolume"] = this.cartonVolume;
        data["includeBattery"] = this.includeBattery;
        data["packageUnit"] = this.packageUnit;
        data["materialGroup"] = this.materialGroup;
        data["materialClass"] = this.materialClass;
        data["isCustomsDeclaration"] = this.isCustomsDeclaration;
        data["isCustomsDeclaratio"] = this.isCustomsDeclaratio;
        data["grayFlag"] = this.grayFlag;
        data["innerLength"] = this.innerLength;
        data["innerWidth"] = this.innerWidth;
        data["innerHeight"] = this.innerHeight;
        data["loadbearing"] = this.loadbearing;
        data["materialType"] = this.materialType;
        data["picture"] = this.picture;
        data["isStandardCarton"] = this.isStandardCarton;
        data["fifoMgt"] = this.fifoMgt;
        data["innerVolumeExtra"] = this.innerVolumeExtra;
        data["isStandard"] = this.isStandard;
        data["isUnifiedAllWh"] = this.isUnifiedAllWh;
        data["isUnifiedAllWhCarton"] = this.isUnifiedAllWhCarton;
        data["needMeasureImage"] = this.needMeasureImage;
        data["needMeasureImageCarton"] = this.needMeasureImageCarton;
        if (this.snSampleList && this.snSampleList.constructor === Array) {
            data["snSampleList"] = [];
            for (let item of this.snSampleList)
                data["snSampleList"].push(item.toJSON());
        }
        if (this.tags && this.tags.constructor === Array) {
            data["tags"] = [];
            for (let item of this.tags)
                data["tags"].push(item);
        }
        return data; 
    }
}

export interface ISkuInfoNotifyInput {
    ownerUserId: string;
    itemId: string;
    itemCode: string;
    storeCode: string | undefined;
    name: string | undefined;
    barCode: string;
    goodsNo: string | undefined;
    actionType: string | undefined;
    itemVersion: number | undefined;
    type: string | undefined;
    category: string | undefined;
    categoryName: string | undefined;
    brand: string | undefined;
    brandName: string | undefined;
    specification: string | undefined;
    color: string | undefined;
    size: string | undefined;
    grossWeight: number | undefined;
    netWeight: number | undefined;
    length: number | undefined;
    width: number | undefined;
    height: number | undefined;
    volume: number | undefined;
    pcs: number | undefined;
    approvalNumber: string | undefined;
    isShelflife: boolean | undefined;
    lifecycle: number | undefined;
    rejectLifecycle: number | undefined;
    lockupLifecycle: number | undefined;
    adventLifecycle: number | undefined;
    isSnMgt: boolean | undefined;
    isHygroscopic: boolean | undefined;
    isDanger: boolean | undefined;
    snMode: string | undefined;
    isPoMgt: boolean | undefined;
    isPrecious: boolean | undefined;
    temperatureRequirement: string | undefined;
    dosageForms: string | undefined;
    producingArea: string | undefined;
    manufacturer: string | undefined;
    classification: string | undefined;
    firstState: boolean | undefined;
    isImported: boolean | undefined;
    isDrugs: boolean | undefined;
    packagingScheme: string | undefined;
    currency: string | undefined;
    costPrice: number | undefined;
    tagPrice: number | undefined;
    retailPrice: number | undefined;
    purchasePrice: number | undefined;
    isProduceCodeMgt: boolean | undefined;
    unit: string | undefined;
    cartonLength: number | undefined;
    cartonWidth: number | undefined;
    cartonHeight: number | undefined;
    cartonWeight: number | undefined;
    cartonVolume: number | undefined;
    includeBattery: string | undefined;
    packageUnit: string | undefined;
    materialGroup: string | undefined;
    materialClass: string | undefined;
    isCustomsDeclaration: boolean | undefined;
    isCustomsDeclaratio: boolean | undefined;
    grayFlag: string | undefined;
    innerLength: number | undefined;
    innerWidth: number | undefined;
    innerHeight: number | undefined;
    loadbearing: number | undefined;
    materialType: number | undefined;
    picture: string | undefined;
    isStandardCarton: boolean | undefined;
    fifoMgt: boolean | undefined;
    innerVolumeExtra: string | undefined;
    isStandard: boolean | undefined;
    isUnifiedAllWh: boolean | undefined;
    isUnifiedAllWhCarton: boolean | undefined;
    needMeasureImage: boolean | undefined;
    needMeasureImageCarton: boolean | undefined;
    snSampleList: SnSample[] | undefined;
    tags: number[] | undefined;
}

export class SnSample implements ISnSample {
    sampleSeq: string;
    sampleDesc: string | undefined;
    sampleRuleList: SampleRule[];

    constructor(data?: ISnSample) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sampleRuleList = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.sampleSeq = data["sampleSeq"];
            this.sampleDesc = data["sampleDesc"];
            if (data["sampleRuleList"] && data["sampleRuleList"].constructor === Array) {
                this.sampleRuleList = [];
                for (let item of data["sampleRuleList"])
                    this.sampleRuleList.push(SampleRule.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SnSample {
        data = typeof data === 'object' ? data : {};
        let result = new SnSample();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sampleSeq"] = this.sampleSeq;
        data["sampleDesc"] = this.sampleDesc;
        if (this.sampleRuleList && this.sampleRuleList.constructor === Array) {
            data["sampleRuleList"] = [];
            for (let item of this.sampleRuleList)
                data["sampleRuleList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISnSample {
    sampleSeq: string;
    sampleDesc: string | undefined;
    sampleRuleList: SampleRule[];
}

export class SampleRule implements ISampleRule {
    ruleDesc: string;
    ruleRegularExpression: string;
    ruleImgUrl: string;
    ruleSample: string;

    constructor(data?: ISampleRule) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ruleDesc = data["ruleDesc"];
            this.ruleRegularExpression = data["ruleRegularExpression"];
            this.ruleImgUrl = data["ruleImgUrl"];
            this.ruleSample = data["ruleSample"];
        }
    }

    static fromJS(data: any): SampleRule {
        data = typeof data === 'object' ? data : {};
        let result = new SampleRule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleDesc"] = this.ruleDesc;
        data["ruleRegularExpression"] = this.ruleRegularExpression;
        data["ruleImgUrl"] = this.ruleImgUrl;
        data["ruleSample"] = this.ruleSample;
        return data; 
    }
}

export interface ISampleRule {
    ruleDesc: string;
    ruleRegularExpression: string;
    ruleImgUrl: string;
    ruleSample: string;
}

export class SkuInfoNotifyOuput implements ISkuInfoNotifyOuput {
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: ISkuInfoNotifyOuput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): SkuInfoNotifyOuput {
        data = typeof data === 'object' ? data : {};
        let result = new SkuInfoNotifyOuput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface ISkuInfoNotifyOuput {
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class StockInOrderNotifyInput implements IStockInOrderNotifyInput {
    ownerUserId: string;
    ownerUserName: string | undefined;
    storeCode: string;
    orderCode: string;
    erpOrderCode: string | undefined;
    orderType: number | undefined;
    inboundTypeDesc: string | undefined;
    oerderFlag: string | undefined;
    orderSource: number | undefined;
    orderCreateTime: moment.Moment | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    tmsServiceCode: string | undefined;
    tmsServiceName: string | undefined;
    tmsOrderCode: string | undefined;
    prevORderCode: string | undefined;
    prevErpOrderCode: string | undefined;
    returnReason: string | undefined;
    buyerNick: string | undefined;
    remark: string | undefined;
    bizType: string | undefined;
    appointmentCode: string | undefined;
    batchSendCtrlParam: BatchSendCtrlParam | undefined;
    senderInfo: StockInSenderInfo | undefined;
    orderItemList: WmsStockInOrderItem[] | undefined;
    driverInfo: StockInDriverInfo | undefined;
    caseInfoList: WmsStockInCaseInfo[] | undefined;

    constructor(data?: IStockInOrderNotifyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerUserId = data["ownerUserId"];
            this.ownerUserName = data["ownerUserName"];
            this.storeCode = data["storeCode"];
            this.orderCode = data["orderCode"];
            this.erpOrderCode = data["erpOrderCode"];
            this.orderType = data["orderType"];
            this.inboundTypeDesc = data["inboundTypeDesc"];
            this.oerderFlag = data["oerderFlag"];
            this.orderSource = data["orderSource"];
            this.orderCreateTime = data["orderCreateTime"] ? moment(data["orderCreateTime"].toString()) : <any>undefined;
            this.supplierCode = data["supplierCode"];
            this.supplierName = data["supplierName"];
            this.tmsServiceCode = data["tmsServiceCode"];
            this.tmsServiceName = data["tmsServiceName"];
            this.tmsOrderCode = data["tmsOrderCode"];
            this.prevORderCode = data["prevORderCode"];
            this.prevErpOrderCode = data["prevErpOrderCode"];
            this.returnReason = data["returnReason"];
            this.buyerNick = data["buyerNick"];
            this.remark = data["remark"];
            this.bizType = data["bizType"];
            this.appointmentCode = data["appointmentCode"];
            this.batchSendCtrlParam = data["batchSendCtrlParam"] ? BatchSendCtrlParam.fromJS(data["batchSendCtrlParam"]) : <any>undefined;
            this.senderInfo = data["senderInfo"] ? StockInSenderInfo.fromJS(data["senderInfo"]) : <any>undefined;
            if (data["orderItemList"] && data["orderItemList"].constructor === Array) {
                this.orderItemList = [];
                for (let item of data["orderItemList"])
                    this.orderItemList.push(WmsStockInOrderItem.fromJS(item));
            }
            this.driverInfo = data["driverInfo"] ? StockInDriverInfo.fromJS(data["driverInfo"]) : <any>undefined;
            if (data["caseInfoList"] && data["caseInfoList"].constructor === Array) {
                this.caseInfoList = [];
                for (let item of data["caseInfoList"])
                    this.caseInfoList.push(WmsStockInCaseInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StockInOrderNotifyInput {
        data = typeof data === 'object' ? data : {};
        let result = new StockInOrderNotifyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerUserId"] = this.ownerUserId;
        data["ownerUserName"] = this.ownerUserName;
        data["storeCode"] = this.storeCode;
        data["orderCode"] = this.orderCode;
        data["erpOrderCode"] = this.erpOrderCode;
        data["orderType"] = this.orderType;
        data["inboundTypeDesc"] = this.inboundTypeDesc;
        data["oerderFlag"] = this.oerderFlag;
        data["orderSource"] = this.orderSource;
        data["orderCreateTime"] = this.orderCreateTime ? this.orderCreateTime.toISOString() : <any>undefined;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["tmsServiceCode"] = this.tmsServiceCode;
        data["tmsServiceName"] = this.tmsServiceName;
        data["tmsOrderCode"] = this.tmsOrderCode;
        data["prevORderCode"] = this.prevORderCode;
        data["prevErpOrderCode"] = this.prevErpOrderCode;
        data["returnReason"] = this.returnReason;
        data["buyerNick"] = this.buyerNick;
        data["remark"] = this.remark;
        data["bizType"] = this.bizType;
        data["appointmentCode"] = this.appointmentCode;
        data["batchSendCtrlParam"] = this.batchSendCtrlParam ? this.batchSendCtrlParam.toJSON() : <any>undefined;
        data["senderInfo"] = this.senderInfo ? this.senderInfo.toJSON() : <any>undefined;
        if (this.orderItemList && this.orderItemList.constructor === Array) {
            data["orderItemList"] = [];
            for (let item of this.orderItemList)
                data["orderItemList"].push(item.toJSON());
        }
        data["driverInfo"] = this.driverInfo ? this.driverInfo.toJSON() : <any>undefined;
        if (this.caseInfoList && this.caseInfoList.constructor === Array) {
            data["caseInfoList"] = [];
            for (let item of this.caseInfoList)
                data["caseInfoList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStockInOrderNotifyInput {
    ownerUserId: string;
    ownerUserName: string | undefined;
    storeCode: string;
    orderCode: string;
    erpOrderCode: string | undefined;
    orderType: number | undefined;
    inboundTypeDesc: string | undefined;
    oerderFlag: string | undefined;
    orderSource: number | undefined;
    orderCreateTime: moment.Moment | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    tmsServiceCode: string | undefined;
    tmsServiceName: string | undefined;
    tmsOrderCode: string | undefined;
    prevORderCode: string | undefined;
    prevErpOrderCode: string | undefined;
    returnReason: string | undefined;
    buyerNick: string | undefined;
    remark: string | undefined;
    bizType: string | undefined;
    appointmentCode: string | undefined;
    batchSendCtrlParam: BatchSendCtrlParam | undefined;
    senderInfo: StockInSenderInfo | undefined;
    orderItemList: WmsStockInOrderItem[] | undefined;
    driverInfo: StockInDriverInfo | undefined;
    caseInfoList: WmsStockInCaseInfo[] | undefined;
}

export class BatchSendCtrlParam implements IBatchSendCtrlParam {
    totalOrderItemCount: number | undefined;
    distributeType: number | undefined;

    constructor(data?: IBatchSendCtrlParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalOrderItemCount = data["totalOrderItemCount"];
            this.distributeType = data["distributeType"];
        }
    }

    static fromJS(data: any): BatchSendCtrlParam {
        data = typeof data === 'object' ? data : {};
        let result = new BatchSendCtrlParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalOrderItemCount"] = this.totalOrderItemCount;
        data["distributeType"] = this.distributeType;
        return data; 
    }
}

export interface IBatchSendCtrlParam {
    totalOrderItemCount: number | undefined;
    distributeType: number | undefined;
}

export class StockInSenderInfo implements IStockInSenderInfo {
    senderZipCode: string | undefined;
    senderCountry: string | undefined;
    senderProvince: string | undefined;
    senderCity: string | undefined;
    senderArea: string | undefined;
    senderTown: string | undefined;
    sendAddress: string | undefined;
    senderName: string | undefined;
    senderMobile: string | undefined;
    senderPhone: string | undefined;
    senderDivisionld: string | undefined;
    senderEmail: string | undefined;

    constructor(data?: IStockInSenderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.senderZipCode = data["senderZipCode"];
            this.senderCountry = data["senderCountry"];
            this.senderProvince = data["senderProvince"];
            this.senderCity = data["senderCity"];
            this.senderArea = data["senderArea"];
            this.senderTown = data["senderTown"];
            this.sendAddress = data["sendAddress"];
            this.senderName = data["senderName"];
            this.senderMobile = data["senderMobile"];
            this.senderPhone = data["senderPhone"];
            this.senderDivisionld = data["senderDivisionld"];
            this.senderEmail = data["senderEmail"];
        }
    }

    static fromJS(data: any): StockInSenderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new StockInSenderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderZipCode"] = this.senderZipCode;
        data["senderCountry"] = this.senderCountry;
        data["senderProvince"] = this.senderProvince;
        data["senderCity"] = this.senderCity;
        data["senderArea"] = this.senderArea;
        data["senderTown"] = this.senderTown;
        data["sendAddress"] = this.sendAddress;
        data["senderName"] = this.senderName;
        data["senderMobile"] = this.senderMobile;
        data["senderPhone"] = this.senderPhone;
        data["senderDivisionld"] = this.senderDivisionld;
        data["senderEmail"] = this.senderEmail;
        return data; 
    }
}

export interface IStockInSenderInfo {
    senderZipCode: string | undefined;
    senderCountry: string | undefined;
    senderProvince: string | undefined;
    senderCity: string | undefined;
    senderArea: string | undefined;
    senderTown: string | undefined;
    sendAddress: string | undefined;
    senderName: string | undefined;
    senderMobile: string | undefined;
    senderPhone: string | undefined;
    senderDivisionld: string | undefined;
    senderEmail: string | undefined;
}

export class WmsStockInOrderItem implements IWmsStockInOrderItem {
    orderItemId: string;
    orderSourceCode: string | undefined;
    subSourceCode: string | undefined;
    ownerUserId: string;
    itemId: string;
    itemName: string;
    itemCode: string;
    barCode: string | undefined;
    inventoryType: number | undefined;
    itemQuantity: number | undefined;
    purchasePrice: number | undefined;
    taxRate: number | undefined;
    itemVersion: number | undefined;
    batchCode: string | undefined;
    purchaseOrderCode: string | undefined;
    dueDate: moment.Moment | undefined;
    produceDate: moment.Moment | undefined;
    produceCode: string | undefined;
    batchRemark: string | undefined;
    expireForbidLeads: number | undefined;

    constructor(data?: IWmsStockInOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderItemId = data["orderItemId"];
            this.orderSourceCode = data["orderSourceCode"];
            this.subSourceCode = data["subSourceCode"];
            this.ownerUserId = data["ownerUserId"];
            this.itemId = data["itemId"];
            this.itemName = data["itemName"];
            this.itemCode = data["itemCode"];
            this.barCode = data["barCode"];
            this.inventoryType = data["inventoryType"];
            this.itemQuantity = data["itemQuantity"];
            this.purchasePrice = data["purchasePrice"];
            this.taxRate = data["taxRate"];
            this.itemVersion = data["itemVersion"];
            this.batchCode = data["batchCode"];
            this.purchaseOrderCode = data["purchaseOrderCode"];
            this.dueDate = data["dueDate"] ? moment(data["dueDate"].toString()) : <any>undefined;
            this.produceDate = data["produceDate"] ? moment(data["produceDate"].toString()) : <any>undefined;
            this.produceCode = data["produceCode"];
            this.batchRemark = data["batchRemark"];
            this.expireForbidLeads = data["expireForbidLeads"];
        }
    }

    static fromJS(data: any): WmsStockInOrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new WmsStockInOrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderItemId"] = this.orderItemId;
        data["orderSourceCode"] = this.orderSourceCode;
        data["subSourceCode"] = this.subSourceCode;
        data["ownerUserId"] = this.ownerUserId;
        data["itemId"] = this.itemId;
        data["itemName"] = this.itemName;
        data["itemCode"] = this.itemCode;
        data["barCode"] = this.barCode;
        data["inventoryType"] = this.inventoryType;
        data["itemQuantity"] = this.itemQuantity;
        data["purchasePrice"] = this.purchasePrice;
        data["taxRate"] = this.taxRate;
        data["itemVersion"] = this.itemVersion;
        data["batchCode"] = this.batchCode;
        data["purchaseOrderCode"] = this.purchaseOrderCode;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["produceDate"] = this.produceDate ? this.produceDate.toISOString() : <any>undefined;
        data["produceCode"] = this.produceCode;
        data["batchRemark"] = this.batchRemark;
        data["expireForbidLeads"] = this.expireForbidLeads;
        return data; 
    }
}

export interface IWmsStockInOrderItem {
    orderItemId: string;
    orderSourceCode: string | undefined;
    subSourceCode: string | undefined;
    ownerUserId: string;
    itemId: string;
    itemName: string;
    itemCode: string;
    barCode: string | undefined;
    inventoryType: number | undefined;
    itemQuantity: number | undefined;
    purchasePrice: number | undefined;
    taxRate: number | undefined;
    itemVersion: number | undefined;
    batchCode: string | undefined;
    purchaseOrderCode: string | undefined;
    dueDate: moment.Moment | undefined;
    produceDate: moment.Moment | undefined;
    produceCode: string | undefined;
    batchRemark: string | undefined;
    expireForbidLeads: number | undefined;
}

export class StockInDriverInfo implements IStockInDriverInfo {
    driverName: string | undefined;
    driverdentityld: string | undefined;
    driverPhone: string | undefined;
    vehicleType: string | undefined;
    vehicleLoad: string | undefined;
    licensePlate: string | undefined;

    constructor(data?: IStockInDriverInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.driverName = data["driverName"];
            this.driverdentityld = data["driverdentityld"];
            this.driverPhone = data["driverPhone"];
            this.vehicleType = data["vehicleType"];
            this.vehicleLoad = data["vehicleLoad"];
            this.licensePlate = data["licensePlate"];
        }
    }

    static fromJS(data: any): StockInDriverInfo {
        data = typeof data === 'object' ? data : {};
        let result = new StockInDriverInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["driverName"] = this.driverName;
        data["driverdentityld"] = this.driverdentityld;
        data["driverPhone"] = this.driverPhone;
        data["vehicleType"] = this.vehicleType;
        data["vehicleLoad"] = this.vehicleLoad;
        data["licensePlate"] = this.licensePlate;
        return data; 
    }
}

export interface IStockInDriverInfo {
    driverName: string | undefined;
    driverdentityld: string | undefined;
    driverPhone: string | undefined;
    vehicleType: string | undefined;
    vehicleLoad: string | undefined;
    licensePlate: string | undefined;
}

export class WmsStockInCaseInfo implements IWmsStockInCaseInfo {
    caseNumber: string | undefined;
    caseSequence: string | undefined;
    palletNumebr: string | undefined;
    conainerNumber: string | undefined;
    weight: number | undefined;
    volume: number | undefined;
    length: number | undefined;
    width: number | undefined;
    heitht: number | undefined;

    constructor(data?: IWmsStockInCaseInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.caseNumber = data["caseNumber"];
            this.caseSequence = data["caseSequence"];
            this.palletNumebr = data["palletNumebr"];
            this.conainerNumber = data["conainerNumber"];
            this.weight = data["weight"];
            this.volume = data["volume"];
            this.length = data["length"];
            this.width = data["width"];
            this.heitht = data["heitht"];
        }
    }

    static fromJS(data: any): WmsStockInCaseInfo {
        data = typeof data === 'object' ? data : {};
        let result = new WmsStockInCaseInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["caseNumber"] = this.caseNumber;
        data["caseSequence"] = this.caseSequence;
        data["palletNumebr"] = this.palletNumebr;
        data["conainerNumber"] = this.conainerNumber;
        data["weight"] = this.weight;
        data["volume"] = this.volume;
        data["length"] = this.length;
        data["width"] = this.width;
        data["heitht"] = this.heitht;
        return data; 
    }
}

export interface IWmsStockInCaseInfo {
    caseNumber: string | undefined;
    caseSequence: string | undefined;
    palletNumebr: string | undefined;
    conainerNumber: string | undefined;
    weight: number | undefined;
    volume: number | undefined;
    length: number | undefined;
    width: number | undefined;
    heitht: number | undefined;
}

export class StockInOrderNotifyOutput implements IStockInOrderNotifyOutput {
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: IStockInOrderNotifyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): StockInOrderNotifyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StockInOrderNotifyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface IStockInOrderNotifyOutput {
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export class StockOutOrderNotifyInput implements IStockOutOrderNotifyInput {
    ownerUserId: string;
    ownerUserName: string | undefined;
    pickCompany: string | undefined;
    pickName: string | undefined;
    pickCall: string | undefined;
    carriersName: string | undefined;
    pickId: string | undefined;
    storeCode: string;
    toStoreCode: string | undefined;
    orderCode: string;
    erpOrderCode: string | undefined;
    orderType: number | undefined;
    outboundTypeDesc: string | undefined;
    orderFlag: string | undefined;
    orderCreateTime: moment.Moment | undefined;
    sendTime: moment.Moment | undefined;
    tmsServiceCode: string | undefined;
    tmsServiceName: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    transportMode: string | undefined;
    carNo: string | undefined;
    timeZone: string | undefined;
    currency: string | undefined;
    remark: string | undefined;
    bizType: string | undefined;
    transferPriority: string | undefined;
    batchSendCtrlParam: StockOutBatchSendCtrlParam | undefined;
    receiverInfo: StockOutReceiverInfo | undefined;
    senderInfo: StockOutSenderInfo | undefined;
    orderItemList: WmsStockOutOrderItem[] | undefined;
    driverInfo: StockOutDriverInfo | undefined;

    constructor(data?: IStockOutOrderNotifyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ownerUserId = data["ownerUserId"];
            this.ownerUserName = data["ownerUserName"];
            this.pickCompany = data["pickCompany"];
            this.pickName = data["pickName"];
            this.pickCall = data["pickCall"];
            this.carriersName = data["carriersName"];
            this.pickId = data["pickId"];
            this.storeCode = data["storeCode"];
            this.toStoreCode = data["toStoreCode"];
            this.orderCode = data["orderCode"];
            this.erpOrderCode = data["erpOrderCode"];
            this.orderType = data["orderType"];
            this.outboundTypeDesc = data["outboundTypeDesc"];
            this.orderFlag = data["orderFlag"];
            this.orderCreateTime = data["orderCreateTime"] ? moment(data["orderCreateTime"].toString()) : <any>undefined;
            this.sendTime = data["sendTime"] ? moment(data["sendTime"].toString()) : <any>undefined;
            this.tmsServiceCode = data["tmsServiceCode"];
            this.tmsServiceName = data["tmsServiceName"];
            this.supplierCode = data["supplierCode"];
            this.supplierName = data["supplierName"];
            this.transportMode = data["transportMode"];
            this.carNo = data["carNo"];
            this.timeZone = data["timeZone"];
            this.currency = data["currency"];
            this.remark = data["remark"];
            this.bizType = data["bizType"];
            this.transferPriority = data["transferPriority"];
            this.batchSendCtrlParam = data["batchSendCtrlParam"] ? StockOutBatchSendCtrlParam.fromJS(data["batchSendCtrlParam"]) : <any>undefined;
            this.receiverInfo = data["receiverInfo"] ? StockOutReceiverInfo.fromJS(data["receiverInfo"]) : <any>undefined;
            this.senderInfo = data["senderInfo"] ? StockOutSenderInfo.fromJS(data["senderInfo"]) : <any>undefined;
            if (data["orderItemList"] && data["orderItemList"].constructor === Array) {
                this.orderItemList = [];
                for (let item of data["orderItemList"])
                    this.orderItemList.push(WmsStockOutOrderItem.fromJS(item));
            }
            this.driverInfo = data["driverInfo"] ? StockOutDriverInfo.fromJS(data["driverInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): StockOutOrderNotifyInput {
        data = typeof data === 'object' ? data : {};
        let result = new StockOutOrderNotifyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ownerUserId"] = this.ownerUserId;
        data["ownerUserName"] = this.ownerUserName;
        data["pickCompany"] = this.pickCompany;
        data["pickName"] = this.pickName;
        data["pickCall"] = this.pickCall;
        data["carriersName"] = this.carriersName;
        data["pickId"] = this.pickId;
        data["storeCode"] = this.storeCode;
        data["toStoreCode"] = this.toStoreCode;
        data["orderCode"] = this.orderCode;
        data["erpOrderCode"] = this.erpOrderCode;
        data["orderType"] = this.orderType;
        data["outboundTypeDesc"] = this.outboundTypeDesc;
        data["orderFlag"] = this.orderFlag;
        data["orderCreateTime"] = this.orderCreateTime ? this.orderCreateTime.toISOString() : <any>undefined;
        data["sendTime"] = this.sendTime ? this.sendTime.toISOString() : <any>undefined;
        data["tmsServiceCode"] = this.tmsServiceCode;
        data["tmsServiceName"] = this.tmsServiceName;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["transportMode"] = this.transportMode;
        data["carNo"] = this.carNo;
        data["timeZone"] = this.timeZone;
        data["currency"] = this.currency;
        data["remark"] = this.remark;
        data["bizType"] = this.bizType;
        data["transferPriority"] = this.transferPriority;
        data["batchSendCtrlParam"] = this.batchSendCtrlParam ? this.batchSendCtrlParam.toJSON() : <any>undefined;
        data["receiverInfo"] = this.receiverInfo ? this.receiverInfo.toJSON() : <any>undefined;
        data["senderInfo"] = this.senderInfo ? this.senderInfo.toJSON() : <any>undefined;
        if (this.orderItemList && this.orderItemList.constructor === Array) {
            data["orderItemList"] = [];
            for (let item of this.orderItemList)
                data["orderItemList"].push(item.toJSON());
        }
        data["driverInfo"] = this.driverInfo ? this.driverInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IStockOutOrderNotifyInput {
    ownerUserId: string;
    ownerUserName: string | undefined;
    pickCompany: string | undefined;
    pickName: string | undefined;
    pickCall: string | undefined;
    carriersName: string | undefined;
    pickId: string | undefined;
    storeCode: string;
    toStoreCode: string | undefined;
    orderCode: string;
    erpOrderCode: string | undefined;
    orderType: number | undefined;
    outboundTypeDesc: string | undefined;
    orderFlag: string | undefined;
    orderCreateTime: moment.Moment | undefined;
    sendTime: moment.Moment | undefined;
    tmsServiceCode: string | undefined;
    tmsServiceName: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    transportMode: string | undefined;
    carNo: string | undefined;
    timeZone: string | undefined;
    currency: string | undefined;
    remark: string | undefined;
    bizType: string | undefined;
    transferPriority: string | undefined;
    batchSendCtrlParam: StockOutBatchSendCtrlParam | undefined;
    receiverInfo: StockOutReceiverInfo | undefined;
    senderInfo: StockOutSenderInfo | undefined;
    orderItemList: WmsStockOutOrderItem[] | undefined;
    driverInfo: StockOutDriverInfo | undefined;
}

export class StockOutBatchSendCtrlParam implements IStockOutBatchSendCtrlParam {
    totalOrderItemCount: number | undefined;
    distributeType: number | undefined;

    constructor(data?: IStockOutBatchSendCtrlParam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalOrderItemCount = data["totalOrderItemCount"];
            this.distributeType = data["distributeType"];
        }
    }

    static fromJS(data: any): StockOutBatchSendCtrlParam {
        data = typeof data === 'object' ? data : {};
        let result = new StockOutBatchSendCtrlParam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalOrderItemCount"] = this.totalOrderItemCount;
        data["distributeType"] = this.distributeType;
        return data; 
    }
}

export interface IStockOutBatchSendCtrlParam {
    totalOrderItemCount: number | undefined;
    distributeType: number | undefined;
}

export class StockOutReceiverInfo implements IStockOutReceiverInfo {
    receiverZipCode: string | undefined;
    receiverCountry: string | undefined;
    receiverProvince: string;
    receiverCity: string;
    receiverArea: string | undefined;
    receiverCode: string | undefined;
    receiverTown: string | undefined;
    receiverAddress: string | undefined;
    receiverDivisionId: string | undefined;
    receiverName: string;
    receiverMobile: string | undefined;
    receiverPhone: string | undefined;
    receiverEmail: string | undefined;

    constructor(data?: IStockOutReceiverInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiverZipCode = data["receiverZipCode"];
            this.receiverCountry = data["receiverCountry"];
            this.receiverProvince = data["receiverProvince"];
            this.receiverCity = data["receiverCity"];
            this.receiverArea = data["receiverArea"];
            this.receiverCode = data["receiverCode"];
            this.receiverTown = data["receiverTown"];
            this.receiverAddress = data["receiverAddress"];
            this.receiverDivisionId = data["receiverDivisionId"];
            this.receiverName = data["receiverName"];
            this.receiverMobile = data["receiverMobile"];
            this.receiverPhone = data["receiverPhone"];
            this.receiverEmail = data["receiverEmail"];
        }
    }

    static fromJS(data: any): StockOutReceiverInfo {
        data = typeof data === 'object' ? data : {};
        let result = new StockOutReceiverInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiverZipCode"] = this.receiverZipCode;
        data["receiverCountry"] = this.receiverCountry;
        data["receiverProvince"] = this.receiverProvince;
        data["receiverCity"] = this.receiverCity;
        data["receiverArea"] = this.receiverArea;
        data["receiverCode"] = this.receiverCode;
        data["receiverTown"] = this.receiverTown;
        data["receiverAddress"] = this.receiverAddress;
        data["receiverDivisionId"] = this.receiverDivisionId;
        data["receiverName"] = this.receiverName;
        data["receiverMobile"] = this.receiverMobile;
        data["receiverPhone"] = this.receiverPhone;
        data["receiverEmail"] = this.receiverEmail;
        return data; 
    }
}

export interface IStockOutReceiverInfo {
    receiverZipCode: string | undefined;
    receiverCountry: string | undefined;
    receiverProvince: string;
    receiverCity: string;
    receiverArea: string | undefined;
    receiverCode: string | undefined;
    receiverTown: string | undefined;
    receiverAddress: string | undefined;
    receiverDivisionId: string | undefined;
    receiverName: string;
    receiverMobile: string | undefined;
    receiverPhone: string | undefined;
    receiverEmail: string | undefined;
}

export class StockOutSenderInfo implements IStockOutSenderInfo {
    senderZipCode: string | undefined;
    senderCountry: string | undefined;
    senderProvince: string | undefined;
    senderCity: string | undefined;
    senderArea: string | undefined;
    senderTown: string | undefined;
    senderAddress: string | undefined;
    senderDivisionId: string | undefined;
    senderName: string | undefined;
    senderMobile: string | undefined;
    senderPhone: string | undefined;
    senderEmail: string | undefined;

    constructor(data?: IStockOutSenderInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.senderZipCode = data["senderZipCode"];
            this.senderCountry = data["senderCountry"];
            this.senderProvince = data["senderProvince"];
            this.senderCity = data["senderCity"];
            this.senderArea = data["senderArea"];
            this.senderTown = data["senderTown"];
            this.senderAddress = data["senderAddress"];
            this.senderDivisionId = data["senderDivisionId"];
            this.senderName = data["senderName"];
            this.senderMobile = data["senderMobile"];
            this.senderPhone = data["senderPhone"];
            this.senderEmail = data["senderEmail"];
        }
    }

    static fromJS(data: any): StockOutSenderInfo {
        data = typeof data === 'object' ? data : {};
        let result = new StockOutSenderInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["senderZipCode"] = this.senderZipCode;
        data["senderCountry"] = this.senderCountry;
        data["senderProvince"] = this.senderProvince;
        data["senderCity"] = this.senderCity;
        data["senderArea"] = this.senderArea;
        data["senderTown"] = this.senderTown;
        data["senderAddress"] = this.senderAddress;
        data["senderDivisionId"] = this.senderDivisionId;
        data["senderName"] = this.senderName;
        data["senderMobile"] = this.senderMobile;
        data["senderPhone"] = this.senderPhone;
        data["senderEmail"] = this.senderEmail;
        return data; 
    }
}

export interface IStockOutSenderInfo {
    senderZipCode: string | undefined;
    senderCountry: string | undefined;
    senderProvince: string | undefined;
    senderCity: string | undefined;
    senderArea: string | undefined;
    senderTown: string | undefined;
    senderAddress: string | undefined;
    senderDivisionId: string | undefined;
    senderName: string | undefined;
    senderMobile: string | undefined;
    senderPhone: string | undefined;
    senderEmail: string | undefined;
}

export class WmsStockOutOrderItem implements IWmsStockOutOrderItem {
    orderItemId: string;
    ownerUserId: string;
    itemId: string;
    itemName: string;
    itemCode: string;
    inventoryType: number | undefined;
    itemQuantity: number | undefined;
    itemPrice: number | undefined;
    itemVersion: number | undefined;
    batchCode: string | undefined;
    purchaseOrderCode: string | undefined;
    dueDate: moment.Moment | undefined;
    produceDate: moment.Moment | undefined;
    produceCode: string | undefined;
    batchRemark: string | undefined;
    minDistributionQuantity: number | undefined;

    constructor(data?: IWmsStockOutOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderItemId = data["orderItemId"];
            this.ownerUserId = data["ownerUserId"];
            this.itemId = data["itemId"];
            this.itemName = data["itemName"];
            this.itemCode = data["itemCode"];
            this.inventoryType = data["inventoryType"];
            this.itemQuantity = data["itemQuantity"];
            this.itemPrice = data["itemPrice"];
            this.itemVersion = data["itemVersion"];
            this.batchCode = data["batchCode"];
            this.purchaseOrderCode = data["purchaseOrderCode"];
            this.dueDate = data["dueDate"] ? moment(data["dueDate"].toString()) : <any>undefined;
            this.produceDate = data["produceDate"] ? moment(data["produceDate"].toString()) : <any>undefined;
            this.produceCode = data["produceCode"];
            this.batchRemark = data["batchRemark"];
            this.minDistributionQuantity = data["minDistributionQuantity"];
        }
    }

    static fromJS(data: any): WmsStockOutOrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new WmsStockOutOrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderItemId"] = this.orderItemId;
        data["ownerUserId"] = this.ownerUserId;
        data["itemId"] = this.itemId;
        data["itemName"] = this.itemName;
        data["itemCode"] = this.itemCode;
        data["inventoryType"] = this.inventoryType;
        data["itemQuantity"] = this.itemQuantity;
        data["itemPrice"] = this.itemPrice;
        data["itemVersion"] = this.itemVersion;
        data["batchCode"] = this.batchCode;
        data["purchaseOrderCode"] = this.purchaseOrderCode;
        data["dueDate"] = this.dueDate ? this.dueDate.toISOString() : <any>undefined;
        data["produceDate"] = this.produceDate ? this.produceDate.toISOString() : <any>undefined;
        data["produceCode"] = this.produceCode;
        data["batchRemark"] = this.batchRemark;
        data["minDistributionQuantity"] = this.minDistributionQuantity;
        return data; 
    }
}

export interface IWmsStockOutOrderItem {
    orderItemId: string;
    ownerUserId: string;
    itemId: string;
    itemName: string;
    itemCode: string;
    inventoryType: number | undefined;
    itemQuantity: number | undefined;
    itemPrice: number | undefined;
    itemVersion: number | undefined;
    batchCode: string | undefined;
    purchaseOrderCode: string | undefined;
    dueDate: moment.Moment | undefined;
    produceDate: moment.Moment | undefined;
    produceCode: string | undefined;
    batchRemark: string | undefined;
    minDistributionQuantity: number | undefined;
}

export class StockOutDriverInfo implements IStockOutDriverInfo {
    driverName: string | undefined;
    driverIdentityId: string | undefined;
    driverPhone: string | undefined;
    vehicleType: number | undefined;
    vehicleLoad: number | undefined;
    licensePlate: string | undefined;

    constructor(data?: IStockOutDriverInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.driverName = data["driverName"];
            this.driverIdentityId = data["driverIdentityId"];
            this.driverPhone = data["driverPhone"];
            this.vehicleType = data["vehicleType"];
            this.vehicleLoad = data["vehicleLoad"];
            this.licensePlate = data["licensePlate"];
        }
    }

    static fromJS(data: any): StockOutDriverInfo {
        data = typeof data === 'object' ? data : {};
        let result = new StockOutDriverInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["driverName"] = this.driverName;
        data["driverIdentityId"] = this.driverIdentityId;
        data["driverPhone"] = this.driverPhone;
        data["vehicleType"] = this.vehicleType;
        data["vehicleLoad"] = this.vehicleLoad;
        data["licensePlate"] = this.licensePlate;
        return data; 
    }
}

export interface IStockOutDriverInfo {
    driverName: string | undefined;
    driverIdentityId: string | undefined;
    driverPhone: string | undefined;
    vehicleType: number | undefined;
    vehicleLoad: number | undefined;
    licensePlate: string | undefined;
}

export class StockOutOrderNotifyOutput implements IStockOutOrderNotifyOutput {
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;

    constructor(data?: IStockOutOrderNotifyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orderCode = data["orderCode"];
            this.success = data["success"];
            this.errorCode = data["errorCode"];
            this.errorMsg = data["errorMsg"];
        }
    }

    static fromJS(data: any): StockOutOrderNotifyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StockOutOrderNotifyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orderCode"] = this.orderCode;
        data["success"] = this.success;
        data["errorCode"] = this.errorCode;
        data["errorMsg"] = this.errorMsg;
        return data; 
    }
}

export interface IStockOutOrderNotifyOutput {
    orderCode: string | undefined;
    success: boolean | undefined;
    errorCode: string | undefined;
    errorMsg: string | undefined;
}

export enum IncomeStatisticsDateInterval {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum IncomeStatisticsDateInterval2 {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum State {
    _0 = 0, 
    _1 = 1, 
}

export enum SalesSummaryDatePeriod {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum SalesSummaryDatePeriod2 {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum DefaultTimezoneScope {
    _1 = 1, 
    _2 = 2, 
    _4 = 4, 
    _7 = 7, 
}

export enum IsTenantAvailableOutputState {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum EntityChangeListDtoChangeType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
}

export enum FriendDtoState {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoSide {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoReadState {
    _1 = 1, 
    _2 = 2, 
}

export enum ChatMessageDtoReceiverReadState {
    _1 = 1, 
    _2 = 2, 
}

export enum UserNotificationState {
    _0 = 0, 
    _1 = 1, 
}

export enum TenantNotificationSeverity {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
    _4 = 4, 
}

export class AdditionalData implements IAdditionalData {
    paypal: { [key: string] : string; } | undefined;

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {};
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal[key] = data["Paypal"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        return data; 
    }
}

export interface IAdditionalData {
    paypal: { [key: string] : string; } | undefined;
}

export enum CreatePaymentDtoEditionPaymentType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum CreatePaymentDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum CreatePaymentDtoSubscriptionPaymentGatewayType {
    _1 = 1, 
}

export enum ExecutePaymentDtoGateway {
    _1 = 1, 
}

export enum ExecutePaymentDtoEditionPaymentType {
    _0 = 0, 
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum ExecutePaymentDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum TenantLoginInfoDtoPaymentPeriodType {
    _30 = 30, 
    _365 = 365, 
}

export enum RegisterTenantInputSubscriptionStartType {
    _1 = 1, 
    _2 = 2, 
    _3 = 3, 
}

export enum RegisterTenantInputGateway {
    _1 = 1, 
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}